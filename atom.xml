<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEAF 周刊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weafteam.github.io/"/>
  <updated>2018-04-22T07:32:03.948Z</updated>
  <id>http://weafteam.github.io/</id>
  
  <author>
    <name>WEAF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>唯密文解密（针对Vigenere加密）</title>
    <link href="http://weafteam.github.io/posts/899ccb0/"/>
    <id>http://weafteam.github.io/posts/899ccb0/</id>
    <published>2018-04-21T01:38:12.000Z</published>
    <updated>2018-04-22T07:32:03.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上次说到了Vigenere加密以及解密的算法，但是如何破译这样的密码，也是很有意思的，这篇博客就是实现一个这样的破译，主要针对的是通过Vigenere加密的密文，那么就开始吧~</p></blockquote><h1 id="任务要求">任务要求：</h1><ul><li><pre><code> a.编程实现Vigenere加密/解密系统，并分析和评估该算法的安全性。</code></pre></li><li><pre><code> b.编程实现唯密文破译系统，能够破译密钥为2到4个字符的Vigenere密文，并分析如何加快破译速度。</code></pre></li><li>时间要求： 布置任务后，在3周之内完成。</li><li>提交结果：已设计并测试好的程序，包括源码、可执行程序、测试数据集、实验报告。</li></ul><h1 id="原理介绍">原理介绍：</h1><p>按照我们之前的说法，我们先介绍一下Caesar加密的缺点。对于一个稍微有点点密码学功底的人来说，Caesar密码的安全强度几乎为零，正如我们是上篇博客所讲的Caesar加密，加密的密钥充其量也就24个，也就是说，不管移动多少个字符，最多进行24次猜解就可以破译出来。</p><p>当然，这只是一种解密方法，也是比较笨的一种方法，而且这种方法并不适用于我们的Vigenere密码破解，因为我们没办法列举出所有的情况。</p><p>这里我们介绍破解Caesar密码的另一类方法，称为（字母）频度分析法。</p><p>假设大家都知道，英语中的字母出现概率是有差别的，其实对于一种特定的自然语言，如果文本足够长，那么各个字母出现的概率就是相对稳定的，具体的概率统计如下图所示：</p><p><img src="https://i.loli.net/2018/04/21/5adaa41cbbb56.png" alt="percent.png"></p><p>这样我们根据以上的频度表，以及根据我们的Caesar密文中的统计出来的各个词的拼读，对应一下就可以找到密文对应的明文，再然后对应密文与明文就可以找到相应的加密的密钥。很简单吧，其实能想到这个想法并不简单的。</p><p>由上一篇的博客介绍，你应该知道了Vigenere密码分解之后其实就是多个Caesar密码。所以我们如果知道密钥的长度，每隔这个长度将原来的Vigenere密文分解为多个Caesar密文，再做上述的工作，是不是就完成了我们的破译工作？思路就是这样，但是怎么确定我们的密钥长度？那么我们接下来就讲讲怎么解决这个问题吧。</p><h1 id="确定密钥长度">确定密钥长度</h1><p>这个在网上搜集到的资料其实是有两种方法的。分别称为Kasiski测试法和Friedman测试法，但是本文给到的代码是基于第二个方法的，不过在此之前，我们还是先讲讲这两个方法的思路吧。</p><h2 id="kasiski测试法">Kasiski测试法</h2><p>Kasiski测试法是由Friedrich Kasiski于1863年给出了其描述，然而早在约1854年这一方法就由Charles Babbage首先发现。</p><p>它的思想是基于这样的一个事实：两个相同的明文段加密成相同的密文段，它们之间的距离为Length，那么密钥的长度就是距离Length的约数。</p><p>而当密文的长度很长时，我们便可以多找几组这样拥有重复密文段，找出他们间距的相同约数就是密钥的长度。</p><p>关于这个方法的代码，本文并未涉及，大家有兴趣可自行查阅资料实现。</p><p>另：机智的你也许发现了，我们这种方法其实并没有涉及到我们刚才说的统计频度，所以我们的重点不是这个方法，接下来就是本文的重点了。</p><h2 id="friedman测试法">Friedman测试法</h2><p>首先我们讲一个概念：重合指数（IC，index of coincidence）。百度一下这个概念的话，搜到的结果可能不是令人很满意，我也是找了很多资料，感觉如下的概念说的很清楚，分享给大家。</p><p>重合指数表示：两个随机选出的字母是相同的概率，对于我们的英文字母来说，即以上概率即为随机选出两个A的概率+随机选出两个B的概率+….+随机选出两个Z的概率。</p><p>前人也为我们统计出了这个数字，为0.65。</p><blockquote><p>即 P(A)^2 + P(B)^2 + P(C)^2 + … + P(Z)^2 = 0.65.</p></blockquote><p>而利用这一概念推测密钥长度的原理为：对于一个Caesar密码的序列，由于所有字母的位移程度是一样的，所以密文的重合指数等于原文的重合指数。</p><p>将这一概念迁移到我们的Vigenere密文上，我们只要计算不同密钥长度下的重合指数，只要重合指数接近期望的0.65时，我们便可以推测当前的长度就是我们的密钥长度。</p><p><strong>举个例子：</strong></p><p>密文为：AAABBCCDDDDEEEFG</p><p>首先我们测试密钥长度=1，首先统计上述密文中每个字母出现的次数（A-Z）：</p><p>A：3 B：2 C：2 D：4 E：3 F:1 G:1 H:0 … Z：0</p><p>然后我们根据上述公式计算重合指数P，如果 P ！= 0.65，我们就尝试密钥长度2。</p><p>假设为2的话，将上述的密文分成两组：</p><p>组1：A A B C D D E F</p><p>组2：A B C D D E E G</p><p>再分别计算重合指数，如果这两个的重合指数都接近于0.65，那么我们就可以基本确定密钥的长度为2了。如果不是，那么继续往下分。</p><p>理论上来说，我们得到的密文长度越长，通过这个方法分析得到的效果会更好，实际上在我测试的结果中，也确实符合刚才的说法。</p><h1 id="实现">实现</h1><p><strong>Friedman测试法确定密钥长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// Friedman测试法确定密钥长度</span><br><span class="line">   public int Friedman(String ciphertext) &#123;</span><br><span class="line">       int keyLength = 1; // 猜测密钥长度</span><br><span class="line">       double[] IC; // 重合指数</span><br><span class="line">       double average; // 平均重合指数</span><br><span class="line">       ArrayList&lt;String&gt; cipherGroup; // 密文分组</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           IC = new double[keyLength];</span><br><span class="line">           cipherGroup = new ArrayList&lt;String&gt;();</span><br><span class="line">           average = 0;</span><br><span class="line"></span><br><span class="line">           // 1 先根据密钥长度分组</span><br><span class="line">           for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">               StringBuffer temporaryGroup = new StringBuffer();</span><br><span class="line">               for (int j = 0; i + j * keyLength &lt; ciphertext.length(); ++j) &#123;</span><br><span class="line">                   temporaryGroup.append(ciphertext.charAt(i + j * keyLength));</span><br><span class="line">               &#125;</span><br><span class="line">               cipherGroup.add(temporaryGroup.toString());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 2 再计算每一组的重合指数</span><br><span class="line">           for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">               String subCipher = new String(cipherGroup.get(i)); // 子串</span><br><span class="line">               HashMap&lt;Character, Integer&gt; occurrenceNumber = new HashMap&lt;Character, Integer&gt;(); // 字母及其出现的次数</span><br><span class="line"></span><br><span class="line">               // 2.1 初始化字母及其次数键值对</span><br><span class="line">               for (int h = 0; h &lt; 26; ++h) &#123;</span><br><span class="line">                   occurrenceNumber.put((char) (h + 65), 0);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 2.2 统计每个字母出现的次数</span><br><span class="line">               for (int j = 0; j &lt; subCipher.length(); ++j) &#123;</span><br><span class="line">                   occurrenceNumber.put(subCipher.charAt(j), occurrenceNumber.get(subCipher.charAt(j)) + 1);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 2.3 计算重合指数</span><br><span class="line">               double denominator = Math.pow((double) subCipher.length(), 2);</span><br><span class="line">               for (int k = 0; k &lt; 26; ++k) &#123;</span><br><span class="line">                   double o = (double) occurrenceNumber.get((char) (k + 65));</span><br><span class="line">                   IC[i] += o * (o - 1);</span><br><span class="line">               &#125;</span><br><span class="line">               IC[i] /= denominator;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 3 判断退出条件,重合指数的平均值是否大于0.065</span><br><span class="line">           for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">               average += IC[i];</span><br><span class="line">           &#125;</span><br><span class="line">           average /= (double) keyLength;</span><br><span class="line">           if (average &gt;= 0.06) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               keyLength++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; // while--end</span><br><span class="line">       </span><br><span class="line">       return keyLength;</span><br><span class="line">   &#125;// Friedman--end</span><br></pre></td></tr></table></figure><p><strong>破译密文</strong></p><p>这里给出来的是打印出来了具体的密钥和明文，实际上可以直接写一个类，类中设计两个属性值，一个密钥属性，一个明文属性，直接赋值下就可以了。相信机智的你可以完成这个操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public void decryptCipher(int keyLength, String ciphertext) &#123;</span><br><span class="line">        int[] key = new int[keyLength];</span><br><span class="line">        ArrayList&lt;String&gt; cipherGroup = new ArrayList&lt;String&gt;();</span><br><span class="line">        double[] probability = new double[] &#123; 0.082, 0.015, 0.028, 0.043, 0.127, 0.022, 0.02, 0.061, 0.07, 0.002, 0.008,</span><br><span class="line">                0.04, 0.024, 0.067, 0.075, 0.019, 0.001, 0.06, 0.063, 0.091, 0.028, 0.01, 0.023, 0.001, 0.02, 0.001 &#125;;</span><br><span class="line"></span><br><span class="line">        // 1 先根据密钥长度分组</span><br><span class="line">        for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">            StringBuffer temporaryGroup = new StringBuffer();</span><br><span class="line">            for (int j = 0; i + j * keyLength &lt; ciphertext.length(); ++j) &#123;</span><br><span class="line">                temporaryGroup.append(ciphertext.charAt(i + j * keyLength));</span><br><span class="line">            &#125;</span><br><span class="line">            cipherGroup.add(temporaryGroup.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2 确定密钥</span><br><span class="line">        for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">            double MG; // 重合指数</span><br><span class="line">            int flag; // 移动位置</span><br><span class="line">            int g = 0; // 密文移动g个位置</span><br><span class="line">            HashMap&lt;Character, Integer&gt; occurrenceNumber; // 字母出现次数</span><br><span class="line">            String subCipher; // 子串</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                MG = 0;</span><br><span class="line">                flag = 65 + g;</span><br><span class="line">                subCipher = new String(cipherGroup.get(i));</span><br><span class="line">                occurrenceNumber = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">                // 1.1 初始化字母及其次数</span><br><span class="line">                for (int h = 0; h &lt; 26; ++h) &#123;</span><br><span class="line">                    occurrenceNumber.put((char) (h + 65), 0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 1.2 统计字母出现次数</span><br><span class="line">                for (int j = 0; j &lt; subCipher.length(); ++j) &#123;</span><br><span class="line">                    occurrenceNumber.put(subCipher.charAt(j), occurrenceNumber.get(subCipher.charAt(j)) + 1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 1.3 计算重合指数</span><br><span class="line">                for (int k = 0; k &lt; 26; ++k, ++flag) &#123;</span><br><span class="line">                    double p = probability[k];</span><br><span class="line">                    flag = (flag == 91) ? 65 : flag;</span><br><span class="line">                    double f = (double) occurrenceNumber.get((char) flag) / subCipher.length();</span><br><span class="line">                    MG += p * f;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 1.4 判断退出条件</span><br><span class="line">                if (MG &gt;= 0.055) &#123;</span><br><span class="line">                    key[i] = g;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ++g;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; // while--end</span><br><span class="line">        &#125; // for--end</span><br><span class="line"></span><br><span class="line">        // 3 打印密钥</span><br><span class="line">        StringBuffer keyString = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; keyLength; ++i) &#123;</span><br><span class="line">            keyString.append((char) (key[i] + 65));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;\n密钥为: &quot; + keyString.toString());</span><br><span class="line"></span><br><span class="line">        // 4 解密</span><br><span class="line">        StringBuffer plainBuffer = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; ciphertext.length(); ++i) &#123;</span><br><span class="line">            int keyFlag = i % keyLength;</span><br><span class="line">            int change = (int) ciphertext.charAt(i) - 65 - key[keyFlag];</span><br><span class="line">            char plainLetter = (char) ((change &lt; 0 ? (change + 26) : change) + 65);</span><br><span class="line">            plainBuffer.append(plainLetter);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;\n明文为：\n&quot; + plainBuffer.toString().toLowerCase());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p><a href="https://blog.csdn.net/limisky/article/details/16885959" target="_blank" rel="noopener">维吉尼亚密码及其破解</a></p><p><a href="https://blog.csdn.net/white_idiot/article/details/61201864" target="_blank" rel="noopener">【密码学】维吉尼亚密码加解密原理及其破解算法Java实现</a></p><p>以上是本次博客的全部内容，感谢驻足~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;上次说到了Vigenere加密以及解密的算法，但是如何破译这样的密码，也是很有意思的，这篇博客就是实现一个这样的破译，主要针对的是通过Vigenere加密的密文，那么就开始吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1
        
      
    
    </summary>
    
      <category term="密码学" scheme="http://weafteam.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://weafteam.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux下MySQL安装</title>
    <link href="http://weafteam.github.io/posts/2cd32dfc/"/>
    <id>http://weafteam.github.io/posts/2cd32dfc/</id>
    <published>2018-04-18T09:57:12.000Z</published>
    <updated>2018-04-22T07:28:18.415Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始给大家分享Java相关的技术开发知识，在以后的开发和学习中，还希望大家多多指教，对于我发表的相关内容，如有错误，请大家指出来，一起学习。 更要记住这句话：Stay Hungry, Stay Foolish.</p><h2 id="一redis的安装">一、Redis的安装</h2><p>为了方便教程这里先简单介绍Redis的安装。</p><h3 id="windows平台的安装">1. windows平台的安装</h3><p>现在官网已经不提供windows平台的下载，所以只能去github上下载安装 <a href="https://github.com/MSOpenTech/redis/tags" target="_blank" rel="noopener">github下载网址</a> 进入之后选择好版本点击msi下载 <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-1.png" alt="Redis"> 然后双击安装。 默认是直接运行的。 可以通过控制台访问如 <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-2.png" alt="Redis"> 具体语法可以在相关网上查阅。 ### 2. Linux平台的安装 直接到官网下载 <a href="http://redis.io/download" target="_blank" rel="noopener">Redis.io</a> 解压并安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span><br><span class="line">tar xzf redis-4.0.9.tar.gz</span><br><span class="line">cd redis-4.0.9</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>服务端运行脚本 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure></p><p>客户端运行脚本 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-cli</span><br></pre></td></tr></table></figure></p><h3 id="springboot2.0相关配置">3. SpringBoot2.0相关配置</h3><p>pom文件加入以下依赖 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>我这里SpringBoot的配置文件使用的是YAML。 在相应环境中配置Redis ##### application-local.yml <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        name: test</span><br><span class="line">        driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/local?useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    redis:</span><br><span class="line">          database: 0</span><br><span class="line">          host: localhost</span><br><span class="line">          port: 6379</span><br><span class="line">          jedis:</span><br><span class="line">            pool:</span><br><span class="line">              min-idle: 0</span><br><span class="line">              max-idle: 8</span><br><span class="line">              max-active: 8</span><br><span class="line">              max-wait: -1ms</span><br></pre></td></tr></table></figure></p><h3 id="代码级别配置">4.代码级别配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.controller.entry.entity.AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.convert.KeyspaceConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.repository.configuration.EnableRedisRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 18:35 2018/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="comment">//增加Respository支持，并使其支持@TimeToLive</span></span><br><span class="line"><span class="meta">@EnableRedisRepositories</span>(keyspaceConfiguration = RedisCacheConfig.MyKeyspaceConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(connectionFactory).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public RedisConnectionFactory connectionFactory() &#123;</span></span><br><span class="line"><span class="comment">//        return new JedisConnectionFactory();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;?, ?&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; template = <span class="keyword">new</span> RedisTemplate&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;</span></span><br><span class="line"><span class="comment">//        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;Object, Object&gt;();</span></span><br><span class="line"><span class="comment">//        redisTemplate.setConnectionFactory(redisConnectionFactory);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());//key序列化</span></span><br><span class="line"><span class="comment">//        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer(Object.class));  //value序列化</span></span><br><span class="line"><span class="comment">//        redisTemplate.afterPropertiesSet();</span></span><br><span class="line"><span class="comment">//        return redisTemplate;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKeyspaceConfiguration</span> <span class="keyword">extends</span> <span class="title">KeyspaceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Iterable&lt;KeyspaceSettings&gt; <span class="title">initialConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> KeyspaceSettings(AccessToken.class, <span class="string">"accessToken"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存对象AccessToken <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisHash;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.TimeToLive;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 14:26 2018/4/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RedisHash</span>(<span class="string">"accessToken"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessToken</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    String id;</span><br><span class="line">    String accessToken;</span><br><span class="line">    <span class="meta">@TimeToLive</span></span><br><span class="line">    Long expire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建Respository <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.controller.entry.entity.AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 14:34 2018/4/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">// 继承自CURD，里边有最基本的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessTokenRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">AccessToken</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来完成自己的业务服务类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.controller.entry.entity.AccessToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 14:50 2018/4/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessTokenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AccessToken <span class="title">save</span><span class="params">(AccessToken accessToken)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(AccessToken accessToken)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AccessToken <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务服务类的实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.controller.entry.entity.AccessToken;</span><br><span class="line"><span class="keyword">import</span> com.xxx.dao.repository.AccessTokenRepository;</span><br><span class="line"><span class="keyword">import</span> com.xxx.service.AccessTokenService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 14:52 2018/4/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accessTokenService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessTokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccessTokenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccessTokenRepository repo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccessToken <span class="title">save</span><span class="params">(AccessToken accessToken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  repo.save(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AccessToken accessToken)</span> </span>&#123;</span><br><span class="line">        repo.delete(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccessToken <span class="title">get</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Optional&lt;AccessToken&gt; accessToken = repo.findById(id);</span><br><span class="line">        <span class="keyword">return</span> accessToken.orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上完成了整个整合过程。 ### 5. 简单的测试 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.controller.entry.entity.AccessToken;</span><br><span class="line"><span class="keyword">import</span> com.xxx.service.AccessTokenService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ：yaxuSong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 15:16 2018/4/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccessTokenService accessTokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AccessToken accessToken = <span class="keyword">new</span> AccessToken();</span><br><span class="line">        accessToken.setAccessToken(<span class="string">"dadaadadsdadewqeqfskksdbfdbkfsdkdajdhwke2elhsbcslc/DNDAWDAWWAFEWFSD23E2342"</span>);</span><br><span class="line">        accessToken.setExpire(<span class="number">60L</span>);</span><br><span class="line"><span class="comment">//单位 秒</span></span><br><span class="line">        AccessToken at = accessTokenService.save(accessToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"成功"</span>+<span class="string">"键值为："</span>+at.getId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        AccessToken accessToken = accessTokenService.get(id);</span><br><span class="line">        <span class="keyword">return</span> accessToken==<span class="keyword">null</span>?<span class="string">"已过期"</span>:accessToken.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><p><img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-3.png" alt="Redis"></p><p>我这里添加了一个过期时间为60s的token。 我们通过查看可以看到时间的变化</p><p>第一次查询： <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-4.png" alt="Redis"> 第二次查询： <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-5.png" alt="Redis"> 第三次查询： <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-6.png" alt="Redis"></p><p>我们查看下本地Rdis所有键值情况： <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-7.png" alt="Redis"> 过一段时间后查询： <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-9.png" alt="Redis"> 我们发现之前还存在键值id为c07cde6a-aec7-40f3-ad39-41862209bc9f的，但是内容没有了。 后来查询的就被删除了（过期后不会直接删除，会稍有延迟，只有id存在，其他都已被删除）</p><p>我们看到键值为：d2b97d54-1c8b-4803-8f60-6aaf3384fc32的是我之前存的TTL=7200s的。 <img src="https://weaf.oss-cn-beijing.aliyuncs.com/redis-8.png" alt="Redis"></p><p>至此所有相关的内容就介绍完了。</p><p>本文参考地址：<a href="https://docs.spring.io/spring-data/redis/docs/2.0.5.RELEASE/reference/html/" target="_blank" rel="noopener">Spring-data-redis</a></p>]]></content>
    
    <summary type="html">
    
      Linux下MySQL安装
    
    </summary>
    
      <category term="JAVA" scheme="http://weafteam.github.io/categories/JAVA/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下MySQL安装</title>
    <link href="http://weafteam.github.io/posts/2cd32dfc/"/>
    <id>http://weafteam.github.io/posts/2cd32dfc/</id>
    <published>2018-04-17T04:07:12.000Z</published>
    <updated>2018-04-22T07:28:18.414Z</updated>
    
    <content type="html"><![CDATA[<p>接下来我将介绍3种方法安装MySQL</p><h1 id="第一种">第一种</h1><h2 id="一查看是否安装了mysql">一、查看是否安装了MySQL</h2><p>使用命令： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure></p><p>如果使用centos，可能会出现冲突，解决冲突需要卸载mariadb 首先查看是否安装了Mariadb <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>然后卸载 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mariadb-libs-5.5.56-2.el7.x86_64</span><br></pre></td></tr></table></figure></p><p>强制卸载(可选): <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-1.png" alt="mysql-1"> 二、如果安装了需删除已安装版本 —— 删除命令： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps 包名</span><br><span class="line">( rpm -ev mysql-4.1.12-3.RHEL4.1 )</span><br></pre></td></tr></table></figure></p><p>删除老版本mysql的开发头文件和库 命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -fr /usr/lib/mysql</span><br><span class="line">rm -fr /usr/include/mysql</span><br></pre></td></tr></table></figure></p><p>注意：卸载后/var/lib/mysql中的数据及/etc/my.cnf不会删除，如果确定没用后就手工删除 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/my.cnf</span><br><span class="line">rm -fr /var/lib/mysql</span><br></pre></td></tr></table></figure></p><h2 id="三安装mysql准备环境">三、安装mysql准备环境</h2><p>我自mysql官网下载通用的Linux版本安装包 mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz 将下载好的包放在 /usr/local 目录下，或者执行命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-2.png" alt="mysql-2"></p><p>解压下载的文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>将解压之后的所有文件移动到/usr/local/mysql <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ./mysql-5.7.20-linux-glibc2.12-x86_64/* ./mysql</span><br></pre></td></tr></table></figure></p><p>为mysql创建系统用户(可选，新版本会自动创建相应用户) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure></p><p>//-r参数表示mysql用户是系统用户，不可用于登录系统 并变更mysql安装目录的所属用户和用户组 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql mysql</span><br><span class="line">// -R 迭代处理</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-3.png" alt="mysql-3"> 四、 安装和初始化 ——</p><p>初始化数据库 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --lc_messages_dir=/usr/local/mysql/share --lc_messages=en_US</span><br></pre></td></tr></table></figure></p><p>记录刚刚输出的密码： jk9tEao&lt;94MC <img src="http://us-forever.com/img/linuxMySQL-4.png" alt="mysql-4"></p><p>配置/etc/my.cnf</p><p><a href="http://us-forever.com/file/my.cnf" target="_blank" rel="noopener">my.cnf</a></p><h2 id="五-启动登录和设置密码">五、 启动登录和设置密码</h2><p>切换到mysql安装目录的bin下启动 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld_safe --user=mysql</span><br></pre></td></tr></table></figure></p><p>启动后可能无法使用当前窗口</p><p>登录进去设置新的密码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysql -u root -p</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">"root"</span>);</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p><img src="http://us-forever.com/img/linuxMySQL-5.png" alt="mysql-5"></p><p>六、 添加到服务</p><p>切换到 support-files目录下，并执行以下命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure></p><p>然后停止当前进程，使用服务启动mysql <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure></p><p>并添加mysql环境变量 在 /etc/profile 的文件末尾追加： export PATH=$PATH:/usr/local/mysql/bin 保存后执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>最后使用新密码登录到mysql <img src="http://us-forever.com/img/linuxMySQL-6.png" alt="mysql-6"></p><h1 id="第二种">第二种</h1><h2 id="一查看是否安装了mysql-1">一、查看是否安装了MySQL</h2><p>使用命令： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure></p><p>如果使用centos，可能会出现冲突，解决冲突需要卸载mariadb 首先查看是否安装了Mariadb <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br></pre></td></tr></table></figure></p><!--more--><p>然后卸载 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mariadb-libs-5.5.56-2.el7.x86_64</span><br></pre></td></tr></table></figure></p><p>强制卸载(可选): <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-1.png" alt="mysql-1"> 二、如果安装了需删除已安装版本 —— 删除命令： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps 包名</span><br><span class="line">( rpm -ev mysql-4.1.12-3.RHEL4.1 )</span><br></pre></td></tr></table></figure></p><p>删除老版本mysql的开发头文件和库 命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -fr /usr/lib/mysql</span><br><span class="line">rm -fr /usr/include/mysql</span><br></pre></td></tr></table></figure></p><p>注意：卸载后/var/lib/mysql中的数据及/etc/my.cnf不会删除，如果确定没用后就手工删除 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/my.cnf</span><br><span class="line">rm -fr /var/lib/mysql</span><br></pre></td></tr></table></figure></p><p>三、准备安装的环境 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.20-1.el7.x86_64.rpm-bundle.tar 或者用自己准备好的包 mysql-5.7.20-1.el7.x86_64.rpm-bundle.tar 解压包 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf mysql-5.7.20-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure></p><p>然后按照以下顺序安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.20-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-5.7.20-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-5.7.20-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>四、启动并修改密码 安装完成后就可以启动服务了 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure></p><p>启动后查看配置文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-1-2.png" alt="linuxMySQL-1-2.png"> 找打log文件 进入查找默认root密码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-1-3.png"></p><p>使用一下命令登录并修改密码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>修改密码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;newpass&apos;);</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p><p><img src="http://us-forever.com/img/linuxMySQL-1-4.png"></p><h1 id="第三种">第三种</h1><h2 id="一查看是否安装了mysql数据库">一、查看是否安装了MySQL数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br></pre></td></tr></table></figure><p><img src="http://us-forever.com/img/mysql1.png"> 卸载 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql-libs-5.1.71-1.el6.x86_64</span><br></pre></td></tr></table></figure></p><p>二、安装 安装一下包 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh MySQL-devel-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-client-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-server-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-embedded-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-shared-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-shared-compat-5.6.23-1.linux_glibc2.5.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>三、启动登录设置密码 使用以下命令开启服务</p><pre><code>service mysql start</code></pre><p>获取初始密码： <img src="http://us-forever.com/img/mysql2.png"> 使用root登录</p><pre><code>mysql -uroot -p</code></pre><p>然后试用一下命令设置密码</p><pre><code>SET PASSWORD = PASSWORD(&#39;123456&#39;);</code></pre>]]></content>
    
    <summary type="html">
    
      Linux下MySQL安装
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>chapter-05-AIR</title>
    <link href="http://weafteam.github.io/posts/7b0ee3f1/"/>
    <id>http://weafteam.github.io/posts/7b0ee3f1/</id>
    <published>2018-04-15T14:14:23.000Z</published>
    <updated>2018-04-22T07:28:18.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-基础2">TensorFlow 基础（2）</h1><p>今天有和大家见面了，今天的文章可能内容有点少，这周有很多事情，所以少写点。下一周我尽量多写点。弥补大家。那么我们今天闲话少说，直接开始今天的TensorFlow的基础介绍。接着上一节继续讲起。</p><ol type="1"><li>Loss Functions</li></ol><blockquote><p>今天这个开头就是最常用的损失函数的实现，使用。主要涉及到两种损失函数的设计，数值预测的回归损失函数，还有分类的损失函数设计。那么我们直接开始我们的实现，有什么难点我会注释。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们像往常一场导入我们需要的模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line">x_vals = tf.linspace(<span class="number">-1.</span>, <span class="number">1.</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">target = tf.constant(<span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># l2 loss 和l2范数差一个平方根</span></span><br><span class="line">l2_y_vals = tf.square(target - x_vals)</span><br><span class="line">l2_y_out = sess.run(l2_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># l1 loss 就是l1范数</span></span><br><span class="line">l1_y_vals = tf.abs(target - x_vals)</span><br><span class="line">l1_y_out = sess.run(l1_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pseudo-Huber loss 为了让loss更加的光滑一些</span></span><br><span class="line"><span class="comment"># 具体看公式一</span></span><br><span class="line">delta = tf.constant(<span class="number">0.25</span>)</span><br><span class="line">phuber1_y_vals = tf.multiply(tf.square(delta), tf.sqrt(<span class="number">1.</span> + tf.square((target - x_vals) / delta)) - <span class="number">1.</span>)</span><br><span class="line">phuber1_y_out = sess.run(phuber1_y_vals)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delta2 = tf.constant(<span class="number">5.</span>)</span><br><span class="line">phuber2_y_vals = tf.multiply(tf.square(delta2), tf.sqrt(<span class="number">1.</span> + tf.square((target - x_vals)/delta2)) - <span class="number">1.</span>)</span><br><span class="line">phuber2_y_out = sess.run(phuber2_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出这些回归损失函数</span></span><br><span class="line">x_array = sess.run(x_vals)</span><br><span class="line">plt.plot(x_array, l2_y_out, <span class="string">'b-'</span>, label=<span class="string">'L2 Loss'</span>)</span><br><span class="line">plt.plot(x_array, l1_y_out, <span class="string">'r--'</span>, label=<span class="string">'L1 Loss'</span>)</span><br><span class="line">plt.plot(x_array, phuber1_y_out, <span class="string">'k-.'</span>, label=<span class="string">'P-Huber Loss (0.25)'</span>)</span><br><span class="line">plt.plot(x_array, phuber2_y_out, <span class="string">'g:'</span>, label=<span class="string">'P-Huber Loss (5.0)'</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.2</span>, <span class="number">0.4</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'lower right'</span>, prop=&#123;<span class="string">'size'</span>: <span class="number">11</span>&#125;)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 你能从后面的两个损失函数中得到什么规律呢？</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Various predicted X values</span></span><br><span class="line">x_vals = tf.linspace(<span class="number">-3.</span>, <span class="number">5.</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target of 1.0</span></span><br><span class="line">target = tf.constant(<span class="number">1.</span>)</span><br><span class="line">targets = tf.fill([<span class="number">500</span>,], <span class="number">1.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类损失函数</span></span><br><span class="line"><span class="comment"># Hinge Loss 合页损失函数</span></span><br><span class="line"><span class="comment"># 具体请见公式二</span></span><br><span class="line">hinge_y_vals = tf.maximum(<span class="number">0.</span>, <span class="number">1.</span> - tf.multiply(target, x_vals))</span><br><span class="line">hinge_y_out = sess.run(hinge_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉熵损失</span></span><br><span class="line">xentropy_y_vals = - tf.multiply(target, tf.log(x_vals)) - tf.multiply((<span class="number">1.</span> - target), tf.log(<span class="number">1.</span> - x_vals))</span><br><span class="line">xentropy_y_out = sess.run(xentropy_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sigmoid 交叉熵</span></span><br><span class="line">x_val_input = tf.expand_dims(x_vals, <span class="number">1</span>)</span><br><span class="line">target_input = tf.expand_dims(targets, <span class="number">1</span>)</span><br><span class="line">xentropy_sigmoid_y_vals = tf.nn.softmax_cross_entropy_with_logits(logits = x_val_input, labels = target_input)</span><br><span class="line">xentropy_sigmoid_y_out = sess.run(xentropy_sigmoid_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重softmax 交叉熵损失函数</span></span><br><span class="line">weight = tf.constant(<span class="number">0.5</span>)</span><br><span class="line">xentropy_weighted_y_vals = tf.nn.weighted_cross_entropy_with_logits(x_vals, targets, weight)</span><br><span class="line">xentropy_weighted_y_out = sess.run(xentropy_weighted_y_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出这些损失函数</span></span><br><span class="line">x_array = sess.run(x_vals)</span><br><span class="line">plt.plot(x_array, hinge_y_out, <span class="string">'b-'</span>, label=<span class="string">'Hinge Loss'</span>)</span><br><span class="line">plt.plot(x_array, xentropy_y_out, <span class="string">'r--'</span>, label=<span class="string">'Cross Entropy Loss'</span>)</span><br><span class="line">plt.plot(x_array, xentropy_sigmoid_y_out, <span class="string">'k-.'</span>, label=<span class="string">'Cross Entropy Sigmoid Loss'</span>)</span><br><span class="line">plt.plot(x_array, xentropy_weighted_y_out, <span class="string">'g:'</span>, label=<span class="string">'Weighted Cross Entropy Loss (x0.5)'</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#plt.xlim(-1, 3)</span></span><br><span class="line">plt.legend(loc=<span class="string">'lower right'</span>, prop=&#123;<span class="string">'size'</span>: <span class="number">11</span>&#125;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体损失函数是干嘛用的，那就是为了具体的数据预测给提供一个最优化的目标，为了让每一类任务有一个最小化目标而构造出来的loss函数，在机器学习里面最重要的其实有一项就是损失函数的设计，设计一个好的损失函数，会让我们的网络更加的稳定，更加容易收敛和收敛到一个相对最优值</span></span><br><span class="line"><span class="comment"># 没有掌握这些基本概念的，希望自己先找一些这方面的知识来看一看，然后再理解的写代码，这样会事半功倍。</span></span><br></pre></td></tr></table></figure><blockquote><p>公式一：</p></blockquote><p><span class="math display">\[L_{\delta}(i) = {\delta}^2 (\sqrt{1 + (a/{\delta})^2} - 1)\]</span></p><blockquote><p>公式二：</p></blockquote><p><span class="math display">\[max(0, 1 - (pre - y))\]</span></p><blockquote><p>公式三：</p></blockquote><p><span class="math display">\[L = -actual * (log(pre)) - (1- actual)(log(1-pre))\]</span></p><blockquote><p>公式四：</p></blockquote><p><span class="math display">\[L = -actual * (log(sigmoid(pre))) - (1- actual)(log(1- sigmoid(pre)))\]</span></p><blockquote><p>公式五：</p></blockquote><p><span class="math display">\[L = -actual * (log(pre)) * weights - (1-actual)(log(1-pre))\]</span></p><ol start="2" type="1"><li>Back Propagation</li></ol><blockquote><p>这个地方不要紧张，我这里给你推荐一个网站，上面有很好理解这个算法的解释。</p></blockquote><p><a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">机器学习基础以及反向传播算法介绍</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是一个回归的例子</span></span><br><span class="line"><span class="comment"># 老样子，我们创建tensorflow的会话，使用默认的计算图</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 一个回归的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x_vals = np.random.normal(<span class="number">1</span>, <span class="number">0.1</span>, <span class="number">100</span>) <span class="comment"># x数据</span></span><br><span class="line">y_vals = np.repeat(<span class="number">10.</span>, <span class="number">100</span>) <span class="comment"># y 数据</span></span><br><span class="line">x_data = tf.placeholder(shape=[<span class="number">1</span>], dtype=tf.float32) <span class="comment"># 占位符</span></span><br><span class="line">y_target = tf.placeholder(shape=[<span class="number">1</span>], dtype=tf.float32) <span class="comment"># label（真值）</span></span><br><span class="line"></span><br><span class="line">A = tf.Variable(tf.random_normal(shape=[<span class="number">1</span>]))</span><br><span class="line">my_output = tf.multiply(x_data, A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用l2 loss</span></span><br><span class="line">loss = tf.square(my_output - y_target)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个反向传播优化器</span></span><br><span class="line">my_opt = tf.train.GradientDescentOptimizer(<span class="number">0.02</span>)</span><br><span class="line">train_step = my_opt.minimize(loss) <span class="comment"># 最小化loss</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始我们的迭代训练</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    rand_index = np.random.choice(<span class="number">100</span>)</span><br><span class="line">    rand_x = [x_vals[rand_index]]</span><br><span class="line">    rand_y = [y_vals[rand_index]]</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;x_data: rand_x, y_target: rand_y&#125;)</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">25</span>==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'Step #'</span> + str(i+<span class="number">1</span>) + <span class="string">' A = '</span> + str(sess.run(A)))</span><br><span class="line">        print(<span class="string">'Loss = '</span> + str(sess.run(loss, feed_dict=&#123;x_data: rand_x, y_target: rand_y&#125;)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是一个分类的例子</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"></span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类的例子</span></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x_vals = np.concatenate((np.random.normal(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">50</span>), np.random.normal(<span class="number">3</span>, <span class="number">1</span>, <span class="number">50</span>)))</span><br><span class="line">y_vals = np.concatenate((np.repeat(<span class="number">0.</span>, <span class="number">50</span>), np.repeat(<span class="number">1.</span>, <span class="number">50</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建占位符</span></span><br><span class="line">x_data = tf.placeholder(shape=[<span class="number">1</span>], dtype=tf.float32)</span><br><span class="line">y_target = tf.placeholder(shape=[<span class="number">1</span>], dtype=tf.float32)</span><br><span class="line">A = tf.Variable(tf.random_normal(mean=<span class="number">10</span>, shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">my_output = tf.add(x_data, A)</span><br><span class="line"></span><br><span class="line">my_output_expanded = tf.expand_dims(my_output, <span class="number">0</span>)</span><br><span class="line">y_target_expanded = tf.expand_dims(y_target, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是不是使用的是对应的分类损失函数呀 sigmoid cross entropy</span></span><br><span class="line">xentropy = tf.nn.sigmoid_cross_entropy_with_logits(logits = my_output_expanded, labels = y_target_expanded)</span><br><span class="line"></span><br><span class="line">my_opt = tf.train.GradientDescentOptimizer(<span class="number">0.05</span>)</span><br><span class="line">train_step = my_opt.minimize(xentropy)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1400</span>):</span><br><span class="line">    rand_index = np.random.choice(<span class="number">100</span>)</span><br><span class="line">    rand_x = [x_vals[rand_index]]</span><br><span class="line">    rand_y = [y_vals[rand_index]]</span><br><span class="line">    </span><br><span class="line">    sess.run(train_step, feed_dict=&#123;x_data: rand_x, y_target: rand_y&#125;)</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">200</span>==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'Step #'</span> + str(i+<span class="number">1</span>) + <span class="string">' A = '</span> + str(sess.run(A)))</span><br><span class="line">        print(<span class="string">'Loss = '</span> + str(sess.run(xentropy, feed_dict=&#123;x_data: rand_x, y_target: rand_y&#125;)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 </span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x_vals)):</span><br><span class="line">    x_val = [x_vals[i]]</span><br><span class="line">    prediction = sess.run(tf.round(tf.sigmoid(my_output)), feed_dict=&#123;x_data: x_val&#125;)</span><br><span class="line">    predictions.append(prediction[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">accuracy = sum(x==y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(predictions, y_vals))/<span class="number">100.</span></span><br><span class="line">print(<span class="string">'Ending Accuracy = '</span> + str(np.round(accuracy, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>o^o,今天我们就讲到这里，下节我们再见，总的来说，就是在回归和分类问题中，设计相对应的loss函数，然后使用反向传播优化器起优化loss，使得loss逐渐减小</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-基础2&quot;&gt;TensorFlow
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>asyncio 不完全指北（一）</title>
    <link href="http://weafteam.github.io/posts/b496f296/"/>
    <id>http://weafteam.github.io/posts/b496f296/</id>
    <published>2018-04-14T19:37:56.000Z</published>
    <updated>2018-04-22T07:10:52.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>众所周知，Python 的并发编程主要由线程、进程和协程三个组件组成，我们可以使用 Python 模块 <code>threading</code>、<code>multiprocessing</code> 和 <code>yield</code> 句法去操纵它们。后来，又有了更高层的封装：<code>concurrent.futures</code> 和 <code>asyncio</code> 模块。<code>concurrent.futures</code>是对 <code>threading</code> 和 <code>multiprocessing</code> 的封装，不是这篇文章的重点；<code>asyncio</code> 是 Python 中的重大变化，也代表了未来的发展趋势，所以这篇文章打算讲讲 <code>asyncio</code>。</p><h2 id="什么是-asyncio">什么是 asyncio</h2><p><code>asyncio</code> 一开始是 Python 的作者 Guido van Rossum 在 Python 仓库之外开发的，代号为“<a href="https://code.google.com/p/tulip/" target="_blank" rel="noopener">Tulip</a>”，在 Python 3.4 时加入标准库。<code>asyncio</code>模块使用事件循环驱动的协程实现并发，提供了基于协程来构建并发程序的工具。作为对比，<code>threading</code> 模块通过应用级线程实现并发；<code>multiprocessing</code> 模块使用系统级进程实现并发；而 <code>asyncio</code>使用单线程、单进程，其中应用程序的各个部分在事件循环的驱动下进行协作，在最佳时间显式切换任务。<code>asyncio</code> 不但支持通常情况下出现阻塞型 IO 时的上下文切换，还支持调度，来让代码在指定的将来时间运行，并且还可以让一个协程等待另一个协程完成。</p><h2 id="asyncio-中的几个概念">asyncio 中的几个概念</h2><p>事件循环：<code>asyncio</code> 提供的框架以事件循环为中心，它是负责有效处理 I / O 事件、系统事件和应用程序上下文切换的第一类对象。Python 提供了几个循环实现，通常会自动选择合理的默认值，但也可以选择特定的事件循环实现。同样也有一些第三方的实现，例如 <a href="https://github.com/MagicStack/uvloop" target="_blank" rel="noopener">uvloop</a>。应用程序将要执行的代码注册到事件循环中，代表允许事件循环在必要时对代码进行调用。当调用结束，或无法继续时，应用程序会让出控制权，交还给事件循环。</p><p>协程（coroutine ）：将控制权交还给事件循环的机制来自于 Python 的协程，这是一种特殊的函数，它将控制权交还给调用方而不会丢失本身状态。协程类似于生成器函数，事实上可以在 Python 3.5 之前的版本中用生成器实现协程。<code>asyncio</code> 还为 <code>Protocols</code> 和 <code>Transports</code> 提供了基于类的抽象层，使用回调的代码风格。在基于类的模型和协程模型中，通过重新进入事件循环来显式更改上下文将取代 Python 线程实现中的隐式上下文更改。</p><p>future：future 是一种对象，表示待完成的操作。事件循环可以监视将要完成的 <code>future</code> 对象，从而允许应用程序的一部分等待另一部分完成某些工作。除了 future，<code>asyncio</code> 还包括其他并发原语，例如锁和信号量。通常情况下，我们不应该自行创建 future，只能通过并发框架（例如 <code>asyncio</code>）来实例化。原因是 future 代表终将发生的事情，而某件事的发生，是通过安排好这件事的执行时间来确定的。只有当我们把某件事交给事件循环处理时，事件循环才会给这件事排期，从而创建一个 future 对象。</p><p>任务（Task）：任务是 future 的子类，它包装并管理协程的执行。任务可以通过事件循环进行调度，以便在它们需要的资源可用时运行，并生成可由其他协程使用的结果。</p><h2 id="使用协程处理多任务协作">使用协程处理多任务协作</h2><p>协程是为并发设计的语言概念。协程函数在调用时创建协程对象，然后调用方可以使用协程的 <code>send ()</code> 方法运行函数。协程可以在另一个协程中使用 <code>await</code>关键字暂停执行。当它被暂停时，协程的状态被保持，允许它在下次被唤醒时恢复到它停止的位置。</p><h3 id="启动协程">启动协程</h3><p>启动一个协程最简单的方式是将一个协程传递给事件循环的 <code>run_until_complete()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in coroutine'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'starting coroutine'</span>)</span><br><span class="line">    print(<span class="string">'entering event loop'</span>)</span><br><span class="line">    event_loop.run_until_complete(coroutine())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'closing event loop'</span>)</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure><p>首先，我们通过 <code>asyncio.get_event_loop()</code> 获取了一个默认事件循环的引用。<code>run_until_complete()</code> 方法接受一个协程对象，并用它启动事件循环，然后在协程通过 <code>return</code> 结束时停止事件循环。</p><h3 id="协程的返回值">协程的返回值</h3><p>协程的返回值返回给启动并等待它的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in coroutine'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    return_value = event_loop.run_until_complete(coroutine())</span><br><span class="line">    print(<span class="string">f'it returned: <span class="subst">&#123;return_value!r&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure><h3 id="链式调用协程">链式调用协程</h3><p>一个协程可以启动另一个协程并等待它返回结果。下面的示例包含两个阶段，它们必须按顺序执行，但可以与另外的操作同时运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">phase1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in phase1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result1'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">phase2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'in phase2'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'result2 derived from <span class="subst">&#123;arg&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in main'</span>)</span><br><span class="line">    print(<span class="string">'waiting for result1'</span>)</span><br><span class="line">    result1 = <span class="keyword">await</span> phase1()</span><br><span class="line">    print(<span class="string">'waiting for result2'</span>)</span><br><span class="line">    result2 = <span class="keyword">await</span> phase2(result1)</span><br><span class="line">    <span class="keyword">return</span> (result1, result2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    return_value = event_loop.run_until_complete(main())</span><br><span class="line">    print(<span class="string">f'return value: <span class="subst">&#123;return_value!r&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure><p>在这里使用了 <code>await</code> 关键字，并没有将新的协程添加到事件循环中。因为控制流已经在由事件循环管理的协程内部，所以不需要通知事件循环管理新的协程。</p><h3 id="使用生成器语法">使用生成器语法</h3><p><code>async</code> 和 <code>await</code> 关键字出现于 Python 3.5，对于 Python 3.5 之前的版本，可以使用 <code>asyncio.coroutine</code> 装饰器和 <code>yield from</code> 来实现相同的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phase1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in phase1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result1'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phase2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'in phase2'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'result2 derived from <span class="subst">&#123;arg&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in main'</span>)</span><br><span class="line">    print(<span class="string">'waiting for result1'</span>)</span><br><span class="line">    result1 = <span class="keyword">yield</span> <span class="keyword">from</span> phase1()</span><br><span class="line">    print(<span class="string">'waiting for result2'</span>)</span><br><span class="line">    result2 = <span class="keyword">yield</span> <span class="keyword">from</span> phase2(result1)</span><br><span class="line">    <span class="keyword">return</span> (result1, result2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    return_value = event_loop.run_until_complete(main())</span><br><span class="line">    print(<span class="string">f'return value: <span class="subst">&#123;return_value!r&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ul><li><a href="https://pymotw.com/3/asyncio/concepts.html" target="_blank" rel="noopener">Asynchronous Concurrency Concepts</a></li><li><a href="https://pymotw.com/3/asyncio/coroutines.html" target="_blank" rel="noopener">Cooperative Multitasking with Coroutines</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，Python 的并发编程主要由线程、进程和协程三个组件组成，我们可以使用 Python 模块 &lt;code&gt;threading&lt;/code&gt;、&lt;code&gt;multiprocessing&lt;/code&gt; 和
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vigenere密码加密解密</title>
    <link href="http://weafteam.github.io/posts/8b092926/"/>
    <id>http://weafteam.github.io/posts/8b092926/</id>
    <published>2018-04-14T14:11:24.000Z</published>
    <updated>2018-04-15T12:46:07.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天换个口味，写点原来从没接触过的东西–密码学。前一阵信息安全课上留了一个作业，实现Vigenere加密解密，借着机会写篇博客。这次博客由于比较仓促，这次只写加密解密系统的实现，不涉及唯密文破解。</p></blockquote><hr><h1 id="任务要求">任务要求：</h1><ul><li><pre><code> a.编程实现Vigenere加密/解密系统，并分析和评估该算法的安全性。</code></pre></li><li><pre><code> b.编程实现唯密文破译系统，能够破译密钥为2到4个字符的Vigenere密文，并分析如何加快破译速度。</code></pre></li><li>时间要求： 布置任务后，在3周之内完成。</li><li>提交结果：已设计并测试好的程序，包括源码、可执行程序、测试数据集、实验报告。</li></ul><h1 id="原理介绍">原理介绍：</h1><p>先普及下Caesar密码，作为单密码简单替换密码届的扛把子，他有着不可动摇的地位，它的原理很简单，对于需要加密的每个字符都进行相同大小的平移。先给出Caesar密码加密的字符对应表，如下：</p><p><img src="https://i.loli.net/2018/04/15/5ad32ed02524c.png" alt="Caesar.png"></p><p>举个例子吧：明文为China，它对应的数字应为2 7 8 13 0.比如我们平移距离为3，那么加密之后的密文应该为FKLQD，简单到炸。</p><p>我们先不谈上述加密方法的缺点，这些我们放到唯密文解密中聊。有了以上的基础之后我们再聊Vigenere加密以及解密，它是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。同样先给出它的密码加密字符对应表（自己画太麻烦了，我就在百科上扒了一个图，溜。。）：</p><p><img src="https://i.loli.net/2018/04/15/5ad33112af0e9.png" alt="222.png"></p><p>上图中的维吉尼亚表的第一列代表着密钥字母（这是有别于Caesar密码的地方），第一行代表着明文字母，行列分别使用当前需要加密字符和当前的密钥字符确定当前明文字符对应着的密文字符。</p><p>这里我们说一下，一般情况下，我们给出的密钥是短于我们的明文长度的。所以我们做Vigenere加密的时候第一步做的就是对照明文长度，补齐密钥字串。</p><p>说了这么多，举个例子说下吧：</p><ul><li><p>例如我们的明文字串为：data security</p></li><li><p>密钥：best</p></li></ul><p>按照上述的规则，第b行，第d列，对应的字符为E，….. 加密之后的密文应为：EELTTIUNSMLR（不区分大小写）。</p><h1 id="实现">实现</h1><h3 id="第一步使得密钥字符串长度与明文长度相同">第一步：使得密钥字符串长度与明文长度相同</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dealKey</span><span class="params">(String str,String Key)</span></span>&#123;   </span><br><span class="line">        Key=Key.toUpperCase();<span class="comment">// 将密钥转换成大写</span></span><br><span class="line">        Key=Key.replaceAll(<span class="string">"[^A-Z]"</span>, <span class="string">""</span>);<span class="comment">//去除所有非字母的字符  </span></span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Key);</span><br><span class="line">        String newKey=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(sstringBuilder.length()!=str.length())&#123; </span><br><span class="line">            <span class="comment">//如果密钥长度与str不同，则需要生成密钥字符串</span></span><br><span class="line">            <span class="keyword">if</span>(stringBuilder.length()&lt;str.length())&#123;</span><br><span class="line">                <span class="comment">//如果密钥长度比str短，则以不断重复密钥的方式生成密钥字符串</span></span><br><span class="line">                <span class="keyword">while</span>(stringBuilder.length()&lt;str.length())&#123;</span><br><span class="line">                    stringBuilder.append(Key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时，密钥字符串的长度大于或等于str长度</span></span><br><span class="line">            <span class="comment">//将密钥字符串截取为与str等长的字符串</span></span><br><span class="line">            newKey=stringBuilder.substring(<span class="number">0</span>, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newKey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="第二步加密">第二步：加密</h3><p>其实我们不用将上述的Vigenere密码表列出来，一是列出来费时费力费空间，二是一个简单的取余操作就能解决这个事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String PwTable = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Encryption</span><span class="params">(String P,String K)</span></span>&#123;</span><br><span class="line">        P = P.toUpperCase();<span class="comment">// 将明文转换成大写</span></span><br><span class="line">        P = P.replaceAll(<span class="string">"[^A-Z]"</span>, <span class="string">""</span>);<span class="comment">//去除所有非字母的字符   </span></span><br><span class="line">        K = dealKey(P,K);</span><br><span class="line">        <span class="keyword">int</span> len = K.length();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row=PwTable.indexOf(K.charAt(i));<span class="comment">//行号</span></span><br><span class="line">            <span class="keyword">int</span> col=PwTable.indexOf(P.charAt(i));<span class="comment">//列号</span></span><br><span class="line">            <span class="keyword">int</span> index = (row+col)%<span class="number">26</span>;</span><br><span class="line">            stringBuilder.append(PwTable.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="第三步解密">第三步：解密</h3><p>这个过程其实是比较有趣的，我们取密钥所在行为解密的行号，密文所在列作为我们的列号，我们需要分两种情况考虑：</p><p>首先说一下第一种情况，将上述的密码表从主对角线分开，一是密文在我们的密码表的右上部，这种情况比较简单，其实就是一个加密过程的逆过程，我们此时的密文字符在密码表中的位置肯定是不比其对应的明文靠后的（理解这句话，这种情况其实也就明白了，再简单点讲就是PwTable.indexof(密文)&gt;PwTable.indexof(对应的明文)），此时我们只要让列号减去行号，然后将结果做indexof操作就能得到相应的明文。</p><p>如果你理解了第一种情况，第二种情况也就好理解了，此时我们的密文字符在我们的密码表中的位置肯定是不比其对应的明文的位置靠前的，我们需要将列号加一圈字符表再去减行号。</p><p>理解之后下面的这些代码应该就不难理解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Decryption</span><span class="params">(String C,String K)</span></span>&#123;</span><br><span class="line">        C=C.toUpperCase();<span class="comment">// 将密文转换成大写</span></span><br><span class="line">        C=C.replaceAll(<span class="string">"[^A-Z]"</span>, <span class="string">""</span>);<span class="comment">//去除所有非字母的字符   </span></span><br><span class="line">        K=dealKey(C,K);</span><br><span class="line">        <span class="keyword">int</span> len = K.length();</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = PwTable.indexOf(K.charAt(i));<span class="comment">//行号</span></span><br><span class="line">            <span class="keyword">int</span> col = PwTable.indexOf(C.charAt(i));<span class="comment">//列号</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">if</span>(row&gt;col)&#123;</span><br><span class="line">                index=col+<span class="number">26</span>-row;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                index=col-row;</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(PwTable.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上是本篇博客的全部内容，希望对你有所帮助，感谢驻足~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;今天换个口味，写点原来从没接触过的东西–密码学。前一阵信息安全课上留了一个作业，实现Vigenere加密解密，借着机会写篇博客。这次博客由于比较仓促，这次只写加密解密系统的实现，不涉及唯密文破解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
        
      
    
    </summary>
    
      <category term="密码学" scheme="http://weafteam.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://weafteam.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何理解丘奇计数</title>
    <link href="http://weafteam.github.io/posts/cd89a3b2/"/>
    <id>http://weafteam.github.io/posts/cd89a3b2/</id>
    <published>2018-04-07T19:39:29.000Z</published>
    <updated>2018-04-14T06:25:47.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不想写 Python 了，这次换个主题：丘奇计数，又名 lambda 演算的自然数表示法。</p><h2 id="什么是-lambda-演算">什么是 lambda 演算</h2><p>lambda 演算（也称为 λ 演算）是数学逻辑中的一种形式系统，它基于函数抽象和应用，使用变量绑定和替换来表示计算。</p><p>没错，上面这句话来自维基百科，基本上是一句正确的废话，看完了也不知道什么是 lambda 演算。不过这篇文章的重点不在 lambda 演算上，希望你已经了解了一些关于 lambda 演算的知识。如果有机会下一篇再展开说（可能</p><h2 id="什么是自然数">什么是自然数</h2><p>在计算机科学和集合论中，我们把非负整数 <span class="math inline">\((0, 1, 2, 3, 4...)\)</span> 称为自然数。皮亚诺给出了自然数的严格定义：</p><ol type="1"><li><span class="math inline">\(0\)</span> 是自然数；</li><li>如果 <span class="math inline">\(n\)</span> 是自然数，那么 <span class="math inline">\(n+1\)</span> 也是自然数（<span class="math inline">\(n+1\)</span> 代表 <span class="math inline">\(n\)</span> 的后继）；</li><li><span class="math inline">\(0\)</span> 不是任何一个数的后继；</li><li>如果 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(n\)</span> 都是自然数且 <span class="math inline">\(m\neq n\)</span>，那么 <span class="math inline">\(n+1 \neq m+1\)</span>；</li><li>设 <span class="math inline">\(P(n)\)</span> 为关于自然数 <span class="math inline">\(n\)</span> 的一个性质，如果 <span class="math inline">\(P(0)\)</span> 正确， 且假设 <span class="math inline">\(P(n)\)</span> 正确，则 <span class="math inline">\(P(n+1)\)</span> 亦正确。那么 <span class="math inline">\(P(n)\)</span> 对一切自然数 <span class="math inline">\(n\)</span> 都正确。</li></ol><p>存在一个集合 <span class="math inline">\(N\)</span>，称其元素为自然数，当且仅当这些元素满足公理 1 - 5（也就是皮亚诺公理）。</p><p>在自然数集合上可以定义一组运算：加法、乘法等等，这里用加法举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">return</span> add(m, n - <span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看出加法是由两条规则递归定义的：</p><ol type="1"><li>$ m + 0 = m$</li><li><span class="math inline">\(m + (n + 1) = (m + n) + 1\)</span></li></ol><h2 id="lambda-演算的自然数表示法">lambda 演算的自然数表示法</h2><p>自然数当然不止可以用皮亚诺公理定义，丘奇首先把自然数和自然数上的运算定义在了 lambda 演算上，所以称之为丘奇计数。</p><p>下面就要开始丘奇计数的定义了，由于 lambda 演算的样子不太友好，所以还是用 Python 表示。</p><p>首先定义 0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: x</span><br></pre></td></tr></table></figure><p>先不管它为什么是 0，让我们看看这个语句。它定义了一个接受一个参数 <code>f</code> 的函数，返回一个函数，这个函数接受一个参数 <code>x</code>，然后返回它。似乎很简单，但是它为什么是 0？</p><p>把它放在一边，看看 1 的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(x)</span><br></pre></td></tr></table></figure><p>这个语句是什么意思呢？定义了一个接受一个参数 <code>f</code> 的函数，返回一个函数，这个函数接受一个参数 <code>x</code>，然后返回 <code>f(x)</code> 的调用结果。好像有些规律了，再看看 2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(f(x))</span><br></pre></td></tr></table></figure><p>定义了一个接受一个参数 <code>f</code> 的函数，返回一个函数，这个函数接受一个参数 <code>x</code>，然后返回 <code>f(f(x))</code> 的调用结果。</p><p>现在可以清楚的看到，每个自然数的后继都多调用了一次 <code>f</code>，自然数被表示为 <code>f</code> 的调用次数。</p><p>于是，我们可以很轻易的写出后继函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">succ = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(n(f)(x))</span><br></pre></td></tr></table></figure><p>这个函数接受一个参数 <code>n</code>（也就是上面被定义的 0，1，2 等等），返回一个函数，这个函数在 <code>n</code> 的基础上多执行了一次 <code>f</code>，达到了求 <code>n</code> 的后继的目的。</p><p>现在让我们忘记 1 的定义，用 0 和后继重新定义一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zero = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: x</span><br><span class="line">succ = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(n(f)(x))</span><br><span class="line"></span><br><span class="line">one = succ(zero)</span><br><span class="line">    = (<span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(n(f)(x)))(<span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: x)</span><br><span class="line">    = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(((<span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: x)(f))(x))</span><br><span class="line">    = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f((<span class="keyword">lambda</span> x: x)(x))</span><br><span class="line">    = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(x)</span><br></pre></td></tr></table></figure><p>和我们预想的完全一致。</p><h3 id="加法">加法</h3><p>接下来试着定义一下加法，加法是两个数相加返回一个数（也就是说，加法是定义在自然数上的幺半群），所以签名长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: ...</span><br></pre></td></tr></table></figure><p>函数体呢？我们推广一下后继函数：后继函数在<code>n</code>的基础上多调用了一次 <code>f</code>，相当于 <code>+1</code>；那加法相当于 <code>+m</code>，也就是多调用 <code>m</code> 次 <code>f</code>，于是可以得出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: m(f)(n(f)(x))</span><br></pre></td></tr></table></figure><h3 id="乘法">乘法</h3><p>乘法的签名也是一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: ...</span><br></pre></td></tr></table></figure><p>我们都知道乘法是从加法推广而来的：<code>m * n</code> 相当于加 <code>m</code> 次 <code>n</code>，所以可以使用加法的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: m(add(n))(zero)(f)(x)</span><br></pre></td></tr></table></figure><p>上面的写法正确，不过太丑了，可以化简为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: m(n(f))(x)</span><br></pre></td></tr></table></figure><h3 id="求幂">求幂</h3><p>求幂的签名也一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: ...</span><br></pre></td></tr></table></figure><p>求幂是由乘法推广而来的：m<sup>n</sup> 相当于乘 <code>n</code> 次 <code>m</code>，所以可以使用乘法的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(mul(m))(one)(f)(x)</span><br></pre></td></tr></table></figure><p>同样可以化简为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow = <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(m)(f)(x)</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>机智的同学一定发现我们并没有实现减法，这是因为减法的实现太复杂了。至于为什么减法的实现很复杂，以及如何实现减法，这里有一篇<a href="http://gettingsharper.de/2012/08/30/lambda-calculus-subtraction-is-hard/" target="_blank" rel="noopener">参考资料</a> ，有兴趣的话可以自行了解一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;不想写 Python 了，这次换个主题：丘奇计数，又名 lambda 演算的自然数表示法。&lt;/p&gt;
&lt;h2 id=&quot;什么是-lambda-演算&quot;&gt;什么是 lambda 演算&lt;/h2&gt;
&lt;p&gt;lambda 演算（也称为 λ
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chapter-04-AIR</title>
    <link href="http://weafteam.github.io/posts/466eca41/"/>
    <id>http://weafteam.github.io/posts/466eca41/</id>
    <published>2018-04-05T02:13:07.000Z</published>
    <updated>2018-04-22T07:10:52.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-基础1">TensorFLow 基础（1）</h1><p>hi,又和大家见面了，上一次我们讲了建立模型步骤和一些基础的概念（Tensor、Placeholder），那么我们这次就继续我们的矩阵操作，因为在TensorFlow处理一些数学问题的时候，往往都是通过矩阵来存储数据，通过特定的矩阵运算，我们实现数据的处理，从而得到一些数据的特性。还有一些其他的Tensorflow的概念，我希望大家能坚持下去，只要将这些基础的概念学会，那么以后运用TensorFlow就会得心应手。</p><ol type="1"><li>和TensorFlow一起工作的Matrices</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵和矩阵操作</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">identity_matrix = tf.diag([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1</span>])</span><br><span class="line">print(sess.run(identity_matrix)) <span class="comment">#注意这个地方，如果是TensorFlow的Tensor，</span></span><br><span class="line"><span class="comment"># 那么使用sess的run方法才能将结果显示</span></span><br><span class="line"><span class="comment"># 或者下面这种方式</span></span><br><span class="line">print(identity_matrix.eval(session = sess))</span><br><span class="line">A = tf.truncated_normal([<span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 2 * 3 大小 均值0 方差为1.</span></span><br><span class="line">print(sess.run(A))</span><br><span class="line">B = tf.fill([<span class="number">2</span>, <span class="number">3</span>], <span class="number">5.</span>) <span class="comment"># 2 * 3 使用5.填充</span></span><br><span class="line">print(sess.run(B))</span><br><span class="line">C = tf.random_uniform([<span class="number">3</span>, <span class="number">2</span>]) <span class="comment"># 3 * 2 随机初始化</span></span><br><span class="line">print(sess.run(C))</span><br><span class="line">D = tf.convert_to_tensor(np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">-3.</span>, <span class="number">-7.</span>, <span class="number">-1.</span>], [<span class="number">0.</span>, <span class="number">5.</span>, <span class="number">-2.</span>]]))</span><br><span class="line">print(sess.run(D))</span><br><span class="line"></span><br><span class="line">print(sess.run(A+B)) <span class="comment"># 加法和 tf.add() 一样</span></span><br><span class="line">print(sess.run(B-B)) <span class="comment"># 减法和 tf.subtract() 一样</span></span><br><span class="line">print(sess.run(tf.matmul(B, identity_matrix))) <span class="comment"># 矩阵乘法</span></span><br><span class="line">print(sess.run(tf.transpose(C))) <span class="comment"># 矩阵转置</span></span><br><span class="line">print(sess.run(tf.matrix_determinant(D)))  <span class="comment"># 计算行列式</span></span><br><span class="line">print(sess.run(tf.matrix_inverse(D))) <span class="comment"># 矩阵的逆</span></span><br><span class="line">print(sess.run(tf.cholesky(identity_matrix))) <span class="comment"># cholesk分解（平方根分解）</span></span><br><span class="line"></span><br><span class="line">eigenvalues, eigenvectors = sess.run(tf.self_adjoint_eig(D)) <span class="comment"># 求特征向量和特征值</span></span><br><span class="line">print(eigenvalues)</span><br><span class="line">print(eigenvectors)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>Math Operation（数学操作）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># math operation</span></span><br><span class="line">print(sess.run(tf.div(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">print(sess.run(tf.truediv(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">print(sess.run(tf.floordiv(<span class="number">3.</span>, <span class="number">4.</span>)))</span><br><span class="line">print(sess.run(tf.mod(<span class="number">22.</span>, <span class="number">5.</span>)))</span><br><span class="line">print(sess.run(tf.cross([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>])))</span><br><span class="line"><span class="comment"># Trig operation</span></span><br><span class="line">print(sess.run(tf.sin(<span class="number">3.1416</span>)))</span><br><span class="line">print(sess.run(tf.cos(<span class="number">3.1416</span>)))</span><br><span class="line">print(sess.run(tf.div(tf.sin(<span class="number">3.1416</span> / <span class="number">4.</span>), tf.cos(<span class="number">3.1416</span> / <span class="number">4.</span>))))</span><br><span class="line"><span class="comment"># custom operation</span></span><br><span class="line"><span class="comment"># f(x) = 3 * x^2 - X + 10</span></span><br><span class="line"></span><br><span class="line">test_nums = range(<span class="number">15</span>) <span class="comment"># 生成一个list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_polynomial</span><span class="params">(x_val)</span>:</span></span><br><span class="line"><span class="keyword">return</span> (tf.subtract(<span class="number">3</span> * tf.square(x_val), x_val) + <span class="number">10</span>)</span><br><span class="line">print(sess.run(custom_polynomial(<span class="number">11</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># list expend</span></span><br><span class="line">expected_output = [<span class="number">3</span> * x * x - x + <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> test_nums]</span><br><span class="line">print(expected_output)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> test_nums:</span><br><span class="line">    print(sess.run(custom_polynomial(num)))</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>Activation Function（激活函数）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活函数主要是为了让神经网络模型具有非线性的特性</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">x_vals = np.linspace(start = <span class="number">-10</span>, stop = <span class="number">10</span>, num = <span class="number">100</span>)</span><br><span class="line"><span class="comment"># Relu Activation-&gt; max(0, x)</span></span><br><span class="line">print(sess.run(tf.nn.relu([<span class="number">-3.</span>, <span class="number">3.</span>, <span class="number">10.</span>])))</span><br><span class="line">y_relu = sess.run(tf.nn.relu(x_vals))</span><br><span class="line"><span class="comment"># Relu6 Activation-&gt; min(max(x, 0), 6)</span></span><br><span class="line">print(sess.run(tf.nn.relu6([<span class="number">-3.</span>, <span class="number">3.</span>, <span class="number">10.</span>])))</span><br><span class="line">y_relu6 = sess.run(tf.nn.relu6(x_vals))</span><br><span class="line"><span class="comment"># Sigmoidactivation-&gt; 见公式1</span></span><br><span class="line">print(sess.run(tf.nn.sigmoid([<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>])))</span><br><span class="line">y_sigmoid = sess.run(tf.nn.sigmoid(x_vals))</span><br><span class="line"><span class="comment"># Hyper Tangent activation-&gt;见公式2</span></span><br><span class="line">print(sess.run(tf.nn.tanh([<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>])))</span><br><span class="line">y_tanh = sess.run(tf.nn.tanh(x_vals))</span><br><span class="line"><span class="comment"># softsign activation-&gt;见公式3</span></span><br><span class="line">print(sess.run(tf.nn.softsign([<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>])))</span><br><span class="line">y_softsign = sess.run(tf.nn.softsign(x_vals))</span><br><span class="line"><span class="comment"># softplus activation-&gt;见公式4</span></span><br><span class="line">print(sess.run(tf.nn.softplus([<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>])))</span><br><span class="line">y_softplus = sess.run(tf.nn.softplus(x_vals))</span><br><span class="line"><span class="comment"># Exponential linear activation-&gt;见公式5</span></span><br><span class="line">print(sess.run(tf.nn.elu([<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>])))</span><br><span class="line">y_elu = sess.run(tf.nn.elu(x_vals))</span><br><span class="line"></span><br><span class="line">plt.plot(x_vals, y_softplus, <span class="string">'r--'</span>, label=<span class="string">'Softplus'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_vals, y_relu, <span class="string">'b:'</span>, label=<span class="string">'ReLU'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_vals, y_relu6, <span class="string">'g-.'</span>, label=<span class="string">'ReLU6'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_vals, y_elu, <span class="string">'k-'</span>, label=<span class="string">'ExpLU'</span>, linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.ylim([<span class="number">-1.5</span>,<span class="number">7</span>])</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(x_vals, y_sigmoid, <span class="string">'r--'</span>, label=<span class="string">'Sigmoid'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_vals, y_tanh, <span class="string">'b:'</span>, label=<span class="string">'Tanh'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_vals, y_softsign, <span class="string">'g-.'</span>, label=<span class="string">'Softsign'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.ylim([<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line">下图给出激活函数的曲线图</span><br></pre></td></tr></table></figure><blockquote><p>公式1：</p></blockquote><p><span class="math display">\[\sigma(x)=\frac{1}{1+e^{-x}}\]</span></p><blockquote><p>公式2：</p></blockquote><p><span class="math display">\[f(x)=\frac{e^x-e^{-x}}{e^x + e^{-x}}\]</span></p><blockquote><p>公式3：</p></blockquote><p><span class="math display">\[f(x) = \frac{1}{1 + |x|}\]</span></p><blockquote><p>公式4</p></blockquote><p><span class="math display">\[f(x) = \log(1 + e^x)\]</span></p><blockquote><p>公式5：</p></blockquote><p><span class="math display">\[elu(x) = \begin{cases} x &amp; x &gt; 0 \\\alpha(exp(x) - 1) &amp; x \leq 0\end{cases}\]</span></p><p><img src="https://s1.ax1x.com/2018/04/05/CC9wN9.png" alt="-"></p><p><img src="https://s1.ax1x.com/2018/04/05/CC90hR.png" alt="-"></p><ol start="4" type="1"><li>Operations on a Computational Graph</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建的数据是要喂给下面的placeholder的</span></span><br><span class="line">x_vals = np.array([<span class="number">1.</span>, <span class="number">3.</span>, <span class="number">5.</span>, <span class="number">7.</span>, <span class="number">9.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建placeholder</span></span><br><span class="line">x_data = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个乘数</span></span><br><span class="line">m = tf.constant(<span class="number">3.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘法</span></span><br><span class="line">prod = tf.multiply(x_data, m)</span><br><span class="line"><span class="keyword">for</span> x_val <span class="keyword">in</span> x_vals:</span><br><span class="line">    print(sess.run(prod, feed_dict = &#123;x_data: x_val&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面将数据计算图输出到文件里面，供我们后来启动tensorboard使用</span></span><br><span class="line">merged = tf.summary.merge_all(key = <span class="string">'summary'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'tensorboard_logs/'</span>):</span><br><span class="line">    os.makedirs(<span class="string">'tensorboard_logs/'</span>)</span><br><span class="line"></span><br><span class="line">my_writer = tf.summary.FileWriter(<span class="string">'./tensorboard_logs/'</span>, sess.graph)</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>Layering Nested Operations</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"></span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据为了feed</span></span><br><span class="line">my_array = np.array([[<span class="number">1.</span>, <span class="number">3.</span>, <span class="number">5.</span>, <span class="number">7.</span>, <span class="number">9.</span>],</span><br><span class="line">                    [<span class="number">-2.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">4.</span>, <span class="number">6.</span>],</span><br><span class="line">                    [<span class="number">-6.</span>, <span class="number">-3.</span>, <span class="number">0.</span>, <span class="number">3.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">x_vals = np.array([my_array, my_array + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明placeholder</span></span><br><span class="line">x_data = tf.placeholder(tf.float32, shape = [<span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明常数来操作</span></span><br><span class="line">m1 = tf.constant([[<span class="number">1.</span>], [<span class="number">0.</span>], [<span class="number">-1.</span>], [<span class="number">2.</span>], [<span class="number">4</span>]])</span><br><span class="line">m2 = tf.constant([[<span class="number">2.</span>]])</span><br><span class="line">a1 = tf.constant([[<span class="number">10.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明操作</span></span><br><span class="line">prod1 = tf.matmul(x_data, m1)</span><br><span class="line">prod2 = tf.matmul(prod1, m2)</span><br><span class="line">add1 = tf.matmul(prod2, a1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印验证结果</span></span><br><span class="line"><span class="keyword">for</span> x_val <span class="keyword">in</span> x_vals:</span><br><span class="line">    print(sess.run(add1, feed_dict = &#123;x_data: x_val&#125;))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">#下面将数据计算图输出到文件里面，供我们后来启动tensorboard使用</span></span><br><span class="line">merged = tf.summary.merge_all(key = <span class="string">'summaries'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'tensorboard_logs/'</span>):</span><br><span class="line">    os.makedirs(<span class="string">'tensorflow_logs/'</span>)</span><br><span class="line">my_writer = tf.summary.FileWriter(<span class="string">'tensorboard_logs/'</span>, sess.graph)</span><br><span class="line"><span class="comment">#下图就是在操作过程中，tensorflow建立的图运算模型</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/05/CCkFQ1.png" alt="-"></p><ol start="6" type="1"><li>Working With Multiple Layers</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"></span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line">x_shape = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 定义一个4 * 4 大小的随机矩阵</span></span><br><span class="line">x_val = np.randim.uniform(size = x_shape)</span><br><span class="line"></span><br><span class="line">x_data = tf.placeholder(tf.float32, shape = x_shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空间移动窗口，也就是卷积操作的卷积核</span></span><br><span class="line"><span class="comment"># 大小是2 * 2， 步长是 2</span></span><br><span class="line"><span class="comment"># filter的值是一个固定的值0.25</span></span><br><span class="line">my_filter = tf.constant(<span class="number">0.25</span>, shape = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">my_strides = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">mov_avg_layer = tf.nn.conv2d(x_data, my_filter, my_strides, padding = <span class="string">'SAME'</span>, name = <span class="string">'Moving_Avg_Window'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_layer</span><span class="params">(input_matrix)</span>:</span></span><br><span class="line">    input_matrix_sqeezed = tf.squeeze(input_matrix)</span><br><span class="line">    A = tf.constant([<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">-1.</span>, <span class="number">3.</span>])</span><br><span class="line">    b = tf.constant(<span class="number">1.</span>, shape = [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">    output = tf.add(tf.matmul(A, input_matrix_sqeezed), b)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(output)</span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'custom_layer'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    custom_layer1 = custom_layer(mov_avg_layer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">print(sess.run(mov_avg_layer, feed_dict = &#123;x_data: x_val&#125;))</span><br><span class="line"></span><br><span class="line">print(sess.run(custom_layer1, feed_dict = &#123;x_data: x_val&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面将数据计算图输出到文件里面，供我们后来启动tensorboard使用</span></span><br><span class="line">merged = tf.summary.merge_all(key = <span class="string">'summaries'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'tensorboard_logs/'</span>):</span><br><span class="line">    os.makedirs(<span class="string">'tensorboard_logs/'</span>)</span><br><span class="line">my_writer = tf.summary.FileWriter(<span class="string">'tensorboard_logs'</span>, sess.graph)</span><br><span class="line"><span class="comment"># 下图是计算图</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/05/CCksmV.png" alt="-"></p><p>总结：这一次，一开始主要讲了矩阵的一些操作，后续又进行了数学操作，激活函数，运算图、层内元素嵌套运算还有最好的多层运算，并给出了tensorboard的计算图结构。大家不仅仅要看一看，也要动手做一做哦。</p><p>一如既往的有什么问题可以直接联系milittle，air@weaf.top邮箱</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-基础1&quot;&gt;TensorFLow
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Nginx和Git的离线安装</title>
    <link href="http://weafteam.github.io/posts/a86291b8/"/>
    <id>http://weafteam.github.io/posts/a86291b8/</id>
    <published>2018-04-01T04:07:12.000Z</published>
    <updated>2018-04-22T07:28:18.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一准备工作">一、准备工作</h1><p>一般情况下为了确保安装没有任何问题，我们先使用有网络环境的下安装的方法，去检测当前机器具体需要安装什么冬天链接库，然后按照提示缺失的库去下载相应的库。 我们按照正常的流程，去解压nginx <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.13.8.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入解压后的目录执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.13.8</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>出现以下错误： <img src="http://us-forever.com/img/nginxerror.png"></p><p>我们按照有网络环境的方法去检测缺失的库及其版本。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>显示如下： <img src="http://us-forever.com/img/liberror.png"></p><p>我们下载号相应的库 下边提供几个下载的网址：</p><ul><li><a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/" class="uri" target="_blank" rel="noopener">http://mirrors.163.com/centos/6/os/x86_64/Packages/</a></li><li><a href="http://rpmfind.net/" class="uri" target="_blank" rel="noopener">http://rpmfind.net/</a></li><li><a href="https://pkgs.org" class="uri" target="_blank" rel="noopener">https://pkgs.org</a></li></ul><p>下边是下载好的库 <img src="http://us-forever.com/img/gcclib.png"> 安装相应的库（<strong>集体安装情况具体分析</strong>）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mpfr-2.4.1-6.el6.x86_64.rpm</span><br><span class="line">rpm -ivh cpp-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -Uvh tzdata-2016j-1.el6.noarch.rpm</span><br><span class="line">rpm -Uvh glibc-common-2.12-1.209.el6.x86_64.rpm glibc-2.12-1.209.el6.x86_64.rpm glibc-headers-2.12-1.209.el6.x86_64.rpm glibc-devel-2.12-1.209.el6.x86_64.rpm kernel-headers-2.6.32-696.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libgomp-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -Uvh libstdc++-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libstdc++-devel-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh ppl-0.10.2-11.el6.x86_64.rpm</span><br><span class="line">rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm</span><br><span class="line">rpm -Uvh libgcc-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-c++-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh automake-1.11.1-4.el6.noarch.rpm autoconf-2.63-5.1.el6.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>然后执行./configure 发现错误： <img src="http://us-forever.com/img/nginxerror1.png"> 然后安装一下库 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pcre-7.8-7.el6.x86_64.rpm</span><br><span class="line">rpm -ivh pcre-devel-7.8-7.el6.x86_64.rpm</span><br><span class="line">rpm -Uvh zlib-1.2.3-29.el6.x86_64.rpm</span><br><span class="line">rpm -ivh zlib-devel-1.2.3-29.el6.x86_64.rpm</span><br><span class="line">rpm -i --force --nodeps krb5-devel-1.10.3-65.el6.x86_64.rpm</span><br><span class="line">rpm -Uvh openssl-1.0.1e-57.el6.x86_64.rpm</span><br><span class="line">rpm -ivh openssl-devel-1.0.1e-57.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>然后执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>安装完成 二、查看版本信息 ===== 根据安装完成的信息查看nginx. 三、简介 —– 不同操作系统的Linux的安装可能不太一样。 本教程使用的是CentOS或者RHEL。 四、准备环境 —- 如果有网络的情况下肯定相当容易： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br><span class="line"></span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure></p><p>若果yum源安装的版本较低，不执行<strong>yum install git</strong>命令，并按照四、五步骤操作。 如果是离线需要完成后续操作： 首先我们需要到官网下载相应的安装包 <a href="https://www.kernel.org/pub/software/scm/git/" class="uri" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git/</a> 选择<strong>tar.gz</strong> 三、下载和安装依赖 —— 然后最麻烦的地方就是依赖动态链接库的下载。 需要下载的库可以到这两个网站上去找： <a href="http://www.rpmfind.net/linux/RPM/index.html" target="_blank" rel="noopener">fr2.rpmfind.net</a> <a href="https://pkgs.org/" target="_blank" rel="noopener">Linux Packages Search-pkgs.org</a> 我这里提供了一些 <!--more--> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cpio-2.11-24.el7.x86_64.rpm</span><br><span class="line">curl-7.29.0-42.el7.x86_64.rpm</span><br><span class="line">expat-2.1.0-10.el7_3.x86_64.rpm</span><br><span class="line">expat-devel-2.1.0-10.el7_3.x86_64.rpm</span><br><span class="line">gdbm-devel-1.10-8.el7.x86_64.rpm</span><br><span class="line">gettext-0.19.8.1-2.el7.x86_64.rpm</span><br><span class="line">gettext-devel-0.19.8.1-2.el7.x86_64.rpm</span><br><span class="line">krb5-devel-1.15.1-8.el7.x86_64.rpm</span><br><span class="line">libcurl-7.29.0-42.el7.x86_64.rpm</span><br><span class="line">libcurl-devel-7.29.0-42.el7.x86_64.rpm</span><br><span class="line">libdb-devel-5.3.21-20.el7.x86_64.rpm</span><br><span class="line">openssl-1.0.2k-8.el7.x86_64.rpm</span><br><span class="line">openssl-devel-1.0.2k-8.el7.x86_64.rpm</span><br><span class="line">perl-5.16.3-292.el7.x86_64.rpm</span><br><span class="line">perl-devel-5.16.3-292.el7.x86_64.rpm</span><br><span class="line">perl-ExtUtils-CBuilder-0.28.2.6-292.el7.noarch.rpm</span><br><span class="line">perl-ExtUtils-Install-1.58-292.el7.noarch.rpm</span><br><span class="line">perl-ExtUtils-MakeMaker-6.68-3.el7.noarch.rpm</span><br><span class="line">perl-ExtUtils-Manifest-1.61-244.el7.noarch.rpm</span><br><span class="line">perl-ExtUtils-ParseXS-3.18-3.el7.noarch.rpm</span><br><span class="line">systemtap-sdt-devel-3.1-3.el7.x86_64.rpm</span><br><span class="line">zlib-1.2.7-17.el7.x86_64.rpm</span><br><span class="line">zlib-devel-1.2.7-17.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>这是git需要的一些库，需要安装的不是很多，但是安装的库也需要依赖。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh perl-5.16.3-292.el7.x86_64.rpm</span><br><span class="line">rpm -ivh perl-devel-5.16.3-292.el7.x86_64.rpm</span><br><span class="line">rpm -ivh zlib-devel-1.2.7-17.el7.x86_64.rpm</span><br><span class="line">rpm -ivh libcurl-devel-7.29.0-42.el7.x86_64.rpm</span><br><span class="line">rpm -ivh curl-7.29.0-42.el7.x86_64.rpm</span><br><span class="line">rpm -ivh zlib-devel-1.2.7-17.el7.x86_64.rpm</span><br><span class="line">rpm -ivh openssl-devel-1.0.2k-8.el7.x86_64.rpm</span><br><span class="line">rpm -ivh perl-ExtUtils-MakeMaker-6.68-3.el7.noarch.rpm</span><br><span class="line">rpm -ivh gettext-devel-0.19.8.1-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>以上库需要安装，并需要安装对应依赖。 有时候有些包可能互相依赖，安装时可使用一下命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh perl-ExtUtils-MakeMaker-6.68-3.el7.noarch.rpm perl-ExtUtils-Install-1.58-292.el7.noarch.rpm zlib-devel-1.2.7-17.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>编译安装可能需要的包 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm</span><br><span class="line">rpm -ivh cpp-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-c++-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libgcc-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libgomp-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libstdc++-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh libstdc++-devel-4.4.7-18.el6.x86_64.rpm</span><br><span class="line">rpm -ivh mpfr-2.4.1-6.el6.x86_64.rpm</span><br><span class="line">rpm -ivh ppl-0.10.2-11.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>有时会发生冲突可以使用枪支卸载，或者不考虑依赖安装。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -e  --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span><br><span class="line">//强制卸载</span><br><span class="line"></span><br><span class="line">rpm -i --force --nodeps krb5-devel-1.15.1-8.el7.x86_64.rpm</span><br><span class="line">//强制安装 --force可选</span><br></pre></td></tr></table></figure></p><h2 id="五解压和安装">五、解压和安装</h2><p>解压安装包 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf git-2.15.1.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入解压后的文件夹 <img src="http://us-forever.com/img/git-1.png"> 执行一下命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>检查没有任何出错 <img src="http://us-forever.com/img/git-2.png"> 然后执行以下命令进行编译 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>检查没有问题执行安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>检查没有任何出错 <img src="http://us-forever.com/img/git-4.png"> 六、查看安装结果 —-</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p><img src="http://us-forever.com/img/git-5.png"></p>]]></content>
    
    <summary type="html">
    
      Nginx和Git的离线安装
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 建立网络模型</title>
    <link href="http://weafteam.github.io/posts/5b7df854/"/>
    <id>http://weafteam.github.io/posts/5b7df854/</id>
    <published>2018-03-31T10:23:35.000Z</published>
    <updated>2018-04-02T14:12:49.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-建立网络模型">TensorFlow 建立网络模型</h1><p>上次一我们在fashion-mnist上面体验了一把，但是里面有一些建立模型和一些TensorFlow的基础概念都没有给大家讲，所以这节决定将这方面的知识介绍一些，上节是为了引起大家的注意，TensorFlow具有很强大的功能，我们只能后续慢慢的学习。</p><ol type="1"><li>其实在上一次的实例中，有很多地方确实是很困惑的，如果没有接触过机器学习的小伙伴可能理解起来会有一些问题，那么我开头就稍微讲一下，机器学习有一些什么？就我现在了解的一些内容给大家介绍，有可能有一些不到位的地方，还请多多包涵：</li></ol><blockquote><ul><li>其实机器学习，总的宗旨就是利用数据的特征来做识别和分类等任务</li><li>第一大类是分类工作，假设有一百类，经典的做法，就是使用神经网络提取一些数据的特征，然后利用softmax输出层进行不同种类概率的预测：</li></ul></blockquote><p><span class="math display">\[softmax(i) = \frac{X_i}{\sum_{i=0,99}X_i}\]</span></p><blockquote><ul><li>上面是softmax层计算的公式，从一百类里面找出每一类的概率值，然后按照概率值来预测输入数据是哪一种类型，就像上一次文章里面的fashion-mnist的数据一样，会预测出输出的类别。softmax(i)代表的就是这个种类的概率值，取最大值作为预测类别。</li><li>你可以把一个矩阵看成一个数据集合，一行是一个数据信息，就和我们的关系型数据一样，一行代表一个表的一条信息，那么每列就是每一行数据的一个属性，那么在机器学习里面就是数据的特征了，因为在网络模型中，每个特征都有对应的权重，那么，对于每个特征来说，对于最后的分类，识别等工作起的重要程度是不一样的。这也和我们的数据库信息差不多，有一些信息也是无关紧要的。有些信息可以主要决定这一行数据。</li><li>第二大类就是回归，回归可以看作是一个连续的分类，对于二维数据来说，其实就是根据你给出的数据来拟合一条线。对于三维来讲就是拟合一个平面。再高维就是超平面。</li></ul></blockquote><ol start="2" type="1"><li>最近，也就是2018年3月31在加利福尼亚州山景城的计算机历史博物馆举办了第二届TensorFlow开发者峰会，会上有超过500名使用TensorFlow的用户，还有一些观众，大家有兴趣的话可以关注youtube的TensorFlow官方频道。可以查看开会的视频。</li></ol><ul><li>TensorFlow应用广泛，其中有使用TensorFlow来做开普勒任务分析的</li><li>也有使用TensorFlow预测心脏发作和中风概率</li><li>还有一些应用在现实当中的项目。</li><li>这让我们认识到TensorFlow对于实际领域中应用的越来越广泛，所以我们不学习是不是有点亏。这么好的开源项目。</li></ul><ol start="3" type="1"><li>上一次我们既然做过了一次服装类别识别，那么这次我主要从TensorFlow建立模型的步骤讲起：让大家再深入理解一下TensorFlow。</li></ol><ul><li>第一步也是很重要的一步，那就是导入数据。</li><li>第二步一般就是对数据进行的预处理，一般包括归一化数据，转换数据等操作。</li><li>第三步设置算法的超参数，一般也就是学习率，batch_size(批处理个数)，epoch(轮次)。这里举一个例子，假如你有10000条训练数据。那么，batch_size设置为100，那么你的一个epoch就迭代100次才能将所有数据训练一遍，每次输入数据是100条，因为一个epoch的意思就是训练完一次训练数据，所以一个epoch是迭代100次就可以结束一轮了。learning_rate一般设置为0.1-0.0001之间，但是也不排除一些特殊情况，主要是learning_rate设置的过小，反向传播更新参数的时候速度会很慢，设置的过大，会出现无法收敛的情况。</li><li>第四步设置变量和placeholders，变量是记录权重和偏置项信息的，一般在最小化loss函数的时候，反向传播算法会更新权重和偏置项，TensorFlow导入数据是通过placeholders来实现的，大家还记得我们上次的fashion-mnist识别，我的数据就是通过先定义placeholders，最后在Session运行的时候，在feed_dict这个字典参数里面将训练数据喂进去的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a_var = tf.constant(<span class="number">42</span>)</span><br><span class="line">x_input = tf.placeholder(tf.float32, [n_x, <span class="keyword">None</span>], name=<span class="string">"X"</span>)</span><br><span class="line">x_output = tf.placeholder(tf.float32, [n_y, <span class="keyword">None</span>], name=<span class="string">"y"</span>)</span><br><span class="line"><span class="comment"># 定义输入数据的一些方式</span></span><br></pre></td></tr></table></figure><ul><li>第五步定义图模型，我们有了数据，初始化了变量和placeholders，那我们就需要定义一个图模型，来生成TensorFlow的图模型（计算图）我们必须告诉TensorFlow对我们的数据进行哪些操作，来让我们的模型具有预测能力（更加深入的运算我们在后续的博客里面会陆续讲到）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h_pre_output = tf.add(tf.matmul(W, x_input) + B)</span><br></pre></td></tr></table></figure><ul><li>第六步声明loss函数，在上面计算图中我们定义了一些对我们数据的操作。那么我们需要验证我们预测的输出，和我们真实之间的差距，一般对于回归任务来讲的话，就是平方误差：这样就求得了平方误差。但是对于分类任务，那就是交叉熵误差。就像上一节我们用到的loss生成函数就是softmax这种方式。，交叉熵的公式后续用到再给大家介绍。</li></ul><p><span class="math display">\[loss(i)=\frac{1}{N}\sum{_i}(y\_pre_i-y\_true_i)^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TensorFlow求法：</span><br><span class="line">loss = tf.reduce_mean(tf.square(y_pre - y_true))</span><br></pre></td></tr></table></figure><ul><li>第七步声明了loss函数以后，我们需要使用BP算法也就是反向传播算法来更新权重和偏置项。在TenorFlow框架里面有好多这样的优化器，都在 tf.train这个模块里面。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate = <span class="number">0.001</span>).minimize(loss)</span><br><span class="line">这个就是我们上次使用的优化器，来优化我们的loss</span><br></pre></td></tr></table></figure><ul><li>最后一步那就是初始化会话Session()，开始训练模型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">session.run(init)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>由上面的步骤，大家再结合上一次的网络代码，是不是可以理解了TensorFlow在建立一个网络模型的时候的具体步骤。</li><li>其实在TensorFlow中还有一个很重要的概念，那就是Tensor，上次说过了它的概念，那么接下来我讲一下TensorFlow里面的Tensor。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"><span class="comment"># 定义一个会话，记得，TensorFlow里面都是通过session来执行的</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 创建一个1 * 20的向量</span></span><br><span class="line">tensor_zeros = tf.zeros([<span class="number">1</span>, <span class="number">20</span>])</span><br><span class="line">sess.run(tensor_zeros) <span class="comment"># 你可以运行一下看看</span></span><br><span class="line">my_var = tf.Variable(tf.zeros([<span class="number">1</span>, <span class="number">20</span>])) <span class="comment"># 使用tenso来初始化变量</span></span><br><span class="line">sess.run(my_var.initializer) <span class="comment"># 又一种运行变量初始化器的方式</span></span><br><span class="line">sess.run(my_var) <span class="comment">#打印出来看看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf.ones() 生成全是1</span></span><br><span class="line"><span class="comment"># tf.zeros() 生成全是0</span></span><br><span class="line"><span class="comment"># tf.constant() 生成一个常量Tensor</span></span><br><span class="line"><span class="comment"># 如果我们想要通过一个已知的Tensor来创建另一个，则可以使用ones_like()和zeros_like()这两个函数</span></span><br><span class="line">zero_similar = tf.Variable(tf.zeros_like(tensor_zeros))</span><br><span class="line"></span><br><span class="line">sess.run(zero_similar.initializer)</span><br><span class="line">print(sess.run(zero_similar))</span><br><span class="line"><span class="comment"># 注意上面的两个函数的参数是为了确定生成Tensor的大小，而产生的值是通过函数决定的</span></span><br><span class="line">tf.fill([row, col], <span class="number">-1</span>)  <span class="comment"># 用具体的数字填充</span></span><br><span class="line">tf.linspace(start=<span class="number">0.0</span>, stop=<span class="number">1.0</span>, num=<span class="number">3</span>) <span class="comment"># 线性分布 包括end</span></span><br><span class="line">tf.range(start=<span class="number">6</span>, limit=<span class="number">15</span>, delta=<span class="number">3</span>)    <span class="comment"># 也是线性均匀 不包括end</span></span><br><span class="line">tf.random_normal([row_dim, col_dim], mean=<span class="number">0.0</span>, stddev=<span class="number">1.0</span>) <span class="comment"># 随机 均值0 方差1.0</span></span><br><span class="line">tf.random_uniform([row_dim, col_dim], minval=<span class="number">0</span>, maxval=<span class="number">4</span>) <span class="comment"># 或者最小最大值随机初始化</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line">my_var = tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">20</span>]))</span><br><span class="line"></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line">writer = tf.summary.FileWriter(<span class="string">"./tmp/variable_logs"</span>, graph=sess.graph)</span><br><span class="line"></span><br><span class="line">initialize_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">sess.run(initialize_op)</span><br><span class="line"><span class="comment"># 上面的就是一个Tensor放在一个变量里面，我们使用了一条语句 merged = tf.summary.merge_all() 还有writer = tf.summary.FileWriter("/tmp/variable_logs", graph=sess.graph)，这两句这是为了将变量在TensorBoard里面显示出来，让我们更加了解TensorFLow的一些操作。</span></span><br><span class="line"><span class="comment"># 上面的操作过程会在当前文件夹里面创建一个/tmp/variable_logs文件夹然后会将变量信息存储在一个文件里面</span></span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>那怎么使用tensorboard</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#进去我们的环境变量，然后执行</span><br><span class="line">tensorboard --logdir=tmp的绝对路径</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/01/9zF2P1.png" alt="-"></p><p>可以看到我上面执行的命令。然后在浏览器里面输入127.0.0.1:6006然后你就可以看到刚才那个变量的操作过程，这就是tensorboard的魅力</p><p><img src="https://s1.ax1x.com/2018/04/01/9zF7ad.png" alt="-"></p><p>上面就是一个变量在进行初始化时候可视化显示</p><ol start="7" type="1"><li>Placeholders使用(一样可以使用tensorboard来查看)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.python.framework import ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line"># 定义一个placeholder</span><br><span class="line">x = tf.placeholder(tf.float32, shape = (4, 4))</span><br><span class="line"></span><br><span class="line"># 随机生成4 * 4的矩阵</span><br><span class="line">reand_array = np.random.rand(4, 4)</span><br><span class="line">y = tf.identity(x) # 返回与输入对象相同的内容和大小</span><br><span class="line">print(sess.run(y, feed_dict=&#123;x: rand_array&#125;))</span><br><span class="line"></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line">writer = tf.summary.FileWriter(&quot;./tmp/variable_logs&quot;, sess.graph)</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/01/9zAshR.png" alt="-"></p><h5 id="总结">总结</h5><p>这次我们就TensorFlow的一些基础概念的介绍，也是为了让大家在以后的TensorFlow使用过程中少一些疑问，后面的章节，我们会慢慢深入。小伙伴们不要着急，我的邮箱是air@weaf.top，依旧是那个可以交流学习的milittle。谢谢大家的驻足。</p><p><a href="https://weaf.top/posts/8e8e4531/" target="_blank" rel="noopener">第一篇 TensorFlow安装</a></p><p><a href="https://weaf.top/posts/b0821049/" target="_blank" rel="noopener">第二篇 TensorFlow初体验（fasion-mnist识别）</a></p><p><a href="https://weaf.top/posts/233074e6/" target="_blank" rel="noopener">修改pip全局镜像方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-建立网络模型&quot;&gt;TensorFlow
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>文本聚类系列教程：（三）构建词袋空间VSM（Vector Space Model）</title>
    <link href="http://weafteam.github.io/posts/a751f7e5/"/>
    <id>http://weafteam.github.io/posts/a751f7e5/</id>
    <published>2018-03-30T06:00:08.000Z</published>
    <updated>2018-04-14T05:59:22.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咱们今天先聊个概念吧，著名的聚类假设，这也是文本聚类的依据，内容如下：该假设认为，同类的文档相似度较大，而不同类的文档相似度较小。</p></blockquote><hr><h1 id="概念">概念：</h1><p>对于上述概念，也就是做文本聚类的基础，如果不相关的文档反而相似度高，我们便无法做文本聚类。</p><p>接下来再说VSM(Vector Space Model),对于VSM的定义，我在网上搜罗了些资料，如下所示：</p><p>Vector space model (or term vector model) is an algebraic model for representing text documents (and any objects, in general) as vectors of identifiers, such as, for example, index terms. It is used in information filtering, information retrieval, indexing and relevancy rankings. Its first use was in the SMART Information Retrieval System.</p><p>A document is represented as a vector. Each dimension corresponds to a separate term. If a term occurs in the document, its value in the vector is non-zero. Several different ways of computing these values, also known as (term) weights, have been developed. One of the best known schemes is tf-idf weighting.</p><p>The definition of term depends on the application. Typically terms are single words, keywords, or longer phrases. If the words are chosen to be the terms, the dimensionality of the vector is the number of words in the vocabulary (the number of distinct words occurring in the corpus).</p><p><strong>拙劣的翻译：</strong></p><p>向量空间模型是用来表示文本文档（通常也包含一些对象）的特征向量的代数模型，例如索引词项。它被应用于信息过滤、信息检索、索引和相关度计算。这个模型最早被应用于SMART信息检索系统。</p><p>一个文本文档表示一个向量。每一个维度相当于一个单独的词项（term）。如果一个词项（term）出现在一个文档中，那么它在表示该文档的向量中对应项不为0.有一些计算这些词项（term）权重的方法被逐渐提出来，其中最著名的方法就是tf-idf权重计算方法。</p><p>对于词项（term）的定义依赖于应用。一般而言，词项（term）可以是单词、关键字、或者长短语。如果单词作为词项（term），那么向量中的维度就是词汇表中的单词的个数（出现在文档全集中所有不同的单词的数量）。</p><p><strong>小荔枝：</strong></p><p>举个荔枝吧 ，方便理解上述的概念。首先假设有这样两个文本</p><p>1.<code>我来到北京清华大学</code></p><p>2.<code>他来到了网易杭研大厦</code></p><p>分词结果为：<code>我/来到/北京/清华大学</code>和<code>他/来到/了/网易/杭研/大厦</code>统计所有文档的词集合：<code>我/来到/北京/清华大学/他/了/网易/杭研/大厦</code>，按照1983停用词去除停用词后结果为：<code>来到/北京/清华大学/网易/杭研/大厦</code></p><p>我们对这两个文本构建向量，结果如下</p><table><thead><tr class="header"><th></th><th>来到</th><th>北京</th><th>清华大学</th><th>网易</th><th>杭研</th><th>大厦</th></tr></thead><tbody><tr class="odd"><td>文本1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>文本2</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>相信你已经对VSM的认识有了一个大致的轮廓，但是细心的你也可能发现了，我们在上述的例子中计算term值的方法仅仅只是计数，这样的term值是否有意义呢？我们是否能用这样的方法直接进行接下来的计算呢？对于前一个问题，答案是肯定的。不管在此基础上做什么样的改进，我们最基础的就是统计单词出现的次数，那就让我们先把上述的代码实现一下吧(与该文件同目录下有个名为txt1的文件夹，里面有1.txt和2.txt两个文件，内容分别是上述所说的两个文档，我们在上次RmStopWord.py的基础上再做修改)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) <span class="comment"># 获取当前文件的dir路径</span></span><br><span class="line">stopwords_path = <span class="string">'stopwords1893.txt'</span>  <span class="comment"># 停用词表路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#text = open(path.join(d, text_path),'rb').read()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_from_file</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_name,<span class="string">"r"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        words = fp.read()</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RmStopWords</span><span class="params">(text)</span>:</span></span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=<span class="keyword">False</span>)</span><br><span class="line">    liststr=<span class="string">"/ "</span>.join(seg_list) <span class="comment"># 添加切分符</span></span><br><span class="line">    f_stop = open(stopwords_path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f_stop_text = f_stop.read()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f_stop.close( )</span><br><span class="line">    f_stop_seg_list=f_stop_text.split(<span class="string">'\n'</span>) <span class="comment"># 停用词是每行一个，所以用/n分离</span></span><br><span class="line">    <span class="keyword">for</span> myword <span class="keyword">in</span> liststr.split(<span class="string">'/'</span>):</span><br><span class="line">        <span class="comment">#对于每个切分的词都去停用词表中对比</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span>(myword.strip() <span class="keyword">in</span> f_stop_seg_list) <span class="keyword">and</span> len(myword.strip())&gt;<span class="number">1</span>:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    <span class="keyword">return</span> mywordlist</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_vector</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    names = [ os.path.join(file_path,f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(file_path) ]</span><br><span class="line">    txts = [ open(name).read() <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    docs = []</span><br><span class="line">    word_set = set()</span><br><span class="line">    <span class="keyword">for</span> txt <span class="keyword">in</span> txts:</span><br><span class="line">        doc = RmStopWords(txt)</span><br><span class="line">        docs.append(doc)</span><br><span class="line">        word_set |= set(doc)</span><br><span class="line">        </span><br><span class="line">    word_set = list(word_set)</span><br><span class="line">    docs_vsm = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只是想显示有多少term</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word_set[:<span class="number">30</span>]:</span><br><span class="line">        print(word)</span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">        temp_vector = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> word_set:</span><br><span class="line">            temp_vector.append(doc.count(word) * <span class="number">1.0</span>)</span><br><span class="line">        docs_vsm.append(temp_vector)</span><br><span class="line">    docs_matrix = np.array(docs_vsm)</span><br><span class="line">    <span class="keyword">return</span> docs_matrix</span><br><span class="line">    </span><br><span class="line"><span class="comment"># txt2 = RmStopWords(read_from_file(text1_path))</span></span><br><span class="line"><span class="comment"># print(txt2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件路径为txt1/1.txt和2.txt，只不过我让程序循环扫描txt1下所有的文本文件</span></span><br><span class="line">txt3 = get_all_vector(<span class="string">'txt1'</span>)</span><br><span class="line">print(txt3)</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><a href="https://imgchr.com/i/9x712t" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/03/31/9x712t.png" alt="vsmResult.png"></a></p><p><strong>分析：</strong></p><p>上述结果不言而喻，那么我们接着讨论，显而易见，我既然提出了第二个疑问就一定有它被提出的道理，仅仅只计算term值的方法显然存在问题，我们再随便举个例子，文本1中<code>北京</code>只出现了1次，但是文本1中只有3个单词，文本2中<code>北京</code>出现了10次但是文本2中有1000个单词，那我们用上述的方法显然不合适。所以接下来我们便要讲一个最著名的方法tf-idf计算权值的方法。</p><h1 id="tf-idfterm-frequencyinverse-document-frequency">TF-IDF(term frequency–inverse document frequency)</h1><p>维基百科和百度百科上的讲的很清楚，这里截取概念方便大家阅读，更详细的内容请参考前面所说的两个百科。</p><p><strong>TF-IDF是一种统计方法，用以评估一个词(term)对于一个文件集或者一个语料库中的一份文件的重要程度。一个词(term)的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</strong></p><p><strong>原理：</strong></p><p>TF-IDF的主要思想是：如果某个词或短语(term)在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语(term)具有很好的类别区分能力，适合用来分类。如果包含词条term的文档越少，也就是n越小，则IDF越大，则说明词条term也具有很好的类别区分能力。</p><p><strong>思考：</strong></p><p>现在想一下我们刚才提出的问题，针对我们上述的问题：同一词语在长文件里可能会比短文件有更高的词数，而不管该词重要与否。那么我们对词数做归一化就可以了，而TF就帮我们做了这样的事。那么我们就先给出TF的运算公式吧。</p><p><span class="math inline">\(tf_i,_j = \frac{n_i,_j}{\sum_k n_k,_j}\)</span></p><p>TF公式解读：上式中分子是该词在文件中出现的次数，而分母则是该词在文件中出现的词数之和。</p><p><strong>我们再讲个小问题：</strong></p><p>如果某一类文档C中包含词条t的文档数为m，而其他类包含t的文档总数为k，显然所有包含t的文档数n=m+k，而当m变大的时候，n也变大，这是后按照IDF的计算方法计算得到的IDF值会变小，也就相对应的说明该词条t类别区分能力不强。但是实际上，如果一个词条在一个类的文件中频繁出现，则说明该词条能够很好的代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。<strong>其实这就是IDF的不足</strong>。</p><p>针对这个问题，我的想法是TF-IDF用来做信息检索和数据挖掘，为了获取更精准的效果，我们宁愿忽略这样不足来换取更加理想的效果（也就是TF-IDF计算出更大的权值）。（这里我的理解是这样的，如果有人有更好的解释，欢迎与我进行讨论，邮箱：well@weaf.top）</p><p>那么接下来就该给出IDF的计算公式了：</p><p><span class="math inline">\(idf(t,D) = log(\frac{N}{\lvert {d \in D, t \in d}\rvert})\)</span></p><p>IDF公式解读：</p><p>|D|：语料库中文件的总数</p><p>分子为包含该词条t的文件数目，如果该词条不在语料库中，就会导致分母为零，因此一般使用1。</p><p>那就接着我们上述代码，运用TF-IDF，把对应的矩阵的单纯计数转换成权值计算吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">def get_all_vector(file_path):</span><br><span class="line">    names = [ os.path.join(file_path,f) for f in os.listdir(file_path) ]</span><br><span class="line">    posts = [ open(name).read() for name in names]</span><br><span class="line">    docs = []</span><br><span class="line">    word_set = set()</span><br><span class="line">    for post in posts:</span><br><span class="line">        doc = RmStopWords(post)</span><br><span class="line">        docs.append(doc)</span><br><span class="line">        word_set |= set(doc)</span><br><span class="line"></span><br><span class="line">    word_set = list(word_set)</span><br><span class="line">    docs_vsm = []</span><br><span class="line">    for word in word_set[:30]:</span><br><span class="line">        print(word)</span><br><span class="line">    for doc in docs:</span><br><span class="line">        temp_vector = []</span><br><span class="line">        for word in word_set:</span><br><span class="line">            temp_vector.append(doc.count(word) * 1.0)</span><br><span class="line">        docs_vsm.append(temp_vector)</span><br><span class="line">    docs_matrix = np.array(docs_vsm)</span><br><span class="line">    #return docs_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    column_sum = [ float(len(np.nonzero(docs_matrix[:,i])[0])) for i in range(docs_matrix.shape[1]) ]</span><br><span class="line">    column_sum = np.array(column_sum)</span><br><span class="line">    column_sum = docs_matrix.shape[0] / column_sum</span><br><span class="line">    </span><br><span class="line">idf =  np.log(column_sum)</span><br><span class="line">    idf =  np.diag(idf)</span><br><span class="line">    </span><br><span class="line">i = 0    </span><br><span class="line">    for doc_v in docs_matrix:    </span><br><span class="line">        if doc_v.sum() == 0:</span><br><span class="line">            docs_matrix[i] = docs_matrix[i]/1</span><br><span class="line">        else:</span><br><span class="line">            docs_matrix[i] = docs_matrix[i] / (doc_v.sum())</span><br><span class="line">        i+=1</span><br><span class="line">    </span><br><span class="line">tfidf = np.dot(docs_matrix,idf)</span><br><span class="line">    return names,tfidf</span><br><span class="line"></span><br><span class="line">txt3 = get_all_vector(&apos;txt1&apos;)</span><br><span class="line">print(txt3)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/04/14/5ad1988749e40.png" alt="tfidfResult.png"></p><p>本次的学习会用到很多numpy的知识，请大家自行查阅。如有兴趣，请思考为什么在新的权值矩阵中“来到”一词的权重变成了0。感谢大家的阅读~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;咱们今天先聊个概念吧，著名的聚类假设，这也是文本聚类的依据，内容如下：该假设认为，同类的文档相似度较大，而不同类的文档相似度较小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1
        
      
    
    </summary>
    
      <category term="文本聚类" scheme="http://weafteam.github.io/categories/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="文本聚类" scheme="http://weafteam.github.io/tags/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>修改pip全局镜像</title>
    <link href="http://weafteam.github.io/posts/233074e6/"/>
    <id>http://weafteam.github.io/posts/233074e6/</id>
    <published>2018-03-27T12:29:36.000Z</published>
    <updated>2018-04-10T08:57:00.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改pip全局镜像">修改pip全局镜像</h3><p>第一次我们在windows上面安装了Anaconda，在使用pip安装Tensorflow中速度过慢，所以我为大家介绍一中修改全局pip源的方法（这样在使用pip下载依赖库的时候就会快一些）：</p><ol type="1"><li>打开用户主目录：我的是<code>C:\Users\milittle</code>。</li><li>在里面新建pip文件夹，在pip文件夹中建立pip.ini文件。</li><li>在pip.ini文件中添加如下配置信息，我使用的豆瓣源：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br><span class="line">index-url = https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>最后的目录结构就是：<code>C:\Users\milittle\pip\pip.ini</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>如何理解描述符</title>
    <link href="http://weafteam.github.io/posts/5dd0238f/"/>
    <id>http://weafteam.github.io/posts/5dd0238f/</id>
    <published>2018-03-25T15:52:32.000Z</published>
    <updated>2018-04-02T14:12:49.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上篇文章中挖了 property 和描述符的坑，这篇就把它填上好了_(:з)∠)_</p><p>property 是用描述符实现的，所以先说说 property。</p><h2 id="property">property</h2><p>property 本身是一个实现了描述符协议的类，在不改变类接口的情况下，提供了一组对实例属性的读取、写入和删除操作。下面举个例子，一个银行账户的抽象，很容易实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, balance)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.balance = balance</span><br></pre></td></tr></table></figure><p>银行账户最常见的操作就是存款和取款了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">100</span>)  <span class="comment"># 创建一个有 100 块存款的账户</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: account.balance</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: account.balance -= <span class="number">90</span>  <span class="comment"># 取 90 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: account.balance  <span class="comment"># 还剩 10 块</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: account.balance += <span class="number">30</span>  <span class="comment"># 存 30 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: account.balance  <span class="comment"># 现在有 40 块</span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">40</span></span><br></pre></td></tr></table></figure><p>但是这里有个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: account.balance -= <span class="number">50</span>  <span class="comment"># 再取 50 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: account.balance  <span class="comment"># 存款变成了负数！</span></span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">-10</span></span><br></pre></td></tr></table></figure><p>当然这种操作是不该被允许的，我们需要对 <code>balance</code> 的写入做限制。Jawa 之类的语言会创建一组 getter、setter 方法来管理属性，但是这并不 Python，也对现有的代码不友好。正确的方式是使用 property。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, balance)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @balance.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'balance must greater than 0.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._balance = value</span><br></pre></td></tr></table></figure><p>现在 <code>balance</code> 被禁止设为小于 0 的数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: account.balance</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: account.balance += <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: account.balance -= <span class="number">200</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: balance must greater than <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: account.balance</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">140</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">-1</span>)  <span class="comment"># 初始化的时候也不行！</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: balance must greater than <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>可以看到我们使用 <code>balance</code> 的方式没有发生变化，但是对值的限制已经生效了。</p><p>property 还有一个 <code>deleter</code> 装饰器，处理应用于属性的 <code>del</code>；当然，<code>del</code> 本身用的也不多，大多数时候把销毁操作交给 Python 就可以了。不过如果涉及到复杂对象的引用，要做到 RAII（误，还是要手动实现的。</p><h3 id="property-是类">property 是类</h3><p>property 本身是用 C 实现的，<a href="https://docs.python.org/3/howto/descriptor.html#properties" target="_blank" rel="noopener">这里</a>有一个纯 Python 的实现。正如上文所说，它本身是一个类，构造方法的签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>熟悉一点装饰器用法的话就可以看出上面的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实际上就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    balance = property(fget=get_balance)</span><br></pre></td></tr></table></figure><p>如果不熟悉的话，下一篇就讲装饰器好了（误</p><h3 id="property-的实例是类属性">property 的实例是类属性</h3><p>上面的代码段同时展示了这样一个事实：property 的实例是类属性。这就涉及到了属性查找顺序的问题，简单试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    data = <span class="string">'data!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: f.data</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: f.data = <span class="string">'f.data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: f.data</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'f.data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: Foo.data</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'data!'</span></span><br></pre></td></tr></table></figure><p>实例属性覆盖了类属性，符合直觉。那么对 property 的实例来说呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: f.bar</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">'bar!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: f.bar = <span class="string">'bar'</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure><p>尝试给 <code>bar</code> 赋值，失败了，也符合 property 的工作方式：执行赋值时，如果没有 setter 方法就抛出异常。那么直接修改 <code>f.__dict__</code> 呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: f.__dict__[<span class="string">'bar'</span>] = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: f.bar</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><p>也不行，property 的实例完全覆盖了实例属性。但是，它是一个类属性，所以我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: Foo.bar</span><br><span class="line">Out[<span class="number">10</span>]: &lt;property at <span class="number">0x29c44800408</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: Foo.bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: f.bar</span><br><span class="line">Out[<span class="number">12</span>]: <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: f.bar = <span class="string">'ba'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: f.bar</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'ba'</span></span><br></pre></td></tr></table></figure><p>对类属性的覆盖使 <code>bar</code> 不再是一个 property 的实例，所以也就不会覆盖后续的赋值了。</p><p>当然我们仍然可以用一个 property 的实例再次覆盖 <code>Foo.bar</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: Foo.bar = property(fget=<span class="keyword">lambda</span> self: <span class="string">'bar!'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: f.bar</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><p>恢复原样。 property 的实例这种先从类中开始属性查找的方式，是一类描述符的工作模式。接下来就说说描述符。</p><h2 id="描述符">描述符</h2><p>描述符是指实现了描述符协议的类，这个协议包含四个方法，分别是 <code>__get__</code>，<code>__set__</code>，<code>__delete__</code> 和 Python 3.6 新增的 <code>__set_name__</code>。通常，只要实现了 <code>__get__</code> 或 <code>__set__</code>，就可以被称之为描述符。在某个角度上说，描述符的作用相当于抽象的 property，可以为一组属性提供相同的读取、写入和删除逻辑。接下来，还是从数据验证的例子开始。</p><p>下面是商店中一项商品的抽象，包含商品名、数量和单价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    amount = Storage(<span class="string">'amount'</span>)</span><br><span class="line">    price = Storage(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, amount, price)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.amount = amount</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure><p>其中的 <code>amount</code> 和 <code>price</code> 都必须大于 0，所以可以用统一的描述符实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f'<span class="subst">&#123;self.name&#125;</span> must greater than 0.'</span>)</span><br></pre></td></tr></table></figure><p>由于我们并没有对读取方法有特别的需求，所以不用实现 <code>__get__</code> 方法。</p><p>试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: item = Item(<span class="string">'orange'</span>, <span class="number">100</span>, <span class="number">0</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: price must greater than <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: item = Item(<span class="string">'orange'</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: amount must greater than <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>如果 <code>amount</code> 或 <code>price</code> 中的任何一个不大于 0，都会被禁止。</p><p>这里需要解释一下 <code>__set__</code> 的签名中的 <code>instance</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>instance</code> 是 <code>Item</code> 的实例。因为描述符应该管理实例的属性，所以需要额外的参数提供相应的实例。这也是为什么我们不能这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    self.__dict__[self.name] = value</span><br></pre></td></tr></table></figure><p>这实际上是为描述符实例设置了值，而描述符实例是<code>Item</code> 类的类属性，所有的 <code>Item</code> 实例都共享相同的描述符实例。修改了某个描述符实例，相当于修改了所有的 <code>Item</code> 实例。</p><p>上面的例子有个缺点，初始化描述符实例的时候需要重复属性的名字。我们希望可以简单的写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    amount = Storage()</span><br><span class="line">    price = Storage()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>而不需要在描述符的构造方法中重复属性名。这就是 Python 3.6 新增的 <code>__set_name__</code> 方法的作用。只要实现 <code>__set_name__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>同样解释一下函数签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>owner</code> 是 <code>Item</code> 类本身，<code>name</code> 是引用描述符实例的变量的名字。</p><p>如果使用的 Python 版本在 3.6 以下呢？有两个方法：第一个是用元类接管<code>Item</code>类的创建过程，这个不在这篇文章的内容之内（可能又挖了一个坑；第二个就是为每个描述符实例生成与属性名无关但是唯一字符串，用来代替属性名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line"></span><br><span class="line">    _counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        self.name = <span class="string">f'_<span class="subst">&#123;cls.__name__&#125;</span>#<span class="subst">&#123;cls._counter&#125;</span>'</span></span><br><span class="line">        cls._counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, self.name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'must greater than 0.'</span>)</span><br></pre></td></tr></table></figure><p>由于 <code>Item</code> 中的属性名和我们实际保存的属性名不同，所以需要实现 <code>__get__</code> 方法。与 <code>__set_name__</code> 签名中的 <code>owner</code> 含义相同，<code>__get__</code> 方法签名中的 <code>owner</code> 也是 <code>Item</code> 类本身。</p><p>现在，我们使用 <code>_Storage#N</code> 这样的名称在 <code>Item</code> 实例中保存属性。当然，这样的名称会让人有点困惑，特别是以类属性访问的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: Item.amount</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'_Storage#0'</span></span><br></pre></td></tr></table></figure><p>为了避免在如此明显的地方暴露我们的实现细节，我们可以修改异常的错误消息，或者，内省描述符实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.name)</span><br></pre></td></tr></table></figure><h3 id="两类描述符">两类描述符</h3><p>上述例子中对数据属性的控制和管理是描述符的典型用途之一。这种实现了 <code>__set__</code> 方法，接管了设置属性行为的描述符，被称为覆盖型描述符，没有定义 <code>__set__</code> 方法的描述符，被称为非覆盖型描述符。由于 Python 中对实例属性和类属性的处理方式不同，这两类描述符也有不同的行为。</p><h4 id="覆盖型描述符">覆盖型描述符</h4><p>实现了 <code>__set__</code> 方法的描述符就是覆盖型描述符。这类描述符虽然是类属性，但是会覆盖实例属性的赋值操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Override</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    override = Override()</span><br></pre></td></tr></table></figure><p>下面做一些实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: m.override = <span class="number">1</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: Manager.override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.__dict__[<span class="string">'override'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: m.__dict__</span><br><span class="line">Out[<span class="number">6</span>]: &#123;<span class="string">'override'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: m.override</span><br><span class="line">get!</span><br></pre></td></tr></table></figure><p>可以看出，无论以实例属性还是类属性访问 <code>override</code>，都会触发 <code>__get__</code> 方法；为实例属性 <code>override</code> 赋值会触发 <code>__set__</code> 方法；即使跳过描述符直接为 <code>m.__dict__</code> 赋值，读取 <code>override</code> 的操作仍然会被描述符覆盖。</p><h5 id="没有-__get__-方法的覆盖型描述符">没有 <code>__get__</code> 方法的覆盖型描述符</h5><p>如果只实现了 <code>__set__</code> 会发生什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverrideNoGet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    override_no_get = OverrideNoGet()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">2</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: Manager.override_no_get</span><br><span class="line">Out[<span class="number">3</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: m.override_no_get = <span class="number">1</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">5</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: m.__dict__[<span class="string">'override_no_get'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: m.override_no_get = <span class="number">2</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，没实现 <code>__get__</code> 方法，无论以实例属性还是类属性访问 <code>override_no_get</code>，都会返回描述符实例；而赋值操作可以触发 <code>__set__</code> 方法；由于我们的 <code>__set__</code> 方法并没有真正修改实例属性，所以再次访问 <code>override_no_get</code> 仍然会得到描述符实例；通过 <code>m.__dict__</code> 修改实例属性后，实例属性就会覆盖描述符；不过只有访问实例属性时才是如此，赋值仍然由 <code>__set__</code> 处理。</p><h4 id="非覆盖型描述符">非覆盖型描述符</h4><p>没有实现 <code>__set__</code> 方法的描述符就是非覆盖型描述符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverride</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    non_override = NonOverride()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: Manager.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: m.non_override = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.non_override</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: Manager.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="keyword">del</span> m.non_override</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: m.non_override</span><br><span class="line">get!</span><br></pre></td></tr></table></figure><p>无论访问实例属性还是类属性，都会触发 <code>__get__</code> 方法；由于没有 <code>__set__</code> 方法，对属性的赋值不会被干涉；对属性复制之后，实例属性就会覆盖同名的描述符，但是访问类属性仍然可以触发 <code>__get__</code> 方法；如果把 <code>non_override</code> 从实例中删除，访问 <code>non_override</code> 的操作又会交给 <code>__get__</code>。</p><p>当然，描述符都是定义在类上的，如果对同名的类属性进行赋值，就会完全替换掉描述符。这里表现出读、写属性时的不对等：对类属性的读操作可以被 <code>__get__</code> 处理，但是写操作不会。当然，了解一些 Python 的话就会知道还存在着另一种不对等：读取实例属性时，会返回实例属性，如果实例属性不存在，会返回类属性；但是为实例属性赋值时，如果实例属性不存在，会在实例中创建属性，不会影响到类属性。</p><h2 id="结语">结语</h2><p>描述符充斥在 Python 底层（举个例子：Python 中的方法是怎么实现的？）与各种框架中，理解描述符是体会 Python 世界工作原理和设计美学的重要方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上篇文章中挖了 property 和描述符的坑，这篇就把它填上好了_(:з)∠)_&lt;/p&gt;
&lt;p&gt;property 是用描述符实现的，所以先说说 property。&lt;/p&gt;
&lt;h2
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow 初体验 （Fashion-mnist）</title>
    <link href="http://weafteam.github.io/posts/b0821049/"/>
    <id>http://weafteam.github.io/posts/b0821049/</id>
    <published>2018-03-25T13:18:37.000Z</published>
    <updated>2018-04-02T14:12:49.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-初体验fashion-mnist">TensorFlow 初体验（Fashion-mnist）</h1><ol type="1"><li>接着上一讲的内容，想必大家已经通过我的教程安装好了TensorFlow了吧，那我们这节课通过安装简单的跨平台的集成开发环境Spyder，在这个集成开发环境上面实现一些python程序。具体安装过程见如下阐述：</li></ol><ul><li>首先在应用程序里面找到Anaconda应用程序，打开里面的Anaconda Navigator，然后打开以后，选中我们上次建立好的环境tensorflow。</li></ul><p><img src="https://s1.ax1x.com/2018/03/25/9qTXNV.png" alt="-"></p><ul><li>选中tensorflow这个环境变量以后，看到里面有一个集成开发环境叫spyder，这个工具就是今天我们要安装的，我的已经安装好了，所以是Launch，你们的没有安装好，所以是install状态，点解安装就好。（这个地方也可能需要翻墙）。</li><li>这个安装好以后，你就会在应用文件夹里面出现一个Spyder(tensorflow)这个应用程序，以后你就从应用文件夹启动就好。</li><li>那么启动以后：我也是启动了，出现了以下的情况：不慌，慢慢来。</li></ul><p><img src="https://s1.ax1x.com/2018/03/25/9q7njH.png" alt="-"></p><ul><li>看到上面的错误，这个错误提示是因为没有安装jedi这个依赖库，而且要求版本要大于0.9.0。那我们接下来解决一下这个问题。</li></ul><blockquote><p>小插曲，一下就可以解决，具体操作步骤:</p><ol type="1"><li>还是打开上次那个AnacondaPrompt的命令行</li><li>进去以后，执行<code>activate tensorflow</code> 相当于你要在这个环境下面给这个spyder安装这个依赖</li><li>进去以后，执行<code>pip install jedi==0.9.0</code> 就可以了，然后重启spyder（可以直接在这个环境里面输入<code>spyder</code>命令就可以实现spyder的启动，你也可以在应用文件夹里面启动，性质是一样的）</li><li>不出什么意外的话，spyder使用就没有问题了，有什么问题可以发邮件给我！！！</li></ol></blockquote><ul><li>解决了上面的小插曲以后，我们在spyder中输入以下代码进行测试。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">sess = tf.Session()</span><br><span class="line">init = tf.global_variables_initializer() </span><br><span class="line"><span class="comment"># 此处的init是全局变量初始化器，</span></span><br><span class="line"><span class="comment"># TensorFlow的session必须执行这个初始化器才能执行前面建立好的图，</span></span><br><span class="line"><span class="comment"># 所以，这个是很重要的一点，后续也会强调</span></span><br><span class="line"><span class="comment">#（也就是后续再网络中建立变量就是通过那个初始化器来进行初始化工作的）</span></span><br><span class="line"><span class="comment"># 其实在没有变量的时候，这个初始化器是不需要的</span></span><br><span class="line"><span class="comment"># 但是为了让大家形成习惯，还是写上</span></span><br><span class="line">sess.run(init)</span><br><span class="line">hello = tf.constant(<span class="string">'hello world'</span>)</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/03/25/9q7r5V.png" alt="-"></p><ul><li>上图中左面是代码书写区域，右面上半部分是变量查看区域，还有文件夹区域可以切换，右面下半部分是执行console区域，我输入上面的代码，执行以后console区域打出hello world字符串。</li></ul><ol start="2" type="1"><li>从上面的一些简单的测试以后，我们进入今天的主题，fashion-minist的识别，fashion-minist是一个服装识别的一个数据集，在这个数据集之前有一个mnist手写体识别数据集，这个手写数据集对应我们手写的十个数字，然后通过设计网络来识别手写体。但是今天我们不做手写体识别，直接来做fashion-minist识别。</li></ol><ul><li>闲话少说，上代码，边写边说。</li></ul><p>首先目标是实现衣服种类的识别。</p><p>数据可以在 <a href="https://github.com/zalandoresearch/fashion-mnist" target="_blank" rel="noopener">Zalando_Fashion_MNIST_repository</a>这个Github仓库获取。</p><p>数据分为60000训练数据和10000测试数据，图片都是灰度图片，大小为28 X 28，总共也是由10类组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Mar 25 15:16:23 2018</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: milittle</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一些必要的库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 数学计算库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 画图的一个库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf <span class="comment"># TensorFlow的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">fashion_mnist = input_data.read_data_sets(<span class="string">'input/data'</span>, one_hot = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个服装对应表</span></span><br><span class="line">label_dict = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'T-shirt/top'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'Trouser'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Pullover'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'Dress'</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">'Coat'</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">'Sandal'</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">'Shirt'</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">'Sneaker'</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">'Bag'</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">'Ankle boot'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取随机的数据和它的label</span></span><br><span class="line">sample_1 = fashion_mnist.train.images[<span class="number">47</span>].reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">sample_label_1 = np.where(fashion_mnist.train.labels[<span class="number">47</span>] == <span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">sample_2 = fashion_mnist.train.images[<span class="number">23</span>].reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">sample_label_2 = np.where(fashion_mnist.train.labels[<span class="number">23</span>] == <span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用matplot画出这个image和label</span></span><br><span class="line">print(<span class="string">"y = &#123;label_index&#125; (&#123;label&#125;)"</span>.format(label_index=sample_label_1, label=label_dict[sample_label_1]))</span><br><span class="line">plt.imshow(sample_1, cmap=<span class="string">'Greys'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"y = &#123;label_index&#125; (&#123;label&#125;)"</span>.format(label_index=sample_label_2, label=label_dict[sample_label_2]))</span><br><span class="line">plt.imshow(sample_2, cmap=<span class="string">'Greys'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就是设计网络参数</span></span><br><span class="line">n_hidden_1 = <span class="number">128</span> <span class="comment"># 第一个隐藏层的单元个数</span></span><br><span class="line">n_hidden_2 = <span class="number">128</span> <span class="comment"># 第二个隐藏层的单元个数</span></span><br><span class="line">n_input = <span class="number">784</span> <span class="comment"># fashion mnist输入图片的维度（单元个数） (图片大小: 28*28)</span></span><br><span class="line">n_classes = <span class="number">10</span> <span class="comment"># fashion mnist的种类数目 (0-9 数字)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 placeholders</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_placeholders</span><span class="params">(n_x, n_y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    为sess创建一个占位对象。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    n_x -- 向量, 图片大小 (28*28 = 784)</span></span><br><span class="line"><span class="string">    n_y -- 向量, 种类数目 (从 0 到 9, 所以是 -&gt; 10种)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回参数:</span></span><br><span class="line"><span class="string">    X -- 为输入图片大小的placeholder shape是[784, None] </span></span><br><span class="line"><span class="string">    Y -- 为输出种类大小的placeholder shape是[10, None] None在这里表示以后输入的数据可以任意多少</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    X = tf.placeholder(tf.float32, [n_x, <span class="keyword">None</span>], name=<span class="string">"X"</span>)</span><br><span class="line">    Y = tf.placeholder(tf.float32, [n_y, <span class="keyword">None</span>], name=<span class="string">"Y"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试上面的create_placeholders()</span></span><br><span class="line">X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">print(<span class="string">"Shape of X: &#123;shape&#125;"</span>.format(shape=X.shape))</span><br><span class="line">print(<span class="string">"Shape of Y: &#123;shape&#125;"</span>.format(shape=Y.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义初始化参数参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数初始化，下面是每个参数的shape，总共有三层</span></span><br><span class="line"><span class="string">                        W1 : [n_hidden_1, n_input]</span></span><br><span class="line"><span class="string">                        b1 : [n_hidden_1, 1]</span></span><br><span class="line"><span class="string">                        W2 : [n_hidden_2, n_hidden_1]</span></span><br><span class="line"><span class="string">                        b2 : [n_hidden_2, 1]</span></span><br><span class="line"><span class="string">                        W3 : [n_classes, n_hidden_2]</span></span><br><span class="line"><span class="string">                        b3 : [n_classes, 1]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    包含所有权重和偏置项的dic</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置随机数种子</span></span><br><span class="line">    tf.set_random_seed(<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为每一层的权重和偏置项进行初始化工作</span></span><br><span class="line">    W1 = tf.get_variable(<span class="string">"W1"</span>, [n_hidden_1, n_input], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b1 = tf.get_variable(<span class="string">"b1"</span>, [n_hidden_1, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    W2 = tf.get_variable(<span class="string">"W2"</span>, [n_hidden_2, n_hidden_1], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b2 = tf.get_variable(<span class="string">"b2"</span>, [n_hidden_2, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    W3 = tf.get_variable(<span class="string">"W3"</span>, [n_classes, n_hidden_2], initializer=tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b3 = tf.get_variable(<span class="string">"b3"</span>, [n_classes, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将参数存储在一个dict对象里面返回去</span></span><br><span class="line">    parameters = &#123;</span><br><span class="line">        <span class="string">"W1"</span>: W1,</span><br><span class="line">        <span class="string">"b1"</span>: b1,</span><br><span class="line">        <span class="string">"W2"</span>: W2,</span><br><span class="line">        <span class="string">"b2"</span>: b2,</span><br><span class="line">        <span class="string">"W3"</span>: W3,</span><br><span class="line">        <span class="string">"b3"</span>: b3</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试初始化参数</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    print(<span class="string">"W1 = &#123;w1&#125;"</span>.format(w1=parameters[<span class="string">"W1"</span>]))</span><br><span class="line">    print(<span class="string">"b1 = &#123;b1&#125;"</span>.format(b1=parameters[<span class="string">"b1"</span>]))</span><br><span class="line">    print(<span class="string">"W2 = &#123;w2&#125;"</span>.format(w2=parameters[<span class="string">"W2"</span>]))</span><br><span class="line">    print(<span class="string">"b2 = &#123;b2&#125;"</span>.format(b2=parameters[<span class="string">"b2"</span>]))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播算法（就是神经网络的前向步骤）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(X, parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现前向传播的模型 LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SOFTMAX</span></span><br><span class="line"><span class="string">    上面的显示就是三个线性层，每一层结束以后，实现relu的作用，实现非线性功能，最后三层以后用softmax实现分类</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入训练数据的个数[784, n] 这里的n代表可以一次训练多个数据</span></span><br><span class="line"><span class="string">    parameters -- 包括上面所有的定义参数三个网络中的权重W和偏置项B</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    Z3 -- 最后的一个线性单元输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从参数dict里面取到所有的参数</span></span><br><span class="line">    W1 = parameters[<span class="string">'W1'</span>]</span><br><span class="line">    b1 = parameters[<span class="string">'b1'</span>]</span><br><span class="line">    W2 = parameters[<span class="string">'W2'</span>]</span><br><span class="line">    b2 = parameters[<span class="string">'b2'</span>]</span><br><span class="line">    W3 = parameters[<span class="string">'W3'</span>]</span><br><span class="line">    b3 = parameters[<span class="string">'b3'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前向传播过程</span></span><br><span class="line">    Z1 = tf.add(tf.matmul(W1,X), b1)     <span class="comment"># Z1 = np.dot(W1, X) + b1</span></span><br><span class="line">    A1 = tf.nn.relu(Z1)                  <span class="comment"># A1 = relu(Z1)</span></span><br><span class="line">    Z2 = tf.add(tf.matmul(W2,A1), b2)    <span class="comment"># Z2 = np.dot(W2, a1) + b2</span></span><br><span class="line">    A2 = tf.nn.relu(Z2)                  <span class="comment"># A2 = relu(Z2)</span></span><br><span class="line">    Z3 = tf.add(tf.matmul(W3,A2), b3)    <span class="comment"># Z3 = np.dot(W3,Z2) + b3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试前向传播喊出</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    print(<span class="string">"Z3 = &#123;final_Z&#125;"</span>.format(final_Z=Z3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算损失函数</span></span><br><span class="line"><span class="comment"># 是计算loss的时候了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(Z3, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算cost</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    Z3 -- 前向传播的最终输出（[10, n]）n也是你输入的训练数据个数</span></span><br><span class="line"><span class="string">    Y -- </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    cost - 损失函数 张量（Tensor）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获得预测和准确的label</span></span><br><span class="line">    logits = tf.transpose(Z3)</span><br><span class="line">    labels = tf.transpose(Y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = logits, labels = labels))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试计算损失函数</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    print(<span class="string">"cost = &#123;cost&#125;"</span>.format(cost=cost))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个就是关键了，因为每一层的参数都是通过反向传播来实现权重和偏置项参数更新的</span></span><br><span class="line"><span class="comment"># 总体的原理就是经过前向传播，计算到最后的层，利用softmax加交叉熵，算出网络的损失函数</span></span><br><span class="line"><span class="comment"># 然后对损失函数进行求偏导，利用反向传播算法实现每一层的权重和偏置项的更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(train, test, learning_rate=<span class="number">0.0001</span>, num_epochs=<span class="number">16</span>, minibatch_size=<span class="number">32</span>, print_cost=True, graph_filename=<span class="string">'costs'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现了一个三层的网络结构: LINEAR-&gt;RELU-&gt;LINEAR-&gt;RELU-&gt;LINEAR-&gt;SOFTMAX.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    train -- 训练集</span></span><br><span class="line"><span class="string">    test -- 测试集</span></span><br><span class="line"><span class="string">    learning_rate -- 优化权重时候所用到的学习率</span></span><br><span class="line"><span class="string">    num_epochs -- 训练网络的轮次</span></span><br><span class="line"><span class="string">    minibatch_size -- 每一次送进网络训练的数据个数（也就是其他函数里面那个n参数）</span></span><br><span class="line"><span class="string">    print_cost -- 每一轮结束以后的损失函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    parameters -- 被用来学习的参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保参数不被覆盖重写</span></span><br><span class="line">    tf.reset_default_graph()</span><br><span class="line">    tf.set_random_seed(<span class="number">42</span>)</span><br><span class="line">    seed = <span class="number">42</span></span><br><span class="line">    <span class="comment"># 获取输入和输出大小</span></span><br><span class="line">    (n_x, m) = train.images.T.shape</span><br><span class="line">    n_y = train.labels.T.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    costs = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建输入输出数据的占位符</span></span><br><span class="line">    X, Y = create_placeholders(n_x, n_y)</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行前向传播</span></span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    <span class="comment"># 计算损失函数</span></span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    <span class="comment"># 使用AdamOptimizer优化器实现反向传播算法（最小化cost）</span></span><br><span class="line">    <span class="comment"># 其实我们这个地方的反向更新参数的过程都是tensorflow给做了</span></span><br><span class="line">    optimizer = tf.train.AdamOptimizer(learning_rate).minimize(cost)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 变量初始化器</span></span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始tensorflow的sess 来计算tensorflow构建好的图</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这个就是之前说过的要进行初始化的</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 训练轮次</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">            </span><br><span class="line">            epoch_cost = <span class="number">0.</span></span><br><span class="line">            num_minibatches = int(m / minibatch_size)</span><br><span class="line">            seed = seed + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_minibatches):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获取下一个batch的训练数据和label数据</span></span><br><span class="line">                minibatch_X, minibatch_Y = train.next_batch(minibatch_size)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 执行优化器</span></span><br><span class="line">                _, minibatch_cost = sess.run([optimizer, cost], feed_dict=&#123;X: minibatch_X.T, Y: minibatch_Y.T&#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新每一轮的损失</span></span><br><span class="line">                epoch_cost += minibatch_cost / num_minibatches</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 打印每一轮的损失</span></span><br><span class="line">            <span class="keyword">if</span> print_cost == <span class="keyword">True</span>:</span><br><span class="line">                print(<span class="string">"Cost after epoch &#123;epoch_num&#125;: &#123;cost&#125;"</span>.format(epoch_num=epoch, cost=epoch_cost))</span><br><span class="line">                costs.append(epoch_cost)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用matplot画出损失的变化曲线图</span></span><br><span class="line">        plt.figure(figsize=(<span class="number">16</span>,<span class="number">5</span>))</span><br><span class="line">        plt.plot(np.squeeze(costs), color=<span class="string">'#2A688B'</span>)</span><br><span class="line">        plt.xlim(<span class="number">0</span>, num_epochs<span class="number">-1</span>)</span><br><span class="line">        plt.ylabel(<span class="string">"cost"</span>)</span><br><span class="line">        plt.xlabel(<span class="string">"iterations"</span>)</span><br><span class="line">        plt.title(<span class="string">"learning rate = &#123;rate&#125;"</span>.format(rate=learning_rate))</span><br><span class="line">        plt.savefig(graph_filename, dpi = <span class="number">300</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存参数</span></span><br><span class="line">        parameters = sess.run(parameters)</span><br><span class="line">        print(<span class="string">"Parameters have been trained!"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算预测准率</span></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(Z3), tf.argmax(Y))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算测试准率</span></span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">"float"</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Train Accuracy:"</span>, accuracy.eval(&#123;X: train.images.T, Y: train.labels.T&#125;))</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Test Accuracy:"</span>, accuracy.eval(&#123;X: test.images.T, Y: test.labels.T&#125;))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要开始训练我们的fashion mnist网络了</span></span><br><span class="line">train = fashion_mnist.train <span class="comment"># 训练的数据</span></span><br><span class="line">test = fashion_mnist.test <span class="comment"># 测试的数据</span></span><br><span class="line"></span><br><span class="line">parameters = model(train, test, learning_rate = <span class="number">0.001</span>, num_epochs = <span class="number">16</span>, graph_filename = <span class="string">'fashion_mnist_costs'</span>)</span><br></pre></td></tr></table></figure><ul><li>上面的代码是写好了，这里有一个python的依赖库（matplotlib）需要安装以下，同样的办法，就是进去tensorflow这个环境里面，然后执行<code>pip install matplotlib</code>就可以了。</li><li>在这个过程中，可能从tensorflow下载数据的时候会很慢。（我们选择直接从上面给出下载数据集的github网址，直接下载以后，将数据拷贝在代码所在文件夹的input/data/文件夹里面，总共由四个文件组成）分别是训练数据图片、训练数据label和测试数据图片、测试数据label。这样就可以省去下载数据时候漫长的等待。</li></ul><ol start="3" type="1"><li>上面就是我们使用TensorFlow实现的fashion-mnist的识别，总体根据实验结果来说，从测试集的数据来看，我达到的准确率结果是88.5%，还算可以。后续我们可能使用其他一些现有的网络结构来实现fashion-mnist的识别，看看准确率会不会提高。</li><li>如下是我对上面TensorFLow出现的方法介绍：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">tf.placeholders(</span><br><span class="line">dtype,</span><br><span class="line">shape=<span class="keyword">None</span>,</span><br><span class="line">name=<span class="keyword">None</span></span><br><span class="line">)</span><br><span class="line">从参数上面看到，总共有三个参数：</span><br><span class="line">dtype：在tensor中被喂数据的元素类型</span><br><span class="line">shape: tensor的shape</span><br><span class="line">name：命名</span><br><span class="line">说明一下，这个函数返回的是一个tensor，在TensorFlow里面，tensor是一个很重要的概念，大家务必掌握，也叫张量，比如我们的一个数:就是<span class="number">0</span>-阶张量，也叫标量。一个向量，就是<span class="number">1</span>-阶张量。一个矩阵，就是<span class="number">2</span>-阶张量，后面的就是一直往高维了走，对应的就是多少阶张量。</span><br><span class="line">这个方法，很重要的原因也在于它是定义在Session执行run的时候，在后面填充数据的占位符，也就是feed_dict这个变量里面的数据，所以大家，务必记住这一关键的概念。后续用起来就会很顺手。</span><br><span class="line">tf.get_variable()</span><br><span class="line">这个方法后续在展开来说，你先理解就是使用它可以定义变量（保存权重和偏置项的），还可以加一些优化器，比如说正则优化器等等</span><br><span class="line">tf.matmul(</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">)</span><br><span class="line">展示给你们列出这两个参数：</span><br><span class="line">a：就是待操作的矩阵<span class="number">1</span></span><br><span class="line">b: 就是待操作的矩阵<span class="number">2</span></span><br><span class="line">函数功能就是实现矩阵的相乘运算（当然要符合基本的矩阵运算格式）</span><br><span class="line">tf.transpose(</span><br><span class="line">a,</span><br><span class="line">)</span><br><span class="line">先列出来一个参数，就是矩阵的转置</span><br><span class="line">Session().run(</span><br><span class="line">fetches,</span><br><span class="line">feed_list=<span class="keyword">None</span>,</span><br><span class="line">)</span><br><span class="line">这个方法就是运行图。很关键，先掌握两个参数:</span><br><span class="line">fetches: 你要从图里面取出的数据（）</span><br><span class="line">feed_list: 你要给图喂的数据（输入和label数据就是用这样的方式来做的）</span><br><span class="line">    比如我们训练的网络中输入的图片信息和对应的label信息</span><br><span class="line">tf.reduce_mean(</span><br><span class="line">input_tensor,</span><br><span class="line">axis=<span class="keyword">None</span>,</span><br><span class="line">keepdims=<span class="keyword">None</span>,</span><br><span class="line">name=<span class="keyword">None</span>,</span><br><span class="line">redcution_indices=<span class="keyword">None</span>,</span><br><span class="line">keep_dims=<span class="keyword">None</span></span><br><span class="line">)</span><br><span class="line">计算输入tensor的总和：</span><br><span class="line">input_tensor: 要叠加的tensor</span><br><span class="line">axis: 选择那个维度叠加</span><br><span class="line">keepdims: 叠加元素以后，保留原来的维度信息</span><br><span class="line">name：就是名字</span><br><span class="line">redcution_indices：被axis取代</span><br><span class="line">keep_dims：被keepdims取代</span><br></pre></td></tr></table></figure><p>我们今天的任务量可能有一些大，大家坚持。总的来说就是使用神经网络对实际的一个fashion-mnist数据集进行服装种类的识别，大家主要看看我的代码。有什么不明白的我在代码里面都做出了注释。</p><p>邮箱——air@weaf.top欢迎来探讨</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-初体验fashion-mnist&quot;&gt;TensorFlow 初体验（Fashion-mnist）&lt;/h1&gt;
&lt;ol
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>rsync的使用与配置</title>
    <link href="http://weafteam.github.io/posts/cfc65600/"/>
    <id>http://weafteam.github.io/posts/cfc65600/</id>
    <published>2018-03-25T13:08:56.000Z</published>
    <updated>2018-04-02T14:12:49.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一什么是rsync">一、什么是rsync</h2><p><strong>rsync</strong>，remote synchronize顾名思意就知道它是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。</p><h2 id="二rsync的安装">二、rsync的安装</h2><p>rysnc的官方网站：http://rsync.samba.org 可以从上面得到最新的版本。目前最新版是3.1.2。当然，因为rsync是一款如此有用的软件，所以很多Linux的发行版本都将它收录在内了。</p><a id="more"></a><p>　　软件包安装</p><table><thead><tr class="header"><th>命令</th><th>平台</th></tr></thead><tbody><tr class="odd"><td># sudo apt-get install rsync</td><td>注：在debian、ubuntu 等在线安装方法；</td></tr><tr class="even"><td># yum install rsync</td><td>注：Fedora、Redhat 等在线安装方法；</td></tr><tr class="odd"><td># rpm -ivh rsync</td><td>注：Fedora、Redhat 等rpm包安装方法；</td></tr></tbody></table><p>　　其它Linux发行版，请用相应的软件包管理方法来安装。</p><p>　　源码包安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　tar xvf  rsync-xxx.tar.gz</span><br><span class="line">　　cd rsync-xxx</span><br><span class="line">　　./configure --prefix=/usr  ;make ;make install   注：在用源码</span><br></pre></td></tr></table></figure></p><p>包编译安装之前，您得安装gcc等编译开具才行； 三、rsync的配置 ———– rsync的主要有以下三个配置文件<strong>rsyncd.conf</strong>(主配置文件)、<strong>rsyncd.secrets</strong>(密码文件)、<strong>rsyncd.motd</strong>(rysnc服务器信息) 比如我们要备份服务器上的/home和/opt，在/home中我想把easylife和samba目录排除在外； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">　　# Distributed under the terms of the GNU General Public License v2</span><br><span class="line">　　# Minimal configuration file for rsync daemon</span><br><span class="line">　　# See rsync(1) and rsyncd.conf(5) man pages for help</span><br><span class="line"></span><br><span class="line">　　# This line is required by the /etc/init.d/rsyncd script</span><br><span class="line">　　pid file = /var/run/rsyncd.pid   </span><br><span class="line">　　port = 873</span><br><span class="line">　　address = 192.168.1.171  </span><br><span class="line">　　#uid = nobody </span><br><span class="line">　　#gid = nobody    </span><br><span class="line">　　uid = root   </span><br><span class="line">　　gid = root  </span><br><span class="line"></span><br><span class="line">　　use chroot = yes  </span><br><span class="line">　　read only = yes </span><br><span class="line"></span><br><span class="line">　　#limit access to private LANs</span><br><span class="line">　　hosts allow=192.168.1.0/255.255.255.0 10.0.1.0/255.255.255.0  </span><br><span class="line">　　hosts deny=*</span><br><span class="line"></span><br><span class="line">　　max connections = 5 </span><br><span class="line">　　motd file = /etc/rsyncd.motd</span><br><span class="line"></span><br><span class="line">　　#This will give you a separate log file</span><br><span class="line">　　#log file = /var/log/rsync.log</span><br><span class="line"></span><br><span class="line">　　#This will log every file transferred - up to 85,000+ per user, per sync</span><br><span class="line">　　#transfer logging = yes</span><br><span class="line"></span><br><span class="line">　　log format = %t %a %m %f %b</span><br><span class="line">　　syslog facility = local3</span><br><span class="line">　　timeout = 300</span><br><span class="line"></span><br><span class="line">　　[rhel4home]   </span><br><span class="line">　　path = /home    </span><br><span class="line">　　list=yes </span><br><span class="line">　　ignore errors </span><br><span class="line">　　auth users = root</span><br><span class="line">　　secrets file = /etc/rsyncd.secrets  </span><br><span class="line">　　comment = This is RHEL 4 data  </span><br><span class="line">　　exclude = easylife/  samba/     </span><br><span class="line"></span><br><span class="line">　　[rhel4opt]</span><br><span class="line">　　path = /opt </span><br><span class="line">　　list=no</span><br><span class="line">　　ignore errors</span><br><span class="line">　　comment = This is RHEL 4 opt </span><br><span class="line">　　auth users = easylife</span><br><span class="line">　　secrets file = /etc/rsyncd/rsyncd.secrets</span><br></pre></td></tr></table></figure></p><p>　　注：关于auth users是必须在服务器上存在的真实的系统用户，如果你想用多个用户以,号隔开，比如auth users = easylife,root 　　设定密码文件</p><p>　　密码文件格式很简单，rsyncd.secrets的内容格式为：</p><p>　　用户名:密码</p><p>　　我们在例子中rsyncd.secrets的内容如下类似的；在文档中说，有些系统不支持长密码，自己尝试着设置一下吧。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　easylife:keer</span><br><span class="line">　　root:mike</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　chown root.root rsyncd.secrets 　#修改属主</span><br><span class="line">　　chmod 600 rsyncd.secrets     #修改权限</span><br></pre></td></tr></table></figure><p>　　注：1、将rsyncd.secrets这个密码文件的文件属性设为root拥有, 且权限要设为600, 否则无法备份成功! 出于安全目的，文件的属性必需是只有属主可读。 　　　　2、这里的密码值得注意，为了安全你不能把系统用户的密码写在这里。比如你的系统用户easylife密码是000000，为了安全你可以让rsync中的easylife为keer。这和samba的用户认证的密码原理是差不多的。</p><p>　　设定rsyncd.motd 文件;</p><p>　 　它是定义rysnc服务器信息的，也就是用户登录信息。比如让用户知道这个服务器是谁提供的等；类似ftp服务器登录时，我们所看到的 linuxsir.org ftp ……。 当然这在全局定义变量时，并不是必须的，你可以用#号注掉，或删除；我在这里写了一个 rsyncd.motd的内容为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">　　Welcome to use the mike.org.cn rsync services!</span><br><span class="line">2002------2009</span><br><span class="line">　　++++++++++++++++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure></p><h2 id="四启动rsync服务器">四、启动rsync服务器</h2><p>相当简单，有以下几种方法</p><p>　　A、–daemon参数方式，是让rsync以服务器模式运行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#/usr/bin/rsync --daemon  --config=/etc/rsyncd/rsyncd.conf 　#--config用于指定rsyncd.conf的位置,如果在/etc下可以不写</span><br></pre></td></tr></table></figure></p><p>　　B、xinetd方式 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　修改services加入如下内容</span><br><span class="line">　　# nano -w /etc/services</span><br><span class="line"></span><br><span class="line">　　rsync　　873/tcp　　# rsync </span><br><span class="line">　　rsync　　873/udp　　# rsync</span><br></pre></td></tr></table></figure></p><p>　　这一步一般可以不做，通常都有这两行(我的RHEL4和GENTOO默认都有)。修改的目的是让系统知道873端口对应的服务名为rsync。如没有的话就自行加入。</p><p>　　设定 /etc/xinetd.d/rsync, 简单例子如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　# default: off</span><br><span class="line">　　# description: The rsync server is a good addition to am ftp server, as it \</span><br><span class="line">　　#       allows crc checksumming etc.</span><br><span class="line">　　service rsync</span><br><span class="line">　　&#123;</span><br><span class="line">disable = no</span><br><span class="line">socket_type     = stream</span><br><span class="line">wait            = no</span><br><span class="line">user            = root</span><br><span class="line">server          = /usr/bin/rsync</span><br><span class="line">server_args     = --daemon</span><br><span class="line">log_on_failure  += USERID</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p><p>　　上述, 主要是要打开rsync這個daemon, 一旦有rsync client要连接時, xinetd会把它转介給 rsyncd(port 873)。然后service xinetd restart, 使上述设定生效.</p><p>　　rsync服务器和防火墙</p><p>　　Linux 防火墙是用iptables，所以我们至少在服务器端要让你所定义的rsync 服务器端口通过，客户端上也应该让通过。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　#iptables -A INPUT -p tcp -m state --state NEW  -m tcp --dport 873 -j ACCEPT</span><br><span class="line">　　#iptables -L  查看一下防火墙是不是打开了 873端口</span><br></pre></td></tr></table></figure></p><p>　　如果你不太懂防火墙的配置，可以先service iptables stop 将防火墙关掉。当然在生产环境这是很危险的，做实验才可以这么做哟！</p><h2 id="五通过rsync客户端来同步数据">五、通过rsync客户端来同步数据</h2><h3 id="b1列出rsync-服务器上的所提供的同步内容">B1、列出rsync 服务器上的所提供的同步内容；</h3><p>　　首先：我们看看rsync服务器上提供了哪些可用的数据源</p><p>　　# rsync –list-only root@192.168.145.5:: 　　++++++++++++++++++++++++++++++++++++++++++++++ 　　Welcome to use the mike.org.cn rsync services! 　　 2002——2009 　　++++++++++++++++++++++++++++++++++++++++++++++</p><p>　　rhel4home This is RHEL 4 data</p><p>　 　注：前面是rsync所提供的数据源，也就是我们在rsyncd.conf中所写的[rhel4home]模块。而“This is RHEL 4 data”是由[rhel4home]模块中的 comment = This is RHEL 4 data 提供的；为什么没有把rhel4opt数据源列出来呢？因为我们在[rhel4opt]中已经把list=no了。</p><p>　　$ rsync –list-only root@192.168.145.5::rhel4home</p><p>　　++++++++++++++++++++++++++++++++++++++++++++++ 　　Welcome to use the mike.org.cn rsync services! 　　 2002——2009 　　++++++++++++++++++++++++++++++++++++++++++++++</p><p>　　Password: 　　drwxr-xr-x 4096 2009/03/15 21:33:13 . 　　-rw-r–r– 1018 2009/03/02 02:33:41 ks.cfg 　　-rwxr-xr-x 21288 2009/03/15 21:33:13 wgetpaste 　　drwxrwxr-x 4096 2008/10/28 21:04:05 cvsroot 　　drwx—— 4096 2008/11/30 16:30:58 easylife 　　drwsr-sr-x 4096 2008/09/20 22:18:05 giddir 　　drwx—— 4096 2008/09/29 14:18:46 quser1 　　drwx—— 4096 2008/09/27 14:38:12 quser2 　　drwx—— 4096 2008/11/14 06:10:19 test 　　drwx—— 4096 2008/09/22 16:50:37 vbird1 　　drwx—— 4096 2008/09/19 15:28:45 vbird2</p><p>　　后面的root@ip中，root是指定密码文件中的用户名，之后的::rhel4home这是rhel4home模块名 ### B2、rsync客户端同步数据；</p><p>　　#rsync -avzP root@192.168.145.5::rhel4home rhel4home 　　Password: 这里要输入root的密码，是服务器端rsyncd.secrets提供的。在前面的例子中我们用的是mike，输入的密码并不回显，输好就回车。</p><p>　 　注： 这个命令的意思就是说，用root用户登录到服务器上，把rhel4home数据，同步到本地当前目录rhel4home上。当然本地的目录是可以你自己 定义的。如果当你在客户端上当前操作的目录下没有rhel4home这个目录时，系统会自动为你创建一个；当存在rhel4home这个目录中，你要注意 它的写权限。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#rsync -avzP  --delete linuxsir@linuxsir.org::rhel4home   rhel4home</span><br></pre></td></tr></table></figure></p><p>　 　这回我们引入一个–delete 选项，表示客户端上的数据要与服务器端完全一致，如果 linuxsirhome目录中有服务器上不存在的文件，则删除。最终目的是让linuxsirhome目录上的数据完全与服务器上保持一致；用的时候要 小心点，最好不要把已经有重要数所据的目录，当做本地更新目录，否则会把你的数据全部删除；</p><p>　　設定 rsync client</p><p>　　设定密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#rsync -avzP  --delete  --password-file=rsyncd.secrets   root@192.168.145.5::rhel4home rhel4home</span><br></pre></td></tr></table></figure></p><p>　　这次我们加了一个选项 –password-file=rsyncd.secrets，这是当我们以root用户登录rsync服务器同步数据时，密码将读取rsyncd.secrets这个文件。这个文件内容只是root用户的密码。我们要如下做；</p><p>　　# touch rsyncd.secrets 　　# chmod 600 rsyncd.secrets 　　# echo “mike”&gt; rsyncd.secrets</p><p>　　# rsync -avzP –delete –password-file=rsyncd.secrets root@192.168.145.5::rhel4home rhel4home</p><p>　　注：这里需要注意的是这份密码文件权限属性要设得只有属主可读。</p><p>　　　　这样就不需要密码了；其实这是比较重要的，因为服务器通过crond 计划任务还是有必要的； ### B3、让rsync客户端自动与服务器同步数据</p><p>　 　服务器是重量级应用，所以数据的网络备份还是极为重要的。我们可以在生产型服务器上配置好rsync 服务器。我们可以把一台装有rysnc机器当做是备份服务器。让这台备份服务器，每天在早上4点开始同步服务器上的数据；并且每个备份都是完整备份。有时 硬盘坏掉，或者服务器数据被删除，完整备份还是相当重要的。这种备份相当于每天为服务器的数据做一个镜像，当生产型服务器发生事故时，我们可以轻松恢复数 据，能把数据损失降到最低；是不是这么回事？？</p><p>　　step1：创建同步脚本和密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　#mkdir   /etc/cron.daily.rsync</span><br><span class="line">　　#cd  /etc/cron.daily.rsync </span><br><span class="line">　　#touch rhel4home.sh  rhel4opt.sh </span><br><span class="line">　　#chmod 755 /etc/cron.daily.rsync/*.sh  </span><br><span class="line">　　#mkdir /etc/rsyncd/</span><br><span class="line">　　#touch /etc/rsyncd/rsyncrhel4root.secrets</span><br><span class="line">　　#touch /etc/rsyncd/rsyncrhel4easylife.secrets</span><br><span class="line">　　#chmod 600  /etc/rsyncd/rsync.*</span><br></pre></td></tr></table></figure></p><p>　 　注： 我们在 /etc/cron.daily/中创建了两个文件rhel4home.sh和rhel4opt.sh ，并且是权限是755的。创建了两个密码文件root用户用的是rsyncrhel4root.secrets ，easylife用户用的是 rsyncrhel4easylife.secrets，权限是600；</p><p>　　我们编辑rhel4home.sh，内容是如下的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　#!/bin/sh</span><br><span class="line">　　#backup 192.168.145.5:/home </span><br><span class="line">　　/usr/bin/rsync   -avzP  --password-file=/etc/rsyncd/rsyncrhel4root.secrets    root@192.168.145.5::rhel4home   /home/rhel4homebak/$(date +&apos;%m-%d-%y&apos;)</span><br></pre></td></tr></table></figure></p><p>　　我们编辑 rhel4opt.sh ，内容是： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　#!/bin/sh</span><br><span class="line">　　#backup 192.168.145.5:/opt </span><br><span class="line">　　/usr/bin/rsync   -avzP  --password-file=/etc/rsyncd/rsyncrhel4easylife.secrets    easylife@192.168.145.5::rhel4opt   /home/rhel4hoptbak/$(date +&apos;%m-%d-%y&apos;)</span><br></pre></td></tr></table></figure></p><p>　　注：你可以把rhel4home.sh和rhel4opt.sh的内容合并到一个文件中，比如都写到rhel4bak.sh中；</p><p>　　接着我们修改 /etc/rsyncd/rsyncrhel4root.secrets和rsyncrhel4easylife.secrets的内容； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　# echo &quot;mike&quot; &gt; /etc/rsyncd/rsyncrhel4root.secrets</span><br><span class="line">　　# echo &quot;keer&quot;&gt; /etc/rsyncd/rsyncrhel4easylife.secrets</span><br></pre></td></tr></table></figure></p><p>　 　然后我们再/home目录下创建rhel4homebak 和rhel4optbak两个目录，意思是服务器端的rhel4home数据同步到备份服务器上的/home/rhel4homebak 下，rhel4opt数据同步到 /home/rhel4optbak/目录下。并按年月日归档创建目录；每天备份都存档； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　#mkdir /home/rhel4homebak</span><br><span class="line">　　#mkdir /home/rhel4optbak</span><br></pre></td></tr></table></figure></p><p>　　step2：修改crond服务器的配置文件 加入到计划任务 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#crontab  -e</span><br></pre></td></tr></table></figure></p><p>　　加入下面的内容：</p><p>　　# Run daily cron jobs at 4:10 every day backup rhel4 data:<br>　　10 4 * * * /usr/bin/run-parts /etc/cron.daily.rsync 1&gt; /dev/null</p><p>　　注：第一行是注释，是说明内容，这样能自己记住。 　　　　第二行表示在每天早上4点10分的时候，运行 /etc/cron.daily.rsync 下的可执行脚本任务； 　　　　 　　配置好后，要重启crond 服务器； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　# killall crond    注：杀死crond 服务器的进程；</span><br><span class="line">　　# ps aux |grep crond  注：查看一下是否被杀死；</span><br><span class="line">　　# /usr/sbin/crond    注：启动 crond 服务器；</span><br><span class="line">　　# ps aux  |grep crond  注：查看一下是否启动了？</span><br><span class="line">　　root      3815  0.0  0.0   1860   664 ?        S    14:44   0:00 /usr/sbin/crond</span><br><span class="line">　　root      3819  0.0  0.0   2188   808 pts/1    S+   14:45   0:00 grep crond</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      rsync的使用与配置
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>文本聚类系列教程：（二）jieba中文分词工具进阶</title>
    <link href="http://weafteam.github.io/posts/931939a5/"/>
    <id>http://weafteam.github.io/posts/931939a5/</id>
    <published>2018-03-19T11:57:19.000Z</published>
    <updated>2018-04-02T14:12:49.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jieba中文分词工具使用进阶篇，废话不多说吗，我们开始本次的学习吧~</p></blockquote><hr><h1 id="如何让分词的更加准确">如何让分词的更加准确</h1><p>我们之前举得例子有些文本其实很简单，我们后来确实换了官方的测试文本《围城》，但是均没避免一个问题，这些测试例都十分地中规中矩。在实际中需要我们做分词的文本可能是多种多样的，这时候的切词有可能会不太特别理想，导致分词的不准确。</p><p>那我们不妨下一个别的电子书（这里我下载的是《斗破苍穹》，为了测试我只用了第一章的文本），然后再进行切词，看下是否存在这样的问题。这里我们稍微改改上次的去停用词的代码，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) <span class="comment"># 获取当前文件的dir路径</span></span><br><span class="line"></span><br><span class="line">text_path = <span class="string">'txt/chapter2.txt'</span> <span class="comment">#《斗破苍穹》第一章的文本路径</span></span><br><span class="line">text = open(path.join(d, text_path),<span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CutWords</span><span class="params">(text)</span>:</span></span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=<span class="keyword">False</span>)</span><br><span class="line">    liststr=<span class="string">"/ "</span>.join(seg_list) <span class="comment"># 添加切分符</span></span><br><span class="line">    <span class="keyword">for</span> myword <span class="keyword">in</span> liststr.split(<span class="string">'/'</span>):</span><br><span class="line">        <span class="keyword">if</span> len(myword.strip())&gt;<span class="number">1</span>:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(mywordlist) <span class="comment">#返回一个字符串</span></span><br><span class="line"></span><br><span class="line">txt5 = CutWords(text)</span><br><span class="line">text_write = <span class="string">'txt/5.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(text_write,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(txt5)</span><br><span class="line">    print(<span class="string">"Success"</span>)</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/20/5ab12557a30b9.png" alt="result_cutwords.png"></p><p>终于被我们找到了一个切词错误，原文是这样的：</p><p>萧媚脑中忽然浮现出三年前那意气风发的少年</p><p>按照我们正常的断句，应为：</p><p>萧媚/脑中/忽然/浮现….，而jieba却认为“萧媚脑”是一个单词，从而导致此处分词不理想。</p><p>jieba考虑了这种情况，而且有很多的应对方案，下面我们先说最简单的。</p><h1 id="调整词典">调整词典</h1><h2 id="方法1动态修改词典">方法1：动态修改词典</h2><p>使用add_word(word,freq=None,tag=None)和del_word(word)可在程序中动态的修改词典，具体操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) <span class="comment"># 获取当前文件的dir路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处增加代码</span></span><br><span class="line">jieba.add_word(<span class="string">'脑中'</span>)</span><br><span class="line"></span><br><span class="line">  ····</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/22/5ab3a2f27d481.png" alt="add_word_test.png"></p><p>果然，这样的方法很直接的把我们原来切错的词变成了正确的词。与add_word()相对应的是delete_word()方法，根据字面意思我们也很容易理解delete_word()方法的作用，这里我就不做过多的演示了，大家在实际场景中直接运用就好了。</p><h2 id="方法2调节词频">方法2：调节词频</h2><p>使用suggest_freq(segment, tune=True)调节单个词语的词频，使得它更容易被分出来，或者不被分出来。</p><p>但是需要注意的是：<strong>自动计算的词频在使用 HMM 新词发现功能时可能无效。</strong></p><p>所以此时我们在做切词的时候需要把是HMM置为False。我们看下官方给的Demo（如果关闭HMM，很多新发现的词都消失了，所以‘萧媚脑’也消失了，无法做测试，我们的例子也是为了方便大家理解，所以也没必要非得针对这一个词做词频调节），具体的做法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到post中将出错。'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">jieba.suggest_freq((<span class="string">'中'</span>, <span class="string">'将'</span>), <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到post中将出错。'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'「台中」正确应该不会被切开'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">jieba.suggest_freq(<span class="string">'台中'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'「台中」正确应该不会被切开'</span>, HMM=<span class="keyword">False</span>)))</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/22/5ab3b191d1bfd.png" alt="suggest_freq.png"></p><p>对比下结果，不难发现suggest_freq()的使用方法，通过这样的强调高频词和低频词的方法可以做到分词更准确。</p><h1 id="添加自定义词典">添加自定义词典</h1><p>比起默认的词典，我们自定义的词典更适合我们自己的文本，这一点是毋庸置疑的。</p><p>词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。</p><p>这里我们的词典为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">云计算 5</span><br><span class="line">李小福 2 nr</span><br><span class="line">创新办 3 i</span><br><span class="line">easy_install 3 eng</span><br><span class="line">好用 300</span><br><span class="line">韩玉赏鉴 3 nz</span><br><span class="line">八一双鹿 3 nz</span><br><span class="line">台中</span><br><span class="line">凱特琳 nz</span><br><span class="line">Edu Trust认证 2000</span><br></pre></td></tr></table></figure><p>我们这个例子也用官方的Demo，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"../"</span>)</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.load_userdict(<span class="string">"userdict.txt"</span>)</span><br><span class="line"><span class="comment"># jieba在0.28版本之后采用延迟加载方式</span></span><br><span class="line"><span class="comment"># “import jieba”不会立即触发词典的加载，而是在有必要的时候才会加载词典</span></span><br><span class="line"><span class="comment"># 如果想手动加载，可执行代码： jieba.initialize() 进行手动初始化操作</span></span><br><span class="line"><span class="comment"># 也正是有了延迟加载机制，我们现在可以改变主词典的路径：</span></span><br><span class="line"><span class="comment"># jieba.set_dictionary('data/dict.txt.big')</span></span><br><span class="line"><span class="comment"># 官方还提供了占用内存较小的词典和适用于繁体字的词典，均在官方的GitHub上，有需要的可以自行下载。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line"><span class="comment"># pseg切分可以显示词性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下三个操作是修改词典的巩固</span></span><br><span class="line">jieba.add_word(<span class="string">'石墨烯'</span>)</span><br><span class="line">jieba.add_word(<span class="string">'凱特琳'</span>)</span><br><span class="line">jieba.del_word(<span class="string">'自定义词'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_sent = (</span><br><span class="line"><span class="string">"李小福是创新办主任也是云计算方面的专家; 什么是八一双鹿\n"</span></span><br><span class="line"><span class="string">"例如我输入一个带“韩玉赏鉴”的标题，在自定义词库中也增加了此词为N类\n"</span></span><br><span class="line"><span class="string">"「台中」正確應該不會被切開。mac上可分出「石墨烯」；此時又可以分出來凱特琳了。"</span></span><br><span class="line">)</span><br><span class="line">words = jieba.cut(test_sent)</span><br><span class="line">print(<span class="string">'/'</span>.join(words))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"="</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">result = pseg.cut(test_sent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> result:</span><br><span class="line">    print(w.word, <span class="string">"/"</span>, w.flag, <span class="string">", "</span>, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/23/5ab46d77c08dc.png" alt="userdict.png"></p><p>像‘云计算’、‘创新办’等词在没加载词典的时候是不能被识别出来的。像‘石墨烯’等在没有add_word()的时候也是不能识别出来的。可见效果还是不错的。</p><h1 id="并行分词">并行分词</h1><p>原理：将目标文本按行分隔后，把各行文本分配到多个 Python 进程并行分词，然后归并结果，从而获得分词速度的可观提升</p><p>但是令人遗憾的是，这个模块并不支持Windows平台，原因是因为jieba的该模块是基于python自带的 multiprocessing 模块，而这个模块并不支持Windows。这里我就贴一下用法，使用Linux系统的同学可以自行体验下这个可观的速度提升。</p><p><strong>用法：</strong></p><ul><li>jieba.enable_parallel(4) # 开启并行分词模式，参数为并行进程数</li><li>jieba.disable_parallel() # 关闭并行分词模式</li></ul><h1 id="最后">最后</h1><p>以上所讲的内容在日常的使用中应该是够用了，当然像基于TextRank算法的关键词抽取等内容，我这里并没涉及，并不是因为不重要，而是我对这个算法还不是很了解，硬着头皮写肯定也是照本宣科，效果肯定很差，所以先挖个坑吧，以后再填。</p><p>感谢阅读~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;jieba中文分词工具使用进阶篇，废话不多说吗，我们开始本次的学习吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1
        
      
    
    </summary>
    
      <category term="文本聚类" scheme="http://weafteam.github.io/categories/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="文本聚类" scheme="http://weafteam.github.io/tags/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>普通的 SQLAlchemy ORM 使用姿势</title>
    <link href="http://weafteam.github.io/posts/39277c31/"/>
    <id>http://weafteam.github.io/posts/39277c31/</id>
    <published>2018-03-18T13:38:54.000Z</published>
    <updated>2018-04-02T14:12:49.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>SQLAlchemy 是 Python 世界中最常用的 SQL 工具之一，包含 SQL 渲染引擎和 ORM 两大部分，平时使用最多的就是 ORM。在我看来平时很多使用 ORM 的姿势是有问题的，或者说是不优雅的。所以这篇文章打算讲讲（搬运）其中一些普通的姿势和技巧（API 文档）。</p><h2 id="property-和混合属性">property 和混合属性</h2><h3 id="property">property</h3><p>下面是一个简单的用户表映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    password = Column(String(<span class="number">128</span>))</span><br></pre></td></tr></table></figure><p>通常情况下，我们会加密用户的密码，在数据库中保存密文，但是这里有一个问题，我们得这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">user = User(name=<span class="string">'zhang'</span>, password=encrypt(<span class="string">'123456'</span>))</span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">user.password = encrypt(<span class="string">'654321'</span>)</span><br></pre></td></tr></table></figure><p>这意味着我们需要不断的重复书写 <code>encrypt</code> 函数来保证加密了用户密码。</p><p>有没有什么方法能省去这一步呢？答案是 <code>property</code>。</p><p>现在把用户表映射改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    _password = Column(String(<span class="number">128</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'write only!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @password.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._password = encrypt(value)</span><br></pre></td></tr></table></figure><p>现在只需要简单的写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">user = User(name=<span class="string">'zhang'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">user.password = <span class="string">'654321'</span></span><br></pre></td></tr></table></figure><p>就可以了。</p><p>关于 Python 中 <code>property</code>和描述符的使用值得再另写一篇文章描述，在这里就不详细说明了。</p><h3 id="混合属性hybrid_property">混合属性（hybrid_property）</h3><p>上面的例子看上去让代码清爽了不少，但是有时候这种用法是无法满足需要的，譬如下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    birthday = Column(DateTime)</span><br></pre></td></tr></table></figure><p>这是一个学生表映射，增加了 <code>birthday</code> 字段。通常我们会保存用户的生日，再通过生日获取用户年龄。有了上面的例子，很容易写出获取年龄的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br></pre></td></tr></table></figure><p>现在可以简单的使用 <code>student.age</code> 获取具体的生日。</p><p>这样做是有缺陷的：如果需要获取所有 18 岁的学生呢？我们希望可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter_by(age=<span class="number">18</span>).all()</span><br></pre></td></tr></table></figure><p>但是却没有任何结果返回。如果改成这样呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now = datetime.now()</span><br><span class="line">start = datetime(now.year - <span class="number">18</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end = end = datetime(now.year + <span class="number">1</span> - <span class="number">18</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">session.query(Student).filter(Student.birthday &gt;= start, Student.birthday &lt; end).all()</span><br></pre></td></tr></table></figure><p>这样倒是可以获取正确的结果了，但是也太丑了点吧？难道没办法写出像第一条一样的既清晰又简洁的查询么？</p><p>答案自然是有的，SQLAlchemy 提供了混合属性（<code>hybrid_property</code>）来处理类似的情况，于是我们可以改写获取年龄的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.hybrid <span class="keyword">import</span> hybrid_property</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @hybrid_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.expression</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - func.year(self.birthday)</span><br></pre></td></tr></table></figure><p>这里将原本的 <code>property</code> 替换为 SQLAlchemy 中的 <code>hybrid_property</code>，同时提供了一个 <code>expression</code> 装饰器，在被装饰的方法中把 Python 代码翻译成 SQL（代码示例的目标数据库为 MySQL，获取日期中的年份的函数为<code>YEAR()</code>，使用其他数据库请查阅对应数据库的相关文档）。有了这个方法，SQLAlchemy 就知道如何在 SQL 语句中处理 <code>age</code> 属性了。</p><p>接下来稍微提一下 <code>hybrid_method</code>。</p><p>和 <code>hybrid_property</code> 类似，只不过可以给 <code>hybrid_method</code> 传参数。下面这个例子不太合适，只为了展示<code>hybrid_method</code> 的功能。</p><p>如何找到所有 90 后同学？当然我们可以复用上面的 <code>age</code> 属性，先计算一下 90 后的同学现在多少岁，然后直接写在查询里就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter(Student.age &gt;= now.year - <span class="number">1990</span>, Student.age &lt; now.year - <span class="number">2000</span>).all()</span><br></pre></td></tr></table></figure><p>如果要判断某个学生是否是 90 后呢？又需要再写一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> now.year - <span class="number">2000</span> &gt; student.age &gt;= now.year - <span class="number">1990</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>出现了很多不直观的代码，这时候可以使用 <code>hybrid_method</code> 简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @hybrid_method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">born_after</span><span class="params">(self, years)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> years + <span class="number">10</span> &gt; self.birthday.year &gt;= years</span><br><span class="line"></span><br><span class="line"><span class="meta">    @born_after.expression</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">born_after</span><span class="params">(self, years)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> and_(func.year(self.birthday) &lt; years + <span class="number">10</span>, func.year(self.birthday) &gt;= years)</span><br></pre></td></tr></table></figure><p>于是现在可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter(Student.born_after(<span class="number">1990</span>)).all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> student.born_after(<span class="number">1990</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>看上去好了一些（误</p><p>这一部分就到此为止，当然 hybrid 在 SQLAlchemy 中的用法不止上述这些，更详细和复杂的内容参见官方文档。</p><h2 id="关联代理association_proxy">关联代理（association_proxy）</h2><h3 id="简化标量集合">简化标量集合</h3><p>关联代理用在有关联的表中，所以我们先创建如下映射关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">association = Table(<span class="string">'association'</span>, Base.metadata,</span><br><span class="line">                    Column(<span class="string">'blog_id'</span>, Integer, ForeignKey(<span class="string">'blog.id'</span>), primary_key=<span class="keyword">True</span>),</span><br><span class="line">                    Column(<span class="string">'tag_id'</span>, Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'blog'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    tags = relationship(</span><br><span class="line">        <span class="string">'Tag'</span>, secondary=association, backref=backref(<span class="string">'blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'dynamic'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'tag'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p>一个经常被拿出来作为演示的 Many-To-Many 模型。</p><p>先填充一些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: blog = Blog(name=<span class="string">'first'</span>)</span><br><span class="line">In [<span class="number">2</span>]: blog.tags.append(Tag(name=<span class="string">'t1'</span>))</span><br><span class="line">In [<span class="number">3</span>]: blog.tags.append(Tag(name=<span class="string">'t2'</span>))</span><br><span class="line">In [<span class="number">4</span>]: session.add(blog)</span><br><span class="line">In [<span class="number">5</span>]: session.commit()</span><br></pre></td></tr></table></figure><p>接下来就可以获取这些对象的所有信息了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: blog.tags.all()</span><br><span class="line">Out[<span class="number">4</span>]: [&lt;Tag at <span class="number">0x1fdbab6f198</span>&gt;, &lt;Tag at <span class="number">0x1fdbab6f208</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: blog.tags.all()[<span class="number">0</span>].name</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'t1'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: [t.name <span class="keyword">for</span> t <span class="keyword">in</span> blog.tags]</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br></pre></td></tr></table></figure><p>上面的操作有点复杂。对我们而言，<code>Tag</code> 对象只有 <code>name</code> 字段是有用的，为了获取 <code>name</code> 字段，我们要写很多额外的代码把 <code>name</code> 字段从 <code>Tag</code> 对象中剥离出来。<code>association_proxy</code> 就可以用来简化这个操作。</p><p>现在修改一下上面的 <code>Blog</code> 映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.associationproxy <span class="keyword">import</span> association_proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tag_objects = relationship(</span><br><span class="line">        <span class="string">'Tag'</span>, secondary=association, backref=backref(<span class="string">'blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'dynamic'</span>)</span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>)</span><br></pre></td></tr></table></figure><p>增加了一行 <code>association_proxy</code> 对象的声明，现在我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: blog.tags</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br></pre></td></tr></table></figure><p>现在查询操作变得很简单了，但是新增标签的操作还是很麻烦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.tag_objects.append(Tag(name=<span class="string">'t3'</span>))</span><br></pre></td></tr></table></figure><p>还是需要实例化一个 <code>Tag</code> 对象，能不能直接写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.tags.append(<span class="string">'t4'</span>)</span><br></pre></td></tr></table></figure><p>当然是可以的，只要再修改一下 <code>association_proxy</code> 的声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>, creator=<span class="keyword">lambda</span> name: Tag(name=name))</span><br></pre></td></tr></table></figure><p>参数 <code>creator</code> 接受一个可调用对象，它告诉 <code>association_proxy</code> 如何处理“新增”操作。</p><p><strong>注意</strong>：<code>creator</code> 的默认参数是被代理对象的构造函数，如果提供了一个单参数的构造函数，那么可以省略 <code>creator</code> 参数。</p><h3 id="简化关联对象">简化关联对象</h3><p>上面的例子里把 <code>association</code> 表作为一个普通的 <code>Table</code> 对象，是因为 <code>association</code> 中不需要保存额外信息，只需要作为 <code>Blog</code> 和 <code>Tag</code> 的中转。现在有了新的需求，我们需要知道每篇博客的标签是在什么时候加上的，这就需要在 <code>association</code> 表中增加一个额外的字段用来表示创建时间，同时为了获取这个时间，还要把 <code>association</code> 改造成一个真正的映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Association</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'association'</span></span><br><span class="line"></span><br><span class="line">    blog_id = Column(Integer, ForeignKey(<span class="string">'blog.id'</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">    tag_id = Column(Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">    created_at = Column(DateTime, default=datetime.now)</span><br><span class="line"></span><br><span class="line">    blog = relationship(<span class="string">'Blog'</span>, backref=backref(<span class="string">'blog_tags'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line">    tag = relationship(<span class="string">'Tag'</span>, backref=backref(<span class="string">'tag_blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'tag'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'blog'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p>这里实际上是把 Many-To-Many 拆成了两个 One-To-Many。</p><p>然后构造一些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In  [<span class="number">1</span>]: blog = Blog(name=<span class="string">'first'</span>)</span><br><span class="line">    ...: tags = [Tag(name=<span class="string">'t1'</span>), Tag(name=<span class="string">'t2'</span>)]</span><br><span class="line">    ...: <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">    ...:     session.add(Association(blog=blog, tag=tag))</span><br><span class="line">    ...: session.add(blog)</span><br><span class="line">    ...: session.add_all(tags)</span><br><span class="line">    ...: session.commit()</span><br></pre></td></tr></table></figure><p>现在就可以获取 <code>Tag</code> 和被添加的时间了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: blog.blog_tags[<span class="number">0</span>].tag.name</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'t1'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: blog.blog_tags[<span class="number">0</span>].created_at</span><br><span class="line">Out[<span class="number">3</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>可以看到，给 <code>Blog</code> 增加标签要经过 <code>Association</code> 这个中间对象。虽然表结构的确如此，但是我们仍然希望 <code>Association</code> 表是透明的，仅当需要获取其中的创建时间时才明确获取 <code>Association</code> 对象。只需要在 <code>Blog</code> 中声明一个关联代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tags = association_proxy(<span class="string">'blog_tags'</span>, <span class="string">'tag'</span>, creator=<span class="keyword">lambda</span> tag: Association(tag=tag))</span><br></pre></td></tr></table></figure><p>然后就可以这样写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: blog.tags[<span class="number">0</span>].name</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'t1'</span></span><br></pre></td></tr></table></figure><p>添加新的 <code>Tag</code> 也方便了很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In  [<span class="number">3</span>]: <span class="keyword">for</span> tag <span class="keyword">in</span> [Tag(name=<span class="string">'t3'</span>), Tag(name=<span class="string">'t4'</span>)]:</span><br><span class="line">    ...:     blog.tags.append(tag)</span><br></pre></td></tr></table></figure><h3 id="混合关联代理">混合关联代理</h3><p>现在回到了第一个问题的出发点，能不能在上一个例子的基础上简化 <code>tags</code> 的调用呢？同样没问题，只要在 <code>Association</code> 中加一个关联代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Association</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tag_objects = relationship(<span class="string">'Tag'</span>, backref=backref(<span class="string">'tag_blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>, creator=<span class="keyword">lambda</span> name: Tag(name=name))</span><br></pre></td></tr></table></figure><p>然后用起来就和第一个例子一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: blog.tags</span><br><span class="line">Out[<span class="number">1</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: blog.tags.append(<span class="string">'t3'</span>)</span><br><span class="line">In [<span class="number">3</span>]: blog.tags</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>, <span class="string">'t3'</span>]</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>上述内容并没有很复杂的操作，都是一些易于实现并且可以改善日常使用体验的方法。SQLAlchemy 还有很多骚操作可以讲，但是受限于本人的姿势水平，很多并没有实际使用过，也谈不上有什么见解。那就这样吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;SQLAlchemy 是 Python 世界中最常用的 SQL 工具之一，包含 SQL 渲染引擎和 ORM 两大部分，平时使用最多的就是 ORM。在我看来平时很多使用 ORM
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本聚类系列教程：（一）jieba中文分词工具入门</title>
    <link href="http://weafteam.github.io/posts/575e441b/"/>
    <id>http://weafteam.github.io/posts/575e441b/</id>
    <published>2018-03-17T09:20:22.000Z</published>
    <updated>2018-04-02T14:12:49.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习文本分类（聚类）的相关知识，所以接下来准备先写一个关于这个方面的系列博客。</p></blockquote><hr><h1 id="写在前面">写在前面：</h1><p>先介绍下由我们四个人组成的组织：FOUR ELEMENTS。四元素分别对应WELL、EARTH、AIR、FLAME，根据首字母缩写，我们的博客主页得名WEAF。</p><p>接下来介绍下我自己，我叫Leno，对应于四元素里面的Well，目前研究生在读，方向为智能信息处理。我的博客主要会以日常遇到的问题以及学习的知识为主。</p><hr><h1 id="简单的介绍">简单的介绍：</h1><p>首先，我们要做的是对中文文本的聚类，如果做聚类的话，我们需要对文本的内容做分析，而分析的最小单位肯定是词。</p><p>其次，中文和英文的词是有区别的，最大的区别就是中文的词与词之间并不是用空格分隔开的，而且由于中国文化的博大精深，切词的时候我们需要考虑的词语组合情况就更多了。显然让我们自己去造一个这样的轮子有点不现实，其实像这样的工具，前辈们已经为我们做好了，而且超好用。</p><p>本文介绍的就是jieba中文分词，正如它的口号那样。如下图所示： <img src="https://i.loli.net/2018/03/17/5aace9320fbc3.png" alt="jieba.png"></p><p>当然，这里有两本秘籍<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">GitHub</a> &amp;&amp; <a href="http://www.oschina.net/p/jieba" target="_blank" rel="noopener">OSChina</a>，既然你我有缘，便免费赠予你。</p><hr><h1 id="安装">安装</h1><p>这年头，没有什么是一句pip install 解决不了的。不管2或者3，直接pip即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure><hr><h1 id="结合官方demo理解jieba的三种切词模式">结合官方Demo理解jieba的三种切词模式</h1><p><strong>三种模式：</strong></p><ul><li>精确模式（默认模式）：它会试图将句子最精确的切开，适合文本分析。</li><li>全模式：不考虑歧义，这个模式会将所有的可以成词的词语都扫描出来，因而速度会非常快。</li><li>搜索引擎模式：该模式是在精确模式的基础上，对长词再进行切分，提高召回率，适用于搜索引擎分词。</li></ul><p><strong>官方Demo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;我来到北京清华大学&quot;, cut_all=True)</span><br><span class="line">print(&quot;全模式: &quot; + &quot;/ &quot;.join(seg_list))  # 全模式</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;我来到北京清华大学&quot;, cut_all=False)</span><br><span class="line">print(&quot;精确模式: &quot; + &quot;/ &quot;.join(seg_list))  # 精确模式</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;)  # 默认是精确模式</span><br><span class="line">print(&quot;默认模式：&quot; + &quot;/ &quot;.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut_for_search(&quot;小明硕士毕业于中国科学院计算所，后在日本京都大学深造&quot;)  # 搜索引擎模式</span><br><span class="line">print(&quot;搜索引擎模式：&quot; + &quot;/ &quot;.join(seg_list))</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/17/5aacfab51d67e.png" alt="Demo1.png"></p><p><strong>模式分析：</strong></p><p>这里我们先分析这三种模式，对于cut方法的讲解在后边会给出，so不要问我为啥不给出cut方法中第三个参数HMM。</p><p>通过对比前两条输出可以看出全模式情况下，它会找出所有可以组成词的划分，而精确模式与其对比给出的答案就会很清爽。所以结合上文所说，不难理解这两个模式的区别。</p><p>接下来我们看第四条输出，它是在精确模式的基础上对长词再做的划分。所以‘日本京都大学’，它会再次切分为‘日本’，‘京都’，‘大学’三个词，同理适用于‘中国科学院’。所以这个模式也不难理解吧。</p><p><strong>补充分析：</strong></p><p>最后看第三条输出内容，也许你会问，既然知道默认模式是精确模式了，为啥还要给出试例，况且还是一个不具有对比性质的对比。这里其实想说明的是：</p><p>‘杭研’并没有在词典中，但是jieba的Viterbi算法也将其识别了出来。</p><p>这时我们就需要考虑HMM这个参数了，关于HMM（Hidden Markov Model，HMM：隐马尔可夫模型），如果深究，那就需要另外一篇博文了，所以我们只要能理解官方给出的这句话即可：<strong>对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法。</strong></p><p>可能说的比较干涩，我们实际测一下吧。</p><p><strong>补充测试代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;,HMM=False)</span><br><span class="line">print(&quot;HMM为False：&quot; + &quot;/ &quot;.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;,HMM=True)</span><br><span class="line">print(&quot;HMM为True：&quot; + &quot;/ &quot;.join(seg_list))</span><br></pre></td></tr></table></figure><p><strong>补充测试结果：</strong></p><p><img src="https://i.loli.net/2018/03/17/5aad1051896b9.png" alt="Demo1plus.png"></p><p>所以<strong>一般情况下</strong>，使用cut方法，不用考虑HMM这个参数就可以，让它默认为True即可，让Viterbi算法为我们识别新词。HMM也能有效的解决中文中的歧义问题。</p><p><strong>启用HMM并不适用所有情况，根据需要开启！！！</strong></p><p>关于切词的方法以及切词的注意事项，请大家参考上文给出的两个链接，这里我不再赘述。</p><hr><h1 id="基于tf-idf的关键词提取">基于TF-IDF的关键词提取</h1><p><strong>相关知识：</strong></p><p>对于一个文档，我们肯定不会对所有的词进行聚类，所以我们需要对文档进行关键词提取。</p><p>下面我们对TF-IDF做一下简单的说明。如果单讲这个知识点，拿出来又是一篇博文。不过后续我也会写一篇关于它的博文。暂时请大家自行查阅相关资料学习。</p><p>TF-IDF是一种统计方法，用于评估一个词对于一个文件集或者语料库中的一份文件的重要程度。</p><p>TF(term frequency)：指的是某一个给定的词语在该文件中出现的频率。公式如下：</p><p><span class="math inline">\(tf_i,_j = \frac{n_i,_j}{\sum_k n_k,_j}\)</span></p><p>IDF(Inverse document frequency)：是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p><p><span class="math inline">\(idf(t,D) = log(\frac{N}{\lvert {d \in D, t \in d}\rvert})\)</span></p><p><strong>关键词提取：</strong></p><p>官方给了一个代码示例文件，源代码在这里：<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags.py" target="_blank" rel="noopener">关键词提取源码</a> 但是为了结果显示得更清晰一点，我做了些许的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;../&apos;)</span><br><span class="line"></span><br><span class="line">import jieba</span><br><span class="line">import jieba.analyse</span><br><span class="line">from optparse import OptionParser</span><br><span class="line"></span><br><span class="line">USAGE = &quot;usage:    python extract_tags.py [file name] -k [top k]&quot;</span><br><span class="line"></span><br><span class="line">parser = OptionParser(USAGE)</span><br><span class="line">parser.add_option(&quot;-k&quot;, dest=&quot;topK&quot;)</span><br><span class="line">opt, args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if len(args) &lt; 1:</span><br><span class="line">    print(USAGE)</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">file_name = args[0]</span><br><span class="line"></span><br><span class="line">if opt.topK is None:</span><br><span class="line">    topK = 20</span><br><span class="line">else:</span><br><span class="line">    topK = int(opt.topK)</span><br><span class="line"></span><br><span class="line">content = open(file_name, &apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=topK,withWeight=True)</span><br><span class="line"></span><br><span class="line">for i in tags :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>先说下用法，官方在文件的第8行给出了用法，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python extract_tags.py [file name] -k [top k]</span><br></pre></td></tr></table></figure><p>将这个Extract_tags.py文件和文本文件放在同一目录下，然后给利用如上命令便可得到文本的关键词。默认取得是top10，我改了下取了top20，我们这里做下测试（使用jieba的官方测试文档：《围城》），结果如下：</p><p><img src="https://i.loli.net/2018/03/18/5aade4db4fb52.png" alt="extract.png"></p><p><strong>分析：</strong></p><p>官方给的代码看着挺长，实际上超简单，其中重要的无非两句话，一句是读文件，另一句则是调用extract_tags()方法，我在原有的基础上设置了withWight=True，因而返回了一个权重值。大家如果嫌麻烦可以对上述关键代码进行抽取，写一个自己的测试。</p><hr><p>正如上图所示，‘自己’、‘知道’、‘先生’等等等等，像这些词语都是些没有实际意义的单词，所以在聚类的时候这些单词不应该做为聚类（或者分类）的标准，它们属于stop_words，中文的意思就是停用词，所以我们接下来处理这个问题。</p><h1 id="去除停用词">去除停用词</h1><p>去除停用词，我们需要知道哪些属于停用词，我在CSDN上找到了一个1893规模的停用词表，链接如下：<a href="http://blog.csdn.net/shijiebei2009/article/details/39696571" target="_blank" rel="noopener">最全中文停用词表整理（1893个）</a>。</p><p>我们接下来的工作思路是这样的，对《围城》（文件1.txt）进行切词，方法就是之前的cut()，读取StopWords文件，对比每个切分出来的单词是否是停用词，如果不是则加入到一个list中，然后再将这个list的内容存到另一个文件2.txt中，对文件2.txt使用之前说到的官方给的关键词提取文件做关键词提取即可。</p><p>去除停用词代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import jieba</span><br><span class="line">from os import path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) # 获取当前文件的dir路径</span><br><span class="line">stopwords_path = &apos;stopwords1893.txt&apos;  # 停用词表路径</span><br><span class="line"></span><br><span class="line">text_path = &apos;txt/1.txt&apos; #《围城》的文本路径</span><br><span class="line">text = open(path.join(d, text_path),&apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">def RmStopWords(text):</span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=False)</span><br><span class="line">    liststr=&quot;/ &quot;.join(seg_list) # 添加切分符</span><br><span class="line">    f_stop = open(stopwords_path)</span><br><span class="line">    try:</span><br><span class="line">        f_stop_text = f_stop.read()</span><br><span class="line">    finally:</span><br><span class="line">        f_stop.close( )</span><br><span class="line">    f_stop_seg_list=f_stop_text.split(&apos;\n&apos;) # 停用词是每行一个，所以用/n分离</span><br><span class="line">    for myword in liststr.split(&apos;/&apos;):</span><br><span class="line">        #对于每个切分的词都去停用词表中对比</span><br><span class="line">        if not(myword.strip() in f_stop_seg_list) and len(myword.strip())&gt;1:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    return &apos;&apos;.join(mywordlist) #返回一个字符串</span><br><span class="line"></span><br><span class="line">txt2 = RmStopWords(text)</span><br><span class="line">text_write = &apos;txt/2.txt&apos;</span><br><span class="line">with open(text_write,&apos;w&apos;) as f:</span><br><span class="line">    f.write(txt2)</span><br><span class="line">    print(&quot;Success&quot;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/18/5aadf03b5ddc2.png" alt="RmStopWords.png"></p><p><strong>分析：</strong></p><p>由上图可见，我们的去停用词的效果还不错。</p><h1 id="最后">最后：</h1><p>这篇博客先写到这里，下一篇博客我会讲到jieba中文分词的进阶篇。感谢阅读，如有问题可以通过邮件与我交流，邮箱：cliugeek@us-forever.com</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近在学习文本分类（聚类）的相关知识，所以接下来准备先写一个关于这个方面的系列博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;写在前面：&lt;/h1&gt;
&lt;p&gt;先介绍下由我们四个人组成的组织：FOUR
        
      
    
    </summary>
    
      <category term="文本聚类" scheme="http://weafteam.github.io/categories/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="文本聚类" scheme="http://weafteam.github.io/tags/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从数据库的设置与Xtrabackup备份InnoDB(MySQL)</title>
    <link href="http://weafteam.github.io/posts/2f5dded6/"/>
    <id>http://weafteam.github.io/posts/2f5dded6/</id>
    <published>2018-03-17T08:08:56.000Z</published>
    <updated>2018-04-02T14:12:49.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一准备环境">一、准备环境</h2><ol type="1"><li>两台服务器：服务器A、服务器B</li><li>服务器A：Red Hat Enterprise Linux Server release 6.5 (Santiago)</li><li>服务器B：Red Hat Enterprise Linux Server release 6.5 (Santiago)</li><li>服务器A IP：172.16.125.50</li><li>服务器B IP：172.16.125.52</li><li>MySQL版本：5.6.23</li></ol><h2 id="二安装mysql">二、安装MySQL</h2><p>具体安装请见</p><ol type="1"><li><a href="http://us-forever.com/2018/01/15/LinuxMySQL的安装/" target="_blank" rel="noopener">LinuxMySQL的安装(1)</a></li><li><a href="http://us-forever.com/2018/02/02/LinuxMySQL的安装-2/" target="_blank" rel="noopener">LinuxMySQL的安装(2)</a></li><li><a href="http://us-forever.com/2018/02/08/LinuxMySQL的安装-3/" target="_blank" rel="noopener">LinuxMySQL的安装(3)</a></li></ol><a id="more"></a><h2 id="三主从库配置">三、主从库配置</h2><h3 id="主库在etcmy.cnf里添加以下内容">1、主库在/etc/my.cnf里添加以下内容</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#log日志</span></span><br><span class="line"><span class="attr">log_bin</span>=mysql_bin</span><br><span class="line"><span class="comment">#server ID</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">#忽略同步的库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=information_schema</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=cluster</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=mysql</span><br><span class="line"><span class="comment">#需要同步的库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=test</span><br></pre></td></tr></table></figure><h3 id="从库在etcmy.cnf里添加以下内容">2、从库在/etc/my.cnf里添加以下内容</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">log_bin=mysql_bin</span><br><span class="line">server_id=3</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=cluster</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">replicate-do-db=ufind_db</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">log-slave-updates</span><br><span class="line">slave-skip-errors=all</span><br><span class="line">slave-net-timeout=60</span><br></pre></td></tr></table></figure><h2 id="四主从库设置">四、主从库设置</h2><h3 id="进入主库我们在主库中创建一个的账户从库通过使用这个账号来同步数据">1、进入主库，我们在主库中创建一个的账户，从库通过使用这个账号来同步数据。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><h3 id="赋予相应的权限">2、赋予相应的权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">FILE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><h3 id="重启数据库主库执行以下命令">3、重启数据库（主库）执行以下命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><p><img src="http://us-forever.com/img/mysqlsync.png"> 要记住以上的信息，在设置从库的时候需要填写并设置。</p><h3 id="在从库里边执行以下命令">4、在从库里边执行以下命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master to master_host=&apos;172.16.125.50&apos;,master_user=&apos;repl&apos;,master_password=&apos;123456&apos;,master_log_file=&apos;mysql_bin.000023&apos;, master_log_pos=120;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h3 id="然后执行一下命令查看状态">5、然后执行一下命令查看状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure><p>内容如下： <img src="http://us-forever.com/img/mysqlsync1.png"> <img src="http://us-forever.com/img/mysqlsync2.png"></p><h3 id="测试与提示">6、测试与提示</h3><p>后期的测试中我们只针对<strong>test</strong>库进行了同步。 所以只能针对<strong>test</strong>进行的操作才有效。</p><p>如果后期对一些列库进行操作，需要 添加相应的配置 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>主库配置文件</span><br><span class="line">binlog-do-db=test</span><br><span class="line"><span class="meta">#</span>从库配置文件</span><br><span class="line">replicate-do-db=test</span><br></pre></td></tr></table></figure></p><p>并查询出最新的master的状态，停止从库。并改变从库的配置重启同步。 五、Xtrabackup的简单介绍 ——————- Percona XtraBackup 是世界上唯一的开源免费的MySQL热备份软件，可以执行非阻塞操作 InnoDB和XtraDB数据库的备份。 Percona XtraBackup可提供以下优点：</p><ul><li>备份快速安全可靠</li><li>备份期间不间断的事务处理</li><li>节省磁盘空间和网络带宽</li><li>自动备份验证</li><li>更快的恢复时间保证正常工作</li></ul><p>Percona XtraBackup 为所有版本的Percona服务器，MySQL和MariaDB提供MySQL热备份。 它可执行 流媒体，压缩和增量MySQL备份。</p><h2 id="六xtrabackup的安装">六、Xtrabackup的安装</h2><p>如果在互联网下 可使用以下命令安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>获取相应rpm包 安装部分依赖(不同的操作系统可能已安装的库不尽相同) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-compat-5.7.20-1.el7.x86_64.rpm</span><br><span class="line"><span class="meta">#</span>根据mysql版本而定</span><br><span class="line">yum list|grep perl</span><br><span class="line">yum -y install perl-DBI.x86_64 perl-DBD-MySQL.x86_64</span><br></pre></td></tr></table></figure></p><p>然后安装Xtrabackup <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>参考： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cmake gcc gcc-c++ libaio libaio-devel automake autoconf bison libtool ncurses-devel libgcrypt-devel libev-devel libcurl-devel vim-common</span><br></pre></td></tr></table></figure></p><h2 id="七xtrabackup备份mysql">七、Xtrabackup备份MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --defaults-file=/etc/my.cnf --user=root --password=root --host=localhost --backup --target-dir=/data/backups/</span><br><span class="line">可指定数据库--databases=test</span><br></pre></td></tr></table></figure><h2 id="八xtrabackup的备份恢复">八、Xtrabackup的备份恢复</h2><p>备份之前必须先关闭MySQL server 然后删除data目录（/var/lib/mysql一般情况是这个） <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup  --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure></p><p>执行完恢复之后需要设置文件权限 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure></p><p>然后启动mysql <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br><span class="line"><span class="meta">#</span>或者使用服务</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure></p><h2 id="九使用脚本自动备份7天之内的数据">九、使用脚本自动备份7天之内的数据</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># Database info</span><br><span class="line">DB_USER="root"</span><br><span class="line">DB_PASS="root"</span><br><span class="line">DB_HOST="localhost"</span><br><span class="line"></span><br><span class="line"># Others vars</span><br><span class="line">BCK_DIR="/opt/app/mysqlbackup"    #the backup file directory</span><br><span class="line">CONF_DIR="/etc/my.cnf"</span><br><span class="line">DATE=`date +%F`</span><br><span class="line">RMDATE=`date -d '-7 day' +%F`</span><br><span class="line"></span><br><span class="line"># TODO</span><br><span class="line"></span><br><span class="line">mkdir -p $BCK_DIR/$DATE/</span><br><span class="line">#Create dir for save backup data</span><br><span class="line">xtrabackup --defaults-file=$CONF_DIR --user=$DB_USER --password=$DB_PASS --host=$DB_HOST --backup --target-dir=$BCK_DIR/$DATE/</span><br><span class="line">#Backup mysql data</span><br><span class="line">rm -rf $BCK_DIR/$RMDATE</span><br><span class="line">#Delete the backup 7 days ago</span><br><span class="line">#热备份数据库</span><br></pre></td></tr></table></figure><p>加入crontab <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * * /bin/sh /home/scripts/mysqlbackup.sh</span><br></pre></td></tr></table></figure></p><p><a href="https://learn.percona.com/hubfs/Manuals/Percona_Xtra_Backup/Percona_XtraBackup_2.4/Percona-XtraBackup-2.4.9.pdf" target="_blank" rel="noopener">更多请参考官方文档</a></p>]]></content>
    
    <summary type="html">
    
      MySQL主从数据库的设置与Xtrabackup备份InnoDB(MySQL)
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>chapter-01-AIR</title>
    <link href="http://weafteam.github.io/posts/8e8e4531/"/>
    <id>http://weafteam.github.io/posts/8e8e4531/</id>
    <published>2018-03-14T10:49:23.000Z</published>
    <updated>2018-04-02T14:12:49.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章-tensorflow-install">第一篇文章-TensorFlow Install</h1><ol type="1"><li>首先介绍一些我们这个组织，这是有四个人构成得一个组织，组织可以叫FOUR ELEMENTS。（也可以叫WEAF）分别对应WELL、EARTH、AIR、FLAME。（WEAF）。</li><li>其次我想做一下自我介绍，我的英文学名叫milittle。我开设的这个周刊名字叫AIR-周刊。希望把自己学习的一些内容分享给大家，也激励自己。学更多的知识。以后大家有什么要交流的，也可以一起交流。（邮箱地址会在文章末尾给出）</li></ol><p>接下来我讲一下我后续每周在<code>AIR-周刊</code>里面会讲到的内容：</p><ul><li>主要涉及TensorFlow框架使用多一些</li><li>后续也会分享一些机器学习方面的算法</li><li>也会有一些在人工智能方面的杂谈</li></ul><p>上面说了一些，我想把这块做好，文章内容有什么变化，后续的文章里面会有所提及。</p><p>今天就介绍一些TensorFlow的简述和安装：</p><ol type="1"><li>TensorFlow是Google公司在2015年12月份开源的一个机器学习库，代码链接<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFLow</a>。</li><li>第二点为什么现在TensorFlow这么火，在人工智能界已经算得上是称霸的地位，我们可以从下面的图中可以看出TensorFlow的数据占据了一大半市场。</li></ol><p><img src="https://s1.ax1x.com/2018/03/14/94kzp6.jpg" alt="-"></p><ol start="3" type="1"><li>原因是什么呢<ul><li>最主要的原因就是本身具有图运算的这个概念。使用简单，而且可以让程序员快捷的实现一些算法。从而可以用TensorFlow解决一些现实中的问题。图运算的概念我们后续会慢慢深入。大家不要着急。</li><li>还有一个原因，我想不用说大家也都知道，既然说了是Google的开源框架，那么技术就一定很牛逼。引得广大程序员的喜爱也是必然发生的事情。</li><li>而且用这个框架可以快速的解决一些机器学习的算法问题。是的编程效率也不断提高。</li></ul></li><li>TensorFlow支持Mac、Windows、Linux。以后我们的实验有可能通过Windows进行，也有可能在Linux进行，而且以后的代码都是基于python3.X，所以希望大家可以实现基本的python3的语法知识和编程知识。还有就是TensorFlow支持CPU版本和GPU版本，安装的时候都有很多的注意事项，基于GPU版本的可能会比较麻烦。但是后续我会给大家出一个教程，分别在Windows下面和Linux下面配置自己的独立环境。让你的机器学习算法跑在你自己的机器上面。完成一些看起来炫酷的程序。</li></ol><p>接下来我介绍一下TensorFlow的Windows CPU安装方法：</p><ol type="1"><li>首先打开电脑，这个是一定的~</li><li>去TensorFlow的<a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">官网</a>下载Windows的版本。点击下面红色箭头的地方—随意，都可以跳转到一个关于windows安装的界面。（可能需要科学上网，逃）</li></ol><p><img src="https://s1.ax1x.com/2018/03/14/94AS1K.png" alt="-"></p><ol start="3" type="1"><li>点开界面以后的注意事项：<ul><li>windows7及其以后的操作系统版本</li><li>决定安装哪个TensorFlow的版本，GPU还是CPU（GPU会有有一些第三方的库依赖，CUDA），接下来我们的教程是CPU版本安装。</li><li>决定怎么安装TensorFlow：可选方式有native pip 和 Anaconda等（我们使用Anaconda）</li><li>最后一步验证你的安装效果</li></ul></li></ol><p>接下来一步一步来：</p><p>第一步、我们决定用Anaconda来安装TensorFlow，你要知道Anaconda是什么呢，它就是可以很好的管理python的一些依赖库。让你在不同python版本之间切换自如。所以我们使用这个工具来安装我们的TensorFlow。Anaconda也可以集成Spyder这些编程工具，使得你编写代码会方便一些。</p><p>第二步、首先你去<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda官网</a>下载windows版本的Anaconda，具体安装就和普通的安装软件类似。这个地方需要注意的是不同python版本需要不同的Anaconda，别下错了。</p><p>第三步、安装好以后，我们打开Anaconda的控制台，就是开始里面找到Anaconda的应用，然后里面有一个Anaconda Prompt。打开以后，我们就开始了我们创建一个独立的TensorFlow独立的环境。</p><blockquote><p><code>conda create -n tensorflow pip python=3.5</code></p><p>上面这命令的意思就是说在Anaconda管理的环境里面给我独立的创建一个python环境来，这个里面python的版本是3.5。注意一下，这个地方还没有安装tensorflow呢，上面的tensorflow只不过是创建的一个环境名字而已。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kjt1.png" alt="-"></p><blockquote><p><code>activate tensorflow</code></p><p>上面的命令是激活这个tensorflow的环境，你可以通过这个环境，添加一些你自己的python库，定制自己的python环境，这也是我使用Anaconda的原因，但是并不是只有Anaconda支持这样的方式。不要和我抬杠。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kXkR.png" alt="-"></p><p>第四步，也就是正儿八经的安装TensorFlow的阶段，<strong>这里解释一下，上面为什么我执行的是tensorflow1，因为我的电脑上面已经有tensorflow这个环境了</strong></p><blockquote><p><code>pip install --ignore-installed --upgrade tensorflow</code></p><p>这个命令就是使用pip正常的安装tensorflow，这里的pip管理起来和普通的pip管理是一个道理，这里就不赘述了。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kL79.png" alt="-"></p><p>第五步，测试TensorFlow是否安装上</p><blockquote><p><code>python</code></p><p>上面的命令是进入python解释器，然后执行下面的import语句</p><p><code>import tensorflow as tf</code></p><p>如果上面的命令执行完，如下图中一样，就算安装成功了，下面的那些语句是写了一个hello world！！！</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/22/9Hf66P.png" alt="-"></p><p>今天是为了我们以后在TensorFlow上开发所做的准备。希望大家安装顺利。我的个人邮箱是air@weaf.top。有什么问题可以单独发邮件问我。感谢你们的驻足。有什么不好的地方，可以给出意见。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;第一篇文章-tensorflow-install&quot;&gt;第一篇文章-TensorFlow Install&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;首先介绍一些我们这个组织，这是有四个人构成得一个组织，组织可以叫FOUR
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
</feed>
