<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEAF 周刊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weafteam.github.io/"/>
  <updated>2018-04-01T12:26:05.182Z</updated>
  <id>http://weafteam.github.io/</id>
  
  <author>
    <name>WEAF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TensorFlow 建立网络模型</title>
    <link href="http://weafteam.github.io/posts/5b7df854/"/>
    <id>http://weafteam.github.io/posts/5b7df854/</id>
    <published>2018-03-31T10:23:35.000Z</published>
    <updated>2018-04-01T12:26:05.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-建立网络模型">TensorFlow 建立网络模型</h1><p>上次一我们在fashion-mnist上面体验了一把，但是里面有一些建立模型和一些TensorFlow的基础概念都没有给大家讲，所以这节决定将这方面的知识介绍一些，上节是为了引起大家的注意，TensorFlow具有很强大的功能，我们只能后续慢慢的学习。</p><ol type="1"><li>其实在上一次的实例中，有很多地方确实是很困惑的，如果没有接触过机器学习的小伙伴可能理解起来会有一些问题，那么我开头就稍微讲一下，机器学习有一些什么？就我现在了解的一些内容给大家介绍，有可能有一些不到位的地方，还请多多包涵：</li></ol><blockquote><ul><li>其实机器学习，总的宗旨就是利用数据的特征来做识别和分类等任务</li><li>第一大类是分类工作，假设有一百类，经典的做法，就是使用神经网络提取一些数据的特征，然后利用softmax输出层进行不同种类概率的预测：</li></ul></blockquote><p><span class="math display">\[softmax(i) = \frac{X_i}{\sum_{i=0,99}X_i}\]</span></p><blockquote><ul><li>上面是softmax层计算的公式，从一百类里面找出每一类的概率值，然后按照概率值来预测输入数据是哪一种类型，就像上一次文章里面的fashion-mnist的数据一样，会预测出输出的类别。softmax(i)代表的就是这个种类的概率值，取最大值作为预测类别。</li><li>你可以把一个矩阵看成一个数据集合，一行是一个数据信息，就和我们的关系型数据一样，一行代表一个表的一条信息，那么每列就是每一行数据的一个属性，那么在机器学习里面就是数据的特征了，因为在网络模型中，每个特征都有对应的权重，那么，对于每个特征来说，对于最后的分类，识别等工作起的重要程度是不一样的。这也和我们的数据库信息差不多，有一些信息也是无关紧要的。有些信息可以主要决定这一行数据。</li><li>第二大类就是回归，回归可以看作是一个连续的分类，对于二维数据来说，其实就是根据你给出的数据来拟合一条线。对于三维来讲就是拟合一个平面。再高维就是超平面。</li></ul></blockquote><ol start="2" type="1"><li>最近，也就是2018年3月31在加利福尼亚州山景城的计算机历史博物馆举办了第二届TensorFlow开发者峰会，会上有超过500名使用TensorFlow的用户，还有一些观众，大家有兴趣的话可以关注youtube的TensorFlow官方频道。可以查看开会的视频。</li></ol><ul><li>TensorFlow应用广泛，其中有使用TensorFlow来做开普勒任务分析的</li><li>也有使用TensorFlow预测心脏发作和中风概率</li><li>还有一些应用在现实当中的项目。</li><li>这让我们认识到TensorFlow对于实际领域中应用的越来越广泛，所以我们不学习是不是有点亏。这么好的开源项目。</li></ul><ol start="3" type="1"><li>上一次我们既然做过了一次服装类别识别，那么这次我主要从TensorFlow建立模型的步骤讲起：让大家再深入理解一下TensorFlow。</li></ol><ul><li>第一步也是很重要的一步，那就是导入数据。</li><li>第二步一般就是对数据进行的预处理，一般包括归一化数据，转换数据等操作。</li><li>第三步设置算法的超参数，一般也就是学习率，batch_size(批处理个数)，epoch(轮次)。这里举一个例子，假如你有10000条训练数据。那么，batch_size设置为100，那么你的一个epoch就迭代100次才能将所有数据训练一遍，每次输入数据是100条，因为一个epoch的意思就是训练完一次训练数据，所以一个epoch是迭代100次就可以结束一轮了。learning_rate一般设置为0.1-0.0001之间，但是也不排除一些特殊情况，主要是learning_rate设置的过小，反向传播更新参数的时候速度会很慢，设置的过大，会出现无法收敛的情况。</li><li>第四步设置变量和placeholders，变量是记录权重和偏置项信息的，一般在最小化loss函数的时候，反向传播算法会更新权重和偏置项，TensorFlow导入数据是通过placeholders来实现的，大家还记得我们上次的fashion-mnist识别，我的数据就是通过先定义placeholders，最后在Session运行的时候，在feed_dict这个字典参数里面将训练数据喂进去的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a_var = tf.constant(<span class="number">42</span>)</span><br><span class="line">x_input = tf.placeholder(tf.float32, [n_x, <span class="keyword">None</span>], name=<span class="string">"X"</span>)</span><br><span class="line">x_output = tf.placeholder(tf.float32, [n_y, <span class="keyword">None</span>], name=<span class="string">"y"</span>)</span><br><span class="line"><span class="comment"># 定义输入数据的一些方式</span></span><br></pre></td></tr></table></figure><ul><li>第五步定义图模型，我们有了数据，初始化了变量和placeholders，那我们就需要定义一个图模型，来生成TensorFlow的图模型（计算图）我们必须告诉TensorFlow对我们的数据进行哪些操作，来让我们的模型具有预测能力（更加深入的运算我们在后续的博客里面会陆续讲到）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h_pre_output = tf.add(tf.matmul(W, x_input) + B)</span><br></pre></td></tr></table></figure><ul><li>第六步声明loss函数，在上面计算图中我们定义了一些对我们数据的操作。那么我们需要验证我们预测的输出，和我们真实之间的差距，一般对于回归任务来讲的话，就是平方误差：这样就求得了平方误差。但是对于分类任务，那就是交叉熵误差。就像上一节我们用到的loss生成函数就是softmax这种方式。，交叉熵的公式后续用到再给大家介绍。</li></ul><p><span class="math display">\[loss(i)=\frac{1}{N}\sum{_i}(y\_pre_i-y\_true_i)^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TensorFlow求法：</span><br><span class="line">loss = tf.reduce_mean(tf.square(y_pre - y_true))</span><br></pre></td></tr></table></figure><ul><li>第七步声明了loss函数以后，我们需要使用BP算法也就是反向传播算法来更新权重和偏置项。在TenorFlow框架里面有好多这样的优化器，都在 tf.train这个模块里面。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate = <span class="number">0.001</span>).minimize(loss)</span><br><span class="line">这个就是我们上次使用的优化器，来优化我们的loss</span><br></pre></td></tr></table></figure><ul><li>最后一步那就是初始化会话Session()，开始训练模型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">session.run(init)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>由上面的步骤，大家再结合上一次的网络代码，是不是可以理解了TensorFlow在建立一个网络模型的时候的具体步骤。</li><li>其实在TensorFlow中还有一个很重要的概念，那就是Tensor，上次说过了它的概念，那么接下来我讲一下TensorFlow里面的Tensor。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"><span class="comment"># 定义一个会话，记得，TensorFlow里面都是通过session来执行的</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 创建一个1 * 20的向量</span></span><br><span class="line">tensor_zeros = tf.zeros([<span class="number">1</span>, <span class="number">20</span>])</span><br><span class="line">sess.run(tensor_zeros) <span class="comment"># 你可以运行一下看看</span></span><br><span class="line">my_var = tf.Variable(tf.zeros([<span class="number">1</span>, <span class="number">20</span>])) <span class="comment"># 使用tenso来初始化变量</span></span><br><span class="line">sess.run(my_var.initializer) <span class="comment"># 又一种运行变量初始化器的方式</span></span><br><span class="line">sess.run(my_var) <span class="comment">#打印出来看看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf.ones() 生成全是1</span></span><br><span class="line"><span class="comment"># tf.zeros() 生成全是0</span></span><br><span class="line"><span class="comment"># tf.constant() 生成一个常量Tensor</span></span><br><span class="line"><span class="comment"># 如果我们想要通过一个已知的Tensor来创建另一个，则可以使用ones_like()和zeros_like()这两个函数</span></span><br><span class="line">zero_similar = tf.Variable(tf.zeros_like(tensor_zeros))</span><br><span class="line"></span><br><span class="line">sess.run(zero_similar.initializer)</span><br><span class="line">print(sess.run(zero_similar))</span><br><span class="line"><span class="comment"># 注意上面的两个函数的参数是为了确定生成Tensor的大小，而产生的值是通过函数决定的</span></span><br><span class="line">tf.fill([row, col], <span class="number">-1</span>)  <span class="comment"># 用具体的数字填充</span></span><br><span class="line">tf.linspace(start=<span class="number">0.0</span>, stop=<span class="number">1.0</span>, num=<span class="number">3</span>) <span class="comment"># 线性分布 包括end</span></span><br><span class="line">tf.range(start=<span class="number">6</span>, limit=<span class="number">15</span>, delta=<span class="number">3</span>)    <span class="comment"># 也是线性均匀 不包括end</span></span><br><span class="line">tf.random_normal([row_dim, col_dim], mean=<span class="number">0.0</span>, stddev=<span class="number">1.0</span>) <span class="comment"># 随机 均值0 方差1.0</span></span><br><span class="line">tf.random_uniform([row_dim, col_dim], minval=<span class="number">0</span>, maxval=<span class="number">4</span>) <span class="comment"># 或者最小最大值随机初始化</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line">my_var = tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">20</span>]))</span><br><span class="line"></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line">writer = tf.summary.FileWriter(<span class="string">"./tmp/variable_logs"</span>, graph=sess.graph)</span><br><span class="line"></span><br><span class="line">initialize_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">sess.run(initialize_op)</span><br><span class="line"><span class="comment"># 上面的就是一个Tensor放在一个变量里面，我们使用了一条语句 merged = tf.summary.merge_all() 还有writer = tf.summary.FileWriter("/tmp/variable_logs", graph=sess.graph)，这两句这是为了将变量在TensorBoard里面显示出来，让我们更加了解TensorFLow的一些操作。</span></span><br><span class="line"><span class="comment"># 上面的操作过程会在当前文件夹里面创建一个/tmp/variable_logs文件夹然后会将变量信息存储在一个文件里面</span></span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>那怎么使用tensorboard</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#进去我们的环境变量，然后执行</span><br><span class="line">tensorboard --logdir=tmp的绝对路径</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/01/9zF2P1.png" alt="-"></p><p>可以看到我上面执行的命令。然后在浏览器里面输入127.0.0.1:6006然后你就可以看到刚才那个变量的操作过程，这就是tensorboard的魅力</p><p><img src="https://s1.ax1x.com/2018/04/01/9zF7ad.png" alt="-"></p><p>上面就是一个变量在进行初始化时候可视化显示</p><ol start="7" type="1"><li>Placeholders使用(一样可以使用tensorboard来查看)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.python.framework import ops</span><br><span class="line">ops.reset_default_graph()</span><br><span class="line">sess = tf.Session()</span><br><span class="line"># 定义一个placeholder</span><br><span class="line">x = tf.placeholder(tf.float32, shape = (4, 4))</span><br><span class="line"></span><br><span class="line"># 随机生成4 * 4的矩阵</span><br><span class="line">reand_array = np.random.rand(4, 4)</span><br><span class="line">y = tf.identity(x) # 返回与输入对象相同的内容和大小</span><br><span class="line">print(sess.run(y, feed_dict=&#123;x: rand_array&#125;))</span><br><span class="line"></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line">writer = tf.summary.FileWriter(&quot;./tmp/variable_logs&quot;, sess.graph)</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/04/01/9zAshR.png" alt="-"></p><h5 id="总结">总结</h5><p>这次我们就TensorFlow的一些基础概念的介绍，也是为了让大家在以后的TensorFlow使用过程中少一些疑问，后面的章节，我们会慢慢深入。小伙伴们不要着急，我的邮箱是air@weaf.top，依旧是那个可以交流学习的milittle。谢谢大家的驻足。</p><p><a href="https://weaf.top/posts/8e8e4531/" target="_blank" rel="noopener">第一篇 TensorFlow安装</a></p><p><a href="https://weaf.top/posts/b0821049/" target="_blank" rel="noopener">第二篇 TensorFlow初体验（fasion-mnist识别）</a></p><p><a href="https://weaf.top/posts/233074e6/" target="_blank" rel="noopener">修改pip全局镜像方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-建立网络模型&quot;&gt;TensorFlow
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>修改pip全局镜像</title>
    <link href="http://weafteam.github.io/posts/233074e6/"/>
    <id>http://weafteam.github.io/posts/233074e6/</id>
    <published>2018-03-27T12:29:36.000Z</published>
    <updated>2018-04-01T12:26:05.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改pip全局镜像">修改pip全局镜像</h3><p>第一次我们在windows上面安装了Anaconda，在使用pip安装Tensorflow中速度过慢，所以我为大家介绍一中修改全局pip源的方法（这样在使用pip下载依赖库的时候就会快一些）：</p><ol type="1"><li>打开用户主目录：我的是<code>C:\Users\milittle</code>。</li><li>在里面新建pip文件夹，在pip文件夹中建立pip.ini文件。</li><li>在pip.ini文件中添加如下配置信息，我使用的豆瓣源：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br><span class="line">index-url = https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>最后的目录结构就是：<code>C:\Users\milittle\pip\pip.ini</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>如何理解描述符</title>
    <link href="http://weafteam.github.io/posts/5dd0238f/"/>
    <id>http://weafteam.github.io/posts/5dd0238f/</id>
    <published>2018-03-25T15:52:32.000Z</published>
    <updated>2018-04-01T12:26:05.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上篇文章中挖了 property 和描述符的坑，这篇就把它填上好了_(:з)∠)_</p><p>property 是用描述符实现的，所以先说说 property。</p><h2 id="property">property</h2><p>property 本身是一个实现了描述符协议的类，在不改变类接口的情况下，提供了一组对实例属性的读取、写入和删除操作。下面举个例子，一个银行账户的抽象，很容易实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, balance)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.balance = balance</span><br></pre></td></tr></table></figure><p>银行账户最常见的操作就是存款和取款了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">100</span>)  <span class="comment"># 创建一个有 100 块存款的账户</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: account.balance</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: account.balance -= <span class="number">90</span>  <span class="comment"># 取 90 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: account.balance  <span class="comment"># 还剩 10 块</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: account.balance += <span class="number">30</span>  <span class="comment"># 存 30 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: account.balance  <span class="comment"># 现在有 40 块</span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">40</span></span><br></pre></td></tr></table></figure><p>但是这里有个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: account.balance -= <span class="number">50</span>  <span class="comment"># 再取 50 块</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: account.balance  <span class="comment"># 存款变成了负数！</span></span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">-10</span></span><br></pre></td></tr></table></figure><p>当然这种操作是不该被允许的，我们需要对 <code>balance</code> 的写入做限制。Jawa 之类的语言会创建一组 getter、setter 方法来管理属性，但是这并不 Python，也对现有的代码不友好。正确的方式是使用 property。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, balance)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @balance.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'balance must greater than 0.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._balance = value</span><br></pre></td></tr></table></figure><p>现在 <code>balance</code> 被禁止设为小于 0 的数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: account.balance</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: account.balance += <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: account.balance -= <span class="number">200</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: balance must greater than <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: account.balance</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">140</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: account = Account(<span class="string">'zhang'</span>, <span class="number">-1</span>)  <span class="comment"># 初始化的时候也不行！</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: balance must greater than <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>可以看到我们使用 <code>balance</code> 的方式没有发生变化，但是对值的限制已经生效了。</p><p>property 还有一个 <code>deleter</code> 装饰器，处理应用于属性的 <code>del</code>；当然，<code>del</code> 本身用的也不多，大多数时候把销毁操作交给 Python 就可以了。不过如果涉及到复杂对象的引用，要做到 RAII（误，还是要手动实现的。</p><h3 id="property-是类">property 是类</h3><p>property 本身是用 C 实现的，<a href="https://docs.python.org/3/howto/descriptor.html#properties" target="_blank" rel="noopener">这里</a>有一个纯 Python 的实现。正如上文所说，它本身是一个类，构造方法的签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>熟悉一点装饰器用法的话就可以看出上面的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实际上就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    balance = property(fget=get_balance)</span><br></pre></td></tr></table></figure><p>如果不熟悉的话，下一篇就讲装饰器好了（误</p><h3 id="property-的实例是类属性">property 的实例是类属性</h3><p>上面的代码段同时展示了这样一个事实：property 的实例是类属性。这就涉及到了属性查找顺序的问题，简单试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    data = <span class="string">'data!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: f.data</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: f.data = <span class="string">'f.data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: f.data</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'f.data!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: Foo.data</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'data!'</span></span><br></pre></td></tr></table></figure><p>实例属性覆盖了类属性，符合直觉。那么对 property 的实例来说呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: f.bar</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">'bar!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: f.bar = <span class="string">'bar'</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure><p>尝试给 <code>bar</code> 赋值，失败了，也符合 property 的工作方式：执行赋值时，如果没有 setter 方法就抛出异常。那么直接修改 <code>f.__dict__</code> 呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: f.__dict__[<span class="string">'bar'</span>] = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: f.bar</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><p>也不行，property 的实例完全覆盖了实例属性。但是，它是一个类属性，所以我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: Foo.bar</span><br><span class="line">Out[<span class="number">10</span>]: &lt;property at <span class="number">0x29c44800408</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: Foo.bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: f.bar</span><br><span class="line">Out[<span class="number">12</span>]: <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: f.bar = <span class="string">'ba'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: f.bar</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'ba'</span></span><br></pre></td></tr></table></figure><p>对类属性的覆盖使 <code>bar</code> 不再是一个 property 的实例，所以也就不会覆盖后续的赋值了。</p><p>当然我们仍然可以用一个 property 的实例再次覆盖 <code>Foo.bar</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: Foo.bar = property(fget=<span class="keyword">lambda</span> self: <span class="string">'bar!'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: f.bar</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'bar!'</span></span><br></pre></td></tr></table></figure><p>恢复原样。 property 的实例这种先从类中开始属性查找的方式，是一类描述符的工作模式。接下来就说说描述符。</p><h2 id="描述符">描述符</h2><p>描述符是指实现了描述符协议的类，这个协议包含四个方法，分别是 <code>__get__</code>，<code>__set__</code>，<code>__delete__</code> 和 Python 3.6 新增的 <code>__set_name__</code>。通常，只要实现了 <code>__get__</code> 或 <code>__set__</code>，就可以被称之为描述符。在某个角度上说，描述符的作用相当于抽象的 property，可以为一组属性提供相同的读取、写入和删除逻辑。接下来，还是从数据验证的例子开始。</p><p>下面是商店中一项商品的抽象，包含商品名、数量和单价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    amount = Storage(<span class="string">'amount'</span>)</span><br><span class="line">    price = Storage(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, amount, price)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.amount = amount</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure><p>其中的 <code>amount</code> 和 <code>price</code> 都必须大于 0，所以可以用统一的描述符实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f'<span class="subst">&#123;self.name&#125;</span> must greater than 0.'</span>)</span><br></pre></td></tr></table></figure><p>由于我们并没有对读取方法有特别的需求，所以不用实现 <code>__get__</code> 方法。</p><p>试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: item = Item(<span class="string">'orange'</span>, <span class="number">100</span>, <span class="number">0</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: price must greater than <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: item = Item(<span class="string">'orange'</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">ValueError: amount must greater than <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>如果 <code>amount</code> 或 <code>price</code> 中的任何一个不大于 0，都会被禁止。</p><p>这里需要解释一下 <code>__set__</code> 的签名中的 <code>instance</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>instance</code> 是 <code>Item</code> 的实例。因为描述符应该管理实例的属性，所以需要额外的参数提供相应的实例。这也是为什么我们不能这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    self.__dict__[self.name] = value</span><br></pre></td></tr></table></figure><p>这实际上是为描述符实例设置了值，而描述符实例是<code>Item</code> 类的类属性，所有的 <code>Item</code> 实例都共享相同的描述符实例。修改了某个描述符实例，相当于修改了所有的 <code>Item</code> 实例。</p><p>上面的例子有个缺点，初始化描述符实例的时候需要重复属性的名字。我们希望可以简单的写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    amount = Storage()</span><br><span class="line">    price = Storage()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>而不需要在描述符的构造方法中重复属性名。这就是 Python 3.6 新增的 <code>__set_name__</code> 方法的作用。只要实现 <code>__set_name__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>同样解释一下函数签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>owner</code> 是 <code>Item</code> 类本身，<code>name</code> 是引用描述符实例的变量的名字。</p><p>如果使用的 Python 版本在 3.6 以下呢？有两个方法：第一个是用元类接管<code>Item</code>类的创建过程，这个不在这篇文章的内容之内（可能又挖了一个坑；第二个就是为每个描述符实例生成与属性名无关但是唯一字符串，用来代替属性名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>:</span></span><br><span class="line"></span><br><span class="line">    _counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        self.name = <span class="string">f'_<span class="subst">&#123;cls.__name__&#125;</span>#<span class="subst">&#123;cls._counter&#125;</span>'</span></span><br><span class="line">        cls._counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, self.name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'must greater than 0.'</span>)</span><br></pre></td></tr></table></figure><p>由于 <code>Item</code> 中的属性名和我们实际保存的属性名不同，所以需要实现 <code>__get__</code> 方法。与 <code>__set_name__</code> 签名中的 <code>owner</code> 含义相同，<code>__get__</code> 方法签名中的 <code>owner</code> 也是 <code>Item</code> 类本身。</p><p>现在，我们使用 <code>_Storage#N</code> 这样的名称在 <code>Item</code> 实例中保存属性。当然，这样的名称会让人有点困惑，特别是以类属性访问的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: Item.amount</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'_Storage#0'</span></span><br></pre></td></tr></table></figure><p>为了避免在如此明显的地方暴露我们的实现细节，我们可以修改异常的错误消息，或者，内省描述符实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.name)</span><br></pre></td></tr></table></figure><h3 id="两类描述符">两类描述符</h3><p>上述例子中对数据属性的控制和管理是描述符的典型用途之一。这种实现了 <code>__set__</code> 方法，接管了设置属性行为的描述符，被称为覆盖型描述符，没有定义 <code>__set__</code> 方法的描述符，被称为非覆盖型描述符。由于 Python 中对实例属性和类属性的处理方式不同，这两类描述符也有不同的行为。</p><h4 id="覆盖型描述符">覆盖型描述符</h4><p>实现了 <code>__set__</code> 方法的描述符就是覆盖型描述符。这类描述符虽然是类属性，但是会覆盖实例属性的赋值操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Override</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    override = Override()</span><br></pre></td></tr></table></figure><p>下面做一些实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: m.override = <span class="number">1</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: Manager.override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.__dict__[<span class="string">'override'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: m.__dict__</span><br><span class="line">Out[<span class="number">6</span>]: &#123;<span class="string">'override'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: m.override</span><br><span class="line">get!</span><br></pre></td></tr></table></figure><p>可以看出，无论以实例属性还是类属性访问 <code>override</code>，都会触发 <code>__get__</code> 方法；为实例属性 <code>override</code> 赋值会触发 <code>__set__</code> 方法；即使跳过描述符直接为 <code>m.__dict__</code> 赋值，读取 <code>override</code> 的操作仍然会被描述符覆盖。</p><h5 id="没有-__get__-方法的覆盖型描述符">没有 <code>__get__</code> 方法的覆盖型描述符</h5><p>如果只实现了 <code>__set__</code> 会发生什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverrideNoGet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    override_no_get = OverrideNoGet()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">2</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: Manager.override_no_get</span><br><span class="line">Out[<span class="number">3</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: m.override_no_get = <span class="number">1</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">5</span>]: &lt;__main__.OverrideNoGet at <span class="number">0x29c44a97668</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: m.__dict__[<span class="string">'override_no_get'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: m.override_no_get = <span class="number">2</span></span><br><span class="line">set!</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: m.override_no_get</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，没实现 <code>__get__</code> 方法，无论以实例属性还是类属性访问 <code>override_no_get</code>，都会返回描述符实例；而赋值操作可以触发 <code>__set__</code> 方法；由于我们的 <code>__set__</code> 方法并没有真正修改实例属性，所以再次访问 <code>override_no_get</code> 仍然会得到描述符实例；通过 <code>m.__dict__</code> 修改实例属性后，实例属性就会覆盖描述符；不过只有访问实例属性时才是如此，赋值仍然由 <code>__set__</code> 处理。</p><h4 id="非覆盖型描述符">非覆盖型描述符</h4><p>没有实现 <code>__set__</code> 方法的描述符就是非覆盖型描述符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverride</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line"></span><br><span class="line">    non_override = NonOverride()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: m = Manager()</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: Manager.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: m.non_override = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.non_override</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: Manager.non_override</span><br><span class="line">get!</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="keyword">del</span> m.non_override</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: m.non_override</span><br><span class="line">get!</span><br></pre></td></tr></table></figure><p>无论访问实例属性还是类属性，都会触发 <code>__get__</code> 方法；由于没有 <code>__set__</code> 方法，对属性的赋值不会被干涉；对属性复制之后，实例属性就会覆盖同名的描述符，但是访问类属性仍然可以触发 <code>__get__</code> 方法；如果把 <code>non_override</code> 从实例中删除，访问 <code>non_override</code> 的操作又会交给 <code>__get__</code>。</p><p>当然，描述符都是定义在类上的，如果对同名的类属性进行赋值，就会完全替换掉描述符。这里表现出读、写属性时的不对等：对类属性的读操作可以被 <code>__get__</code> 处理，但是写操作不会。当然，了解一些 Python 的话就会知道还存在着另一种不对等：读取实例属性时，会返回实例属性，如果实例属性不存在，会返回类属性；但是为实例属性赋值时，如果实例属性不存在，会在实例中创建属性，不会影响到类属性。</p><h2 id="结语">结语</h2><p>描述符充斥在 Python 底层（举个例子：Python 中的方法是怎么实现的？）与各种框架中，理解描述符是体会 Python 世界工作原理和设计美学的重要方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上篇文章中挖了 property 和描述符的坑，这篇就把它填上好了_(:з)∠)_&lt;/p&gt;
&lt;p&gt;property 是用描述符实现的，所以先说说 property。&lt;/p&gt;
&lt;h2
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow 初体验 （Fashion-mnist）</title>
    <link href="http://weafteam.github.io/posts/b0821049/"/>
    <id>http://weafteam.github.io/posts/b0821049/</id>
    <published>2018-03-25T13:18:37.000Z</published>
    <updated>2018-04-01T12:26:05.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow-初体验fashion-mnist">TensorFlow 初体验（Fashion-mnist）</h1><ol type="1"><li>接着上一讲的内容，想必大家已经通过我的教程安装好了TensorFlow了吧，那我们这节课通过安装简单的跨平台的集成开发环境Spyder，在这个集成开发环境上面实现一些python程序。具体安装过程见如下阐述：</li></ol><ul><li>首先在应用程序里面找到Anaconda应用程序，打开里面的Anaconda Navigator，然后打开以后，选中我们上次建立好的环境tensorflow。</li></ul><p><img src="https://s1.ax1x.com/2018/03/25/9qTXNV.png" alt="-"></p><ul><li>选中tensorflow这个环境变量以后，看到里面有一个集成开发环境叫spyder，这个工具就是今天我们要安装的，我的已经安装好了，所以是Launch，你们的没有安装好，所以是install状态，点解安装就好。（这个地方也可能需要翻墙）。</li><li>这个安装好以后，你就会在应用文件夹里面出现一个Spyder(tensorflow)这个应用程序，以后你就从应用文件夹启动就好。</li><li>那么启动以后：我也是启动了，出现了以下的情况：不慌，慢慢来。</li></ul><p><img src="https://s1.ax1x.com/2018/03/25/9q7njH.png" alt="-"></p><ul><li>看到上面的错误，这个错误提示是因为没有安装jedi这个依赖库，而且要求版本要大于0.9.0。那我们接下来解决一下这个问题。</li></ul><blockquote><p>小插曲，一下就可以解决，具体操作步骤:</p><ol type="1"><li>还是打开上次那个AnacondaPrompt的命令行</li><li>进去以后，执行<code>activate tensorflow</code> 相当于你要在这个环境下面给这个spyder安装这个依赖</li><li>进去以后，执行<code>pip install jedi==0.9.0</code> 就可以了，然后重启spyder（可以直接在这个环境里面输入<code>spyder</code>命令就可以实现spyder的启动，你也可以在应用文件夹里面启动，性质是一样的）</li><li>不出什么意外的话，spyder使用就没有问题了，有什么问题可以发邮件给我！！！</li></ol></blockquote><ul><li>解决了上面的小插曲以后，我们在spyder中输入以下代码进行测试。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">sess = tf.Session()</span><br><span class="line">init = tf.global_variables_initializer() </span><br><span class="line"><span class="comment"># 此处的init是全局变量初始化器，</span></span><br><span class="line"><span class="comment"># TensorFlow的session必须执行这个初始化器才能执行前面建立好的图，</span></span><br><span class="line"><span class="comment"># 所以，这个是很重要的一点，后续也会强调</span></span><br><span class="line"><span class="comment">#（也就是后续再网络中建立变量就是通过那个初始化器来进行初始化工作的）</span></span><br><span class="line"><span class="comment"># 其实在没有变量的时候，这个初始化器是不需要的</span></span><br><span class="line"><span class="comment"># 但是为了让大家形成习惯，还是写上</span></span><br><span class="line">sess.run(init)</span><br><span class="line">hello = tf.constant(<span class="string">'hello world'</span>)</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/03/25/9q7r5V.png" alt="-"></p><ul><li>上图中左面是代码书写区域，右面上半部分是变量查看区域，还有文件夹区域可以切换，右面下半部分是执行console区域，我输入上面的代码，执行以后console区域打出hello world字符串。</li></ul><ol start="2" type="1"><li>从上面的一些简单的测试以后，我们进入今天的主题，fashion-minist的识别，fashion-minist是一个服装识别的一个数据集，在这个数据集之前有一个mnist手写体识别数据集，这个手写数据集对应我们手写的十个数字，然后通过设计网络来识别手写体。但是今天我们不做手写体识别，直接来做fashion-minist识别。</li></ol><ul><li>闲话少说，上代码，边写边说。</li></ul><p>首先目标是实现衣服种类的识别。</p><p>数据可以在 <a href="https://github.com/zalandoresearch/fashion-mnist" target="_blank" rel="noopener">Zalando_Fashion_MNIST_repository</a>这个Github仓库获取。</p><p>数据分为60000训练数据和10000测试数据，图片都是灰度图片，大小为28 X 28，总共也是由10类组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Mar 25 15:16:23 2018</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: milittle</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一些必要的库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 数学计算库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 画图的一个库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf <span class="comment"># TensorFlow的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">fashion_mnist = input_data.read_data_sets(<span class="string">'input/data'</span>, one_hot = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个服装对应表</span></span><br><span class="line">label_dict = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'T-shirt/top'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'Trouser'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Pullover'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'Dress'</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">'Coat'</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">'Sandal'</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">'Shirt'</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">'Sneaker'</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">'Bag'</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">'Ankle boot'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取随机的数据和它的label</span></span><br><span class="line">sample_1 = fashion_mnist.train.images[<span class="number">47</span>].reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">sample_label_1 = np.where(fashion_mnist.train.labels[<span class="number">47</span>] == <span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">sample_2 = fashion_mnist.train.images[<span class="number">23</span>].reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">sample_label_2 = np.where(fashion_mnist.train.labels[<span class="number">23</span>] == <span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用matplot画出这个image和label</span></span><br><span class="line">print(<span class="string">"y = &#123;label_index&#125; (&#123;label&#125;)"</span>.format(label_index=sample_label_1, label=label_dict[sample_label_1]))</span><br><span class="line">plt.imshow(sample_1, cmap=<span class="string">'Greys'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"y = &#123;label_index&#125; (&#123;label&#125;)"</span>.format(label_index=sample_label_2, label=label_dict[sample_label_2]))</span><br><span class="line">plt.imshow(sample_2, cmap=<span class="string">'Greys'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就是设计网络参数</span></span><br><span class="line">n_hidden_1 = <span class="number">128</span> <span class="comment"># 第一个隐藏层的单元个数</span></span><br><span class="line">n_hidden_2 = <span class="number">128</span> <span class="comment"># 第二个隐藏层的单元个数</span></span><br><span class="line">n_input = <span class="number">784</span> <span class="comment"># fashion mnist输入图片的维度（单元个数） (图片大小: 28*28)</span></span><br><span class="line">n_classes = <span class="number">10</span> <span class="comment"># fashion mnist的种类数目 (0-9 数字)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 placeholders</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_placeholders</span><span class="params">(n_x, n_y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    为sess创建一个占位对象。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    n_x -- 向量, 图片大小 (28*28 = 784)</span></span><br><span class="line"><span class="string">    n_y -- 向量, 种类数目 (从 0 到 9, 所以是 -&gt; 10种)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回参数:</span></span><br><span class="line"><span class="string">    X -- 为输入图片大小的placeholder shape是[784, None] </span></span><br><span class="line"><span class="string">    Y -- 为输出种类大小的placeholder shape是[10, None] None在这里表示以后输入的数据可以任意多少</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    X = tf.placeholder(tf.float32, [n_x, <span class="keyword">None</span>], name=<span class="string">"X"</span>)</span><br><span class="line">    Y = tf.placeholder(tf.float32, [n_y, <span class="keyword">None</span>], name=<span class="string">"Y"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试上面的create_placeholders()</span></span><br><span class="line">X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">print(<span class="string">"Shape of X: &#123;shape&#125;"</span>.format(shape=X.shape))</span><br><span class="line">print(<span class="string">"Shape of Y: &#123;shape&#125;"</span>.format(shape=Y.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义初始化参数参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数初始化，下面是每个参数的shape，总共有三层</span></span><br><span class="line"><span class="string">                        W1 : [n_hidden_1, n_input]</span></span><br><span class="line"><span class="string">                        b1 : [n_hidden_1, 1]</span></span><br><span class="line"><span class="string">                        W2 : [n_hidden_2, n_hidden_1]</span></span><br><span class="line"><span class="string">                        b2 : [n_hidden_2, 1]</span></span><br><span class="line"><span class="string">                        W3 : [n_classes, n_hidden_2]</span></span><br><span class="line"><span class="string">                        b3 : [n_classes, 1]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    包含所有权重和偏置项的dic</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置随机数种子</span></span><br><span class="line">    tf.set_random_seed(<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为每一层的权重和偏置项进行初始化工作</span></span><br><span class="line">    W1 = tf.get_variable(<span class="string">"W1"</span>, [n_hidden_1, n_input], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b1 = tf.get_variable(<span class="string">"b1"</span>, [n_hidden_1, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    W2 = tf.get_variable(<span class="string">"W2"</span>, [n_hidden_2, n_hidden_1], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b2 = tf.get_variable(<span class="string">"b2"</span>, [n_hidden_2, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    W3 = tf.get_variable(<span class="string">"W3"</span>, [n_classes, n_hidden_2], initializer=tf.contrib.layers.xavier_initializer(seed = <span class="number">42</span>))</span><br><span class="line">    b3 = tf.get_variable(<span class="string">"b3"</span>, [n_classes, <span class="number">1</span>], initializer = tf.zeros_initializer())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将参数存储在一个dict对象里面返回去</span></span><br><span class="line">    parameters = &#123;</span><br><span class="line">        <span class="string">"W1"</span>: W1,</span><br><span class="line">        <span class="string">"b1"</span>: b1,</span><br><span class="line">        <span class="string">"W2"</span>: W2,</span><br><span class="line">        <span class="string">"b2"</span>: b2,</span><br><span class="line">        <span class="string">"W3"</span>: W3,</span><br><span class="line">        <span class="string">"b3"</span>: b3</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试初始化参数</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    print(<span class="string">"W1 = &#123;w1&#125;"</span>.format(w1=parameters[<span class="string">"W1"</span>]))</span><br><span class="line">    print(<span class="string">"b1 = &#123;b1&#125;"</span>.format(b1=parameters[<span class="string">"b1"</span>]))</span><br><span class="line">    print(<span class="string">"W2 = &#123;w2&#125;"</span>.format(w2=parameters[<span class="string">"W2"</span>]))</span><br><span class="line">    print(<span class="string">"b2 = &#123;b2&#125;"</span>.format(b2=parameters[<span class="string">"b2"</span>]))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播算法（就是神经网络的前向步骤）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(X, parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现前向传播的模型 LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SOFTMAX</span></span><br><span class="line"><span class="string">    上面的显示就是三个线性层，每一层结束以后，实现relu的作用，实现非线性功能，最后三层以后用softmax实现分类</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入训练数据的个数[784, n] 这里的n代表可以一次训练多个数据</span></span><br><span class="line"><span class="string">    parameters -- 包括上面所有的定义参数三个网络中的权重W和偏置项B</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    Z3 -- 最后的一个线性单元输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从参数dict里面取到所有的参数</span></span><br><span class="line">    W1 = parameters[<span class="string">'W1'</span>]</span><br><span class="line">    b1 = parameters[<span class="string">'b1'</span>]</span><br><span class="line">    W2 = parameters[<span class="string">'W2'</span>]</span><br><span class="line">    b2 = parameters[<span class="string">'b2'</span>]</span><br><span class="line">    W3 = parameters[<span class="string">'W3'</span>]</span><br><span class="line">    b3 = parameters[<span class="string">'b3'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前向传播过程</span></span><br><span class="line">    Z1 = tf.add(tf.matmul(W1,X), b1)     <span class="comment"># Z1 = np.dot(W1, X) + b1</span></span><br><span class="line">    A1 = tf.nn.relu(Z1)                  <span class="comment"># A1 = relu(Z1)</span></span><br><span class="line">    Z2 = tf.add(tf.matmul(W2,A1), b2)    <span class="comment"># Z2 = np.dot(W2, a1) + b2</span></span><br><span class="line">    A2 = tf.nn.relu(Z2)                  <span class="comment"># A2 = relu(Z2)</span></span><br><span class="line">    Z3 = tf.add(tf.matmul(W3,A2), b3)    <span class="comment"># Z3 = np.dot(W3,Z2) + b3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试前向传播喊出</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    print(<span class="string">"Z3 = &#123;final_Z&#125;"</span>.format(final_Z=Z3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算损失函数</span></span><br><span class="line"><span class="comment"># 是计算loss的时候了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(Z3, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算cost</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    Z3 -- 前向传播的最终输出（[10, n]）n也是你输入的训练数据个数</span></span><br><span class="line"><span class="string">    Y -- </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    cost - 损失函数 张量（Tensor）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获得预测和准确的label</span></span><br><span class="line">    logits = tf.transpose(Z3)</span><br><span class="line">    labels = tf.transpose(Y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = logits, labels = labels))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试计算损失函数</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    X, Y = create_placeholders(n_input, n_classes)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    print(<span class="string">"cost = &#123;cost&#125;"</span>.format(cost=cost))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个就是关键了，因为每一层的参数都是通过反向传播来实现权重和偏置项参数更新的</span></span><br><span class="line"><span class="comment"># 总体的原理就是经过前向传播，计算到最后的层，利用softmax加交叉熵，算出网络的损失函数</span></span><br><span class="line"><span class="comment"># 然后对损失函数进行求偏导，利用反向传播算法实现每一层的权重和偏置项的更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(train, test, learning_rate=<span class="number">0.0001</span>, num_epochs=<span class="number">16</span>, minibatch_size=<span class="number">32</span>, print_cost=True, graph_filename=<span class="string">'costs'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现了一个三层的网络结构: LINEAR-&gt;RELU-&gt;LINEAR-&gt;RELU-&gt;LINEAR-&gt;SOFTMAX.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    train -- 训练集</span></span><br><span class="line"><span class="string">    test -- 测试集</span></span><br><span class="line"><span class="string">    learning_rate -- 优化权重时候所用到的学习率</span></span><br><span class="line"><span class="string">    num_epochs -- 训练网络的轮次</span></span><br><span class="line"><span class="string">    minibatch_size -- 每一次送进网络训练的数据个数（也就是其他函数里面那个n参数）</span></span><br><span class="line"><span class="string">    print_cost -- 每一轮结束以后的损失函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    parameters -- 被用来学习的参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保参数不被覆盖重写</span></span><br><span class="line">    tf.reset_default_graph()</span><br><span class="line">    tf.set_random_seed(<span class="number">42</span>)</span><br><span class="line">    seed = <span class="number">42</span></span><br><span class="line">    <span class="comment"># 获取输入和输出大小</span></span><br><span class="line">    (n_x, m) = train.images.T.shape</span><br><span class="line">    n_y = train.labels.T.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    costs = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建输入输出数据的占位符</span></span><br><span class="line">    X, Y = create_placeholders(n_x, n_y)</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行前向传播</span></span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    <span class="comment"># 计算损失函数</span></span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    <span class="comment"># 使用AdamOptimizer优化器实现反向传播算法（最小化cost）</span></span><br><span class="line">    <span class="comment"># 其实我们这个地方的反向更新参数的过程都是tensorflow给做了</span></span><br><span class="line">    optimizer = tf.train.AdamOptimizer(learning_rate).minimize(cost)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 变量初始化器</span></span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始tensorflow的sess 来计算tensorflow构建好的图</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这个就是之前说过的要进行初始化的</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 训练轮次</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">            </span><br><span class="line">            epoch_cost = <span class="number">0.</span></span><br><span class="line">            num_minibatches = int(m / minibatch_size)</span><br><span class="line">            seed = seed + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_minibatches):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获取下一个batch的训练数据和label数据</span></span><br><span class="line">                minibatch_X, minibatch_Y = train.next_batch(minibatch_size)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 执行优化器</span></span><br><span class="line">                _, minibatch_cost = sess.run([optimizer, cost], feed_dict=&#123;X: minibatch_X.T, Y: minibatch_Y.T&#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新每一轮的损失</span></span><br><span class="line">                epoch_cost += minibatch_cost / num_minibatches</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 打印每一轮的损失</span></span><br><span class="line">            <span class="keyword">if</span> print_cost == <span class="keyword">True</span>:</span><br><span class="line">                print(<span class="string">"Cost after epoch &#123;epoch_num&#125;: &#123;cost&#125;"</span>.format(epoch_num=epoch, cost=epoch_cost))</span><br><span class="line">                costs.append(epoch_cost)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用matplot画出损失的变化曲线图</span></span><br><span class="line">        plt.figure(figsize=(<span class="number">16</span>,<span class="number">5</span>))</span><br><span class="line">        plt.plot(np.squeeze(costs), color=<span class="string">'#2A688B'</span>)</span><br><span class="line">        plt.xlim(<span class="number">0</span>, num_epochs<span class="number">-1</span>)</span><br><span class="line">        plt.ylabel(<span class="string">"cost"</span>)</span><br><span class="line">        plt.xlabel(<span class="string">"iterations"</span>)</span><br><span class="line">        plt.title(<span class="string">"learning rate = &#123;rate&#125;"</span>.format(rate=learning_rate))</span><br><span class="line">        plt.savefig(graph_filename, dpi = <span class="number">300</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存参数</span></span><br><span class="line">        parameters = sess.run(parameters)</span><br><span class="line">        print(<span class="string">"Parameters have been trained!"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算预测准率</span></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(Z3), tf.argmax(Y))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算测试准率</span></span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">"float"</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Train Accuracy:"</span>, accuracy.eval(&#123;X: train.images.T, Y: train.labels.T&#125;))</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Test Accuracy:"</span>, accuracy.eval(&#123;X: test.images.T, Y: test.labels.T&#125;))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要开始训练我们的fashion mnist网络了</span></span><br><span class="line">train = fashion_mnist.train <span class="comment"># 训练的数据</span></span><br><span class="line">test = fashion_mnist.test <span class="comment"># 测试的数据</span></span><br><span class="line"></span><br><span class="line">parameters = model(train, test, learning_rate = <span class="number">0.001</span>, num_epochs = <span class="number">16</span>, graph_filename = <span class="string">'fashion_mnist_costs'</span>)</span><br></pre></td></tr></table></figure><ul><li>上面的代码是写好了，这里有一个python的依赖库（matplotlib）需要安装以下，同样的办法，就是进去tensorflow这个环境里面，然后执行<code>pip install matplotlib</code>就可以了。</li><li>在这个过程中，可能从tensorflow下载数据的时候会很慢。（我们选择直接从上面给出下载数据集的github网址，直接下载以后，将数据拷贝在代码所在文件夹的input/data/文件夹里面，总共由四个文件组成）分别是训练数据图片、训练数据label和测试数据图片、测试数据label。这样就可以省去下载数据时候漫长的等待。</li></ul><ol start="3" type="1"><li>上面就是我们使用TensorFlow实现的fashion-mnist的识别，总体根据实验结果来说，从测试集的数据来看，我达到的准确率结果是88.5%，还算可以。后续我们可能使用其他一些现有的网络结构来实现fashion-mnist的识别，看看准确率会不会提高。</li><li>如下是我对上面TensorFLow出现的方法介绍：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">tf.placeholders(</span><br><span class="line">dtype,</span><br><span class="line">shape=<span class="keyword">None</span>,</span><br><span class="line">name=<span class="keyword">None</span></span><br><span class="line">)</span><br><span class="line">从参数上面看到，总共有三个参数：</span><br><span class="line">dtype：在tensor中被喂数据的元素类型</span><br><span class="line">shape: tensor的shape</span><br><span class="line">name：命名</span><br><span class="line">说明一下，这个函数返回的是一个tensor，在TensorFlow里面，tensor是一个很重要的概念，大家务必掌握，也叫张量，比如我们的一个数:就是<span class="number">0</span>-阶张量，也叫标量。一个向量，就是<span class="number">1</span>-阶张量。一个矩阵，就是<span class="number">2</span>-阶张量，后面的就是一直往高维了走，对应的就是多少阶张量。</span><br><span class="line">这个方法，很重要的原因也在于它是定义在Session执行run的时候，在后面填充数据的占位符，也就是feed_dict这个变量里面的数据，所以大家，务必记住这一关键的概念。后续用起来就会很顺手。</span><br><span class="line">tf.get_variable()</span><br><span class="line">这个方法后续在展开来说，你先理解就是使用它可以定义变量（保存权重和偏置项的），还可以加一些优化器，比如说正则优化器等等</span><br><span class="line">tf.matmul(</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">)</span><br><span class="line">展示给你们列出这两个参数：</span><br><span class="line">a：就是待操作的矩阵<span class="number">1</span></span><br><span class="line">b: 就是待操作的矩阵<span class="number">2</span></span><br><span class="line">函数功能就是实现矩阵的相乘运算（当然要符合基本的矩阵运算格式）</span><br><span class="line">tf.transpose(</span><br><span class="line">a,</span><br><span class="line">)</span><br><span class="line">先列出来一个参数，就是矩阵的转置</span><br><span class="line">Session().run(</span><br><span class="line">fetches,</span><br><span class="line">feed_list=<span class="keyword">None</span>,</span><br><span class="line">)</span><br><span class="line">这个方法就是运行图。很关键，先掌握两个参数:</span><br><span class="line">fetches: 你要从图里面取出的数据（）</span><br><span class="line">feed_list: 你要给图喂的数据（输入和label数据就是用这样的方式来做的）</span><br><span class="line">    比如我们训练的网络中输入的图片信息和对应的label信息</span><br><span class="line">tf.reduce_mean(</span><br><span class="line">input_tensor,</span><br><span class="line">axis=<span class="keyword">None</span>,</span><br><span class="line">keepdims=<span class="keyword">None</span>,</span><br><span class="line">name=<span class="keyword">None</span>,</span><br><span class="line">redcution_indices=<span class="keyword">None</span>,</span><br><span class="line">keep_dims=<span class="keyword">None</span></span><br><span class="line">)</span><br><span class="line">计算输入tensor的总和：</span><br><span class="line">input_tensor: 要叠加的tensor</span><br><span class="line">axis: 选择那个维度叠加</span><br><span class="line">keepdims: 叠加元素以后，保留原来的维度信息</span><br><span class="line">name：就是名字</span><br><span class="line">redcution_indices：被axis取代</span><br><span class="line">keep_dims：被keepdims取代</span><br></pre></td></tr></table></figure><p>我们今天的任务量可能有一些大，大家坚持。总的来说就是使用神经网络对实际的一个fashion-mnist数据集进行服装种类的识别，大家主要看看我的代码。有什么不明白的我在代码里面都做出了注释。</p><p>邮箱——air@weaf.top欢迎来探讨</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;tensorflow-初体验fashion-mnist&quot;&gt;TensorFlow 初体验（Fashion-mnist）&lt;/h1&gt;
&lt;ol
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>rsync的使用与配置</title>
    <link href="http://weafteam.github.io/posts/cfc65600/"/>
    <id>http://weafteam.github.io/posts/cfc65600/</id>
    <published>2018-03-25T13:08:56.000Z</published>
    <updated>2018-04-01T12:26:05.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一什么是rsync">一、什么是rsync</h2><p><strong>rsync</strong>，remote synchronize顾名思意就知道它是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。</p><h2 id="二rsync的安装">二、rsync的安装</h2><p>rysnc的官方网站：http://rsync.samba.org 可以从上面得到最新的版本。目前最新版是3.1.2。当然，因为rsync是一款如此有用的软件，所以很多Linux的发行版本都将它收录在内了。</p><a id="more"></a><p>　　软件包安装</p><table><thead><tr class="header"><th>命令</th><th>平台</th></tr></thead><tbody><tr class="odd"><td># sudo apt-get install rsync</td><td>注：在debian、ubuntu 等在线安装方法；</td></tr><tr class="even"><td># yum install rsync</td><td>注：Fedora、Redhat 等在线安装方法；</td></tr><tr class="odd"><td># rpm -ivh rsync</td><td>注：Fedora、Redhat 等rpm包安装方法；</td></tr></tbody></table><p>　　其它Linux发行版，请用相应的软件包管理方法来安装。</p><p>　　源码包安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　tar xvf  rsync-xxx.tar.gz</span><br><span class="line">　　cd rsync-xxx</span><br><span class="line">　　./configure --prefix=/usr  ;make ;make install   注：在用源码</span><br></pre></td></tr></table></figure></p><p>包编译安装之前，您得安装gcc等编译开具才行； 三、rsync的配置 ———– rsync的主要有以下三个配置文件<strong>rsyncd.conf</strong>(主配置文件)、<strong>rsyncd.secrets</strong>(密码文件)、<strong>rsyncd.motd</strong>(rysnc服务器信息) 比如我们要备份服务器上的/home和/opt，在/home中我想把easylife和samba目录排除在外； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">　　# Distributed under the terms of the GNU General Public License v2</span><br><span class="line">　　# Minimal configuration file for rsync daemon</span><br><span class="line">　　# See rsync(1) and rsyncd.conf(5) man pages for help</span><br><span class="line"></span><br><span class="line">　　# This line is required by the /etc/init.d/rsyncd script</span><br><span class="line">　　pid file = /var/run/rsyncd.pid   </span><br><span class="line">　　port = 873</span><br><span class="line">　　address = 192.168.1.171  </span><br><span class="line">　　#uid = nobody </span><br><span class="line">　　#gid = nobody    </span><br><span class="line">　　uid = root   </span><br><span class="line">　　gid = root  </span><br><span class="line"></span><br><span class="line">　　use chroot = yes  </span><br><span class="line">　　read only = yes </span><br><span class="line"></span><br><span class="line">　　#limit access to private LANs</span><br><span class="line">　　hosts allow=192.168.1.0/255.255.255.0 10.0.1.0/255.255.255.0  </span><br><span class="line">　　hosts deny=*</span><br><span class="line"></span><br><span class="line">　　max connections = 5 </span><br><span class="line">　　motd file = /etc/rsyncd.motd</span><br><span class="line"></span><br><span class="line">　　#This will give you a separate log file</span><br><span class="line">　　#log file = /var/log/rsync.log</span><br><span class="line"></span><br><span class="line">　　#This will log every file transferred - up to 85,000+ per user, per sync</span><br><span class="line">　　#transfer logging = yes</span><br><span class="line"></span><br><span class="line">　　log format = %t %a %m %f %b</span><br><span class="line">　　syslog facility = local3</span><br><span class="line">　　timeout = 300</span><br><span class="line"></span><br><span class="line">　　[rhel4home]   </span><br><span class="line">　　path = /home    </span><br><span class="line">　　list=yes </span><br><span class="line">　　ignore errors </span><br><span class="line">　　auth users = root</span><br><span class="line">　　secrets file = /etc/rsyncd.secrets  </span><br><span class="line">　　comment = This is RHEL 4 data  </span><br><span class="line">　　exclude = easylife/  samba/     </span><br><span class="line"></span><br><span class="line">　　[rhel4opt]</span><br><span class="line">　　path = /opt </span><br><span class="line">　　list=no</span><br><span class="line">　　ignore errors</span><br><span class="line">　　comment = This is RHEL 4 opt </span><br><span class="line">　　auth users = easylife</span><br><span class="line">　　secrets file = /etc/rsyncd/rsyncd.secrets</span><br></pre></td></tr></table></figure></p><p>　　注：关于auth users是必须在服务器上存在的真实的系统用户，如果你想用多个用户以,号隔开，比如auth users = easylife,root 　　设定密码文件</p><p>　　密码文件格式很简单，rsyncd.secrets的内容格式为：</p><p>　　用户名:密码</p><p>　　我们在例子中rsyncd.secrets的内容如下类似的；在文档中说，有些系统不支持长密码，自己尝试着设置一下吧。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　easylife:keer</span><br><span class="line">　　root:mike</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　chown root.root rsyncd.secrets 　#修改属主</span><br><span class="line">　　chmod 600 rsyncd.secrets     #修改权限</span><br></pre></td></tr></table></figure><p>　　注：1、将rsyncd.secrets这个密码文件的文件属性设为root拥有, 且权限要设为600, 否则无法备份成功! 出于安全目的，文件的属性必需是只有属主可读。 　　　　2、这里的密码值得注意，为了安全你不能把系统用户的密码写在这里。比如你的系统用户easylife密码是000000，为了安全你可以让rsync中的easylife为keer。这和samba的用户认证的密码原理是差不多的。</p><p>　　设定rsyncd.motd 文件;</p><p>　 　它是定义rysnc服务器信息的，也就是用户登录信息。比如让用户知道这个服务器是谁提供的等；类似ftp服务器登录时，我们所看到的 linuxsir.org ftp ……。 当然这在全局定义变量时，并不是必须的，你可以用#号注掉，或删除；我在这里写了一个 rsyncd.motd的内容为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">　　Welcome to use the mike.org.cn rsync services!</span><br><span class="line">2002------2009</span><br><span class="line">　　++++++++++++++++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure></p><h2 id="四启动rsync服务器">四、启动rsync服务器</h2><p>相当简单，有以下几种方法</p><p>　　A、–daemon参数方式，是让rsync以服务器模式运行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#/usr/bin/rsync --daemon  --config=/etc/rsyncd/rsyncd.conf 　#--config用于指定rsyncd.conf的位置,如果在/etc下可以不写</span><br></pre></td></tr></table></figure></p><p>　　B、xinetd方式 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　修改services加入如下内容</span><br><span class="line">　　# nano -w /etc/services</span><br><span class="line"></span><br><span class="line">　　rsync　　873/tcp　　# rsync </span><br><span class="line">　　rsync　　873/udp　　# rsync</span><br></pre></td></tr></table></figure></p><p>　　这一步一般可以不做，通常都有这两行(我的RHEL4和GENTOO默认都有)。修改的目的是让系统知道873端口对应的服务名为rsync。如没有的话就自行加入。</p><p>　　设定 /etc/xinetd.d/rsync, 简单例子如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　# default: off</span><br><span class="line">　　# description: The rsync server is a good addition to am ftp server, as it \</span><br><span class="line">　　#       allows crc checksumming etc.</span><br><span class="line">　　service rsync</span><br><span class="line">　　&#123;</span><br><span class="line">disable = no</span><br><span class="line">socket_type     = stream</span><br><span class="line">wait            = no</span><br><span class="line">user            = root</span><br><span class="line">server          = /usr/bin/rsync</span><br><span class="line">server_args     = --daemon</span><br><span class="line">log_on_failure  += USERID</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p><p>　　上述, 主要是要打开rsync這個daemon, 一旦有rsync client要连接時, xinetd会把它转介給 rsyncd(port 873)。然后service xinetd restart, 使上述设定生效.</p><p>　　rsync服务器和防火墙</p><p>　　Linux 防火墙是用iptables，所以我们至少在服务器端要让你所定义的rsync 服务器端口通过，客户端上也应该让通过。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　#iptables -A INPUT -p tcp -m state --state NEW  -m tcp --dport 873 -j ACCEPT</span><br><span class="line">　　#iptables -L  查看一下防火墙是不是打开了 873端口</span><br></pre></td></tr></table></figure></p><p>　　如果你不太懂防火墙的配置，可以先service iptables stop 将防火墙关掉。当然在生产环境这是很危险的，做实验才可以这么做哟！</p><h2 id="五通过rsync客户端来同步数据">五、通过rsync客户端来同步数据</h2><h3 id="b1列出rsync-服务器上的所提供的同步内容">B1、列出rsync 服务器上的所提供的同步内容；</h3><p>　　首先：我们看看rsync服务器上提供了哪些可用的数据源</p><p>　　# rsync –list-only root@192.168.145.5:: 　　++++++++++++++++++++++++++++++++++++++++++++++ 　　Welcome to use the mike.org.cn rsync services! 　　 2002——2009 　　++++++++++++++++++++++++++++++++++++++++++++++</p><p>　　rhel4home This is RHEL 4 data</p><p>　 　注：前面是rsync所提供的数据源，也就是我们在rsyncd.conf中所写的[rhel4home]模块。而“This is RHEL 4 data”是由[rhel4home]模块中的 comment = This is RHEL 4 data 提供的；为什么没有把rhel4opt数据源列出来呢？因为我们在[rhel4opt]中已经把list=no了。</p><p>　　$ rsync –list-only root@192.168.145.5::rhel4home</p><p>　　++++++++++++++++++++++++++++++++++++++++++++++ 　　Welcome to use the mike.org.cn rsync services! 　　 2002——2009 　　++++++++++++++++++++++++++++++++++++++++++++++</p><p>　　Password: 　　drwxr-xr-x 4096 2009/03/15 21:33:13 . 　　-rw-r–r– 1018 2009/03/02 02:33:41 ks.cfg 　　-rwxr-xr-x 21288 2009/03/15 21:33:13 wgetpaste 　　drwxrwxr-x 4096 2008/10/28 21:04:05 cvsroot 　　drwx—— 4096 2008/11/30 16:30:58 easylife 　　drwsr-sr-x 4096 2008/09/20 22:18:05 giddir 　　drwx—— 4096 2008/09/29 14:18:46 quser1 　　drwx—— 4096 2008/09/27 14:38:12 quser2 　　drwx—— 4096 2008/11/14 06:10:19 test 　　drwx—— 4096 2008/09/22 16:50:37 vbird1 　　drwx—— 4096 2008/09/19 15:28:45 vbird2</p><p>　　后面的root@ip中，root是指定密码文件中的用户名，之后的::rhel4home这是rhel4home模块名 ### B2、rsync客户端同步数据；</p><p>　　#rsync -avzP root@192.168.145.5::rhel4home rhel4home 　　Password: 这里要输入root的密码，是服务器端rsyncd.secrets提供的。在前面的例子中我们用的是mike，输入的密码并不回显，输好就回车。</p><p>　 　注： 这个命令的意思就是说，用root用户登录到服务器上，把rhel4home数据，同步到本地当前目录rhel4home上。当然本地的目录是可以你自己 定义的。如果当你在客户端上当前操作的目录下没有rhel4home这个目录时，系统会自动为你创建一个；当存在rhel4home这个目录中，你要注意 它的写权限。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#rsync -avzP  --delete linuxsir@linuxsir.org::rhel4home   rhel4home</span><br></pre></td></tr></table></figure></p><p>　 　这回我们引入一个–delete 选项，表示客户端上的数据要与服务器端完全一致，如果 linuxsirhome目录中有服务器上不存在的文件，则删除。最终目的是让linuxsirhome目录上的数据完全与服务器上保持一致；用的时候要 小心点，最好不要把已经有重要数所据的目录，当做本地更新目录，否则会把你的数据全部删除；</p><p>　　設定 rsync client</p><p>　　设定密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#rsync -avzP  --delete  --password-file=rsyncd.secrets   root@192.168.145.5::rhel4home rhel4home</span><br></pre></td></tr></table></figure></p><p>　　这次我们加了一个选项 –password-file=rsyncd.secrets，这是当我们以root用户登录rsync服务器同步数据时，密码将读取rsyncd.secrets这个文件。这个文件内容只是root用户的密码。我们要如下做；</p><p>　　# touch rsyncd.secrets 　　# chmod 600 rsyncd.secrets 　　# echo “mike”&gt; rsyncd.secrets</p><p>　　# rsync -avzP –delete –password-file=rsyncd.secrets root@192.168.145.5::rhel4home rhel4home</p><p>　　注：这里需要注意的是这份密码文件权限属性要设得只有属主可读。</p><p>　　　　这样就不需要密码了；其实这是比较重要的，因为服务器通过crond 计划任务还是有必要的； ### B3、让rsync客户端自动与服务器同步数据</p><p>　 　服务器是重量级应用，所以数据的网络备份还是极为重要的。我们可以在生产型服务器上配置好rsync 服务器。我们可以把一台装有rysnc机器当做是备份服务器。让这台备份服务器，每天在早上4点开始同步服务器上的数据；并且每个备份都是完整备份。有时 硬盘坏掉，或者服务器数据被删除，完整备份还是相当重要的。这种备份相当于每天为服务器的数据做一个镜像，当生产型服务器发生事故时，我们可以轻松恢复数 据，能把数据损失降到最低；是不是这么回事？？</p><p>　　step1：创建同步脚本和密码文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　#mkdir   /etc/cron.daily.rsync</span><br><span class="line">　　#cd  /etc/cron.daily.rsync </span><br><span class="line">　　#touch rhel4home.sh  rhel4opt.sh </span><br><span class="line">　　#chmod 755 /etc/cron.daily.rsync/*.sh  </span><br><span class="line">　　#mkdir /etc/rsyncd/</span><br><span class="line">　　#touch /etc/rsyncd/rsyncrhel4root.secrets</span><br><span class="line">　　#touch /etc/rsyncd/rsyncrhel4easylife.secrets</span><br><span class="line">　　#chmod 600  /etc/rsyncd/rsync.*</span><br></pre></td></tr></table></figure></p><p>　 　注： 我们在 /etc/cron.daily/中创建了两个文件rhel4home.sh和rhel4opt.sh ，并且是权限是755的。创建了两个密码文件root用户用的是rsyncrhel4root.secrets ，easylife用户用的是 rsyncrhel4easylife.secrets，权限是600；</p><p>　　我们编辑rhel4home.sh，内容是如下的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　#!/bin/sh</span><br><span class="line">　　#backup 192.168.145.5:/home </span><br><span class="line">　　/usr/bin/rsync   -avzP  --password-file=/etc/rsyncd/rsyncrhel4root.secrets    root@192.168.145.5::rhel4home   /home/rhel4homebak/$(date +&apos;%m-%d-%y&apos;)</span><br></pre></td></tr></table></figure></p><p>　　我们编辑 rhel4opt.sh ，内容是： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　#!/bin/sh</span><br><span class="line">　　#backup 192.168.145.5:/opt </span><br><span class="line">　　/usr/bin/rsync   -avzP  --password-file=/etc/rsyncd/rsyncrhel4easylife.secrets    easylife@192.168.145.5::rhel4opt   /home/rhel4hoptbak/$(date +&apos;%m-%d-%y&apos;)</span><br></pre></td></tr></table></figure></p><p>　　注：你可以把rhel4home.sh和rhel4opt.sh的内容合并到一个文件中，比如都写到rhel4bak.sh中；</p><p>　　接着我们修改 /etc/rsyncd/rsyncrhel4root.secrets和rsyncrhel4easylife.secrets的内容； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　# echo &quot;mike&quot; &gt; /etc/rsyncd/rsyncrhel4root.secrets</span><br><span class="line">　　# echo &quot;keer&quot;&gt; /etc/rsyncd/rsyncrhel4easylife.secrets</span><br></pre></td></tr></table></figure></p><p>　 　然后我们再/home目录下创建rhel4homebak 和rhel4optbak两个目录，意思是服务器端的rhel4home数据同步到备份服务器上的/home/rhel4homebak 下，rhel4opt数据同步到 /home/rhel4optbak/目录下。并按年月日归档创建目录；每天备份都存档； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　#mkdir /home/rhel4homebak</span><br><span class="line">　　#mkdir /home/rhel4optbak</span><br></pre></td></tr></table></figure></p><p>　　step2：修改crond服务器的配置文件 加入到计划任务 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　#crontab  -e</span><br></pre></td></tr></table></figure></p><p>　　加入下面的内容：</p><p>　　# Run daily cron jobs at 4:10 every day backup rhel4 data:<br>　　10 4 * * * /usr/bin/run-parts /etc/cron.daily.rsync 1&gt; /dev/null</p><p>　　注：第一行是注释，是说明内容，这样能自己记住。 　　　　第二行表示在每天早上4点10分的时候，运行 /etc/cron.daily.rsync 下的可执行脚本任务； 　　　　 　　配置好后，要重启crond 服务器； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　# killall crond    注：杀死crond 服务器的进程；</span><br><span class="line">　　# ps aux |grep crond  注：查看一下是否被杀死；</span><br><span class="line">　　# /usr/sbin/crond    注：启动 crond 服务器；</span><br><span class="line">　　# ps aux  |grep crond  注：查看一下是否启动了？</span><br><span class="line">　　root      3815  0.0  0.0   1860   664 ?        S    14:44   0:00 /usr/sbin/crond</span><br><span class="line">　　root      3819  0.0  0.0   2188   808 pts/1    S+   14:45   0:00 grep crond</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      rsync的使用与配置
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>文本聚类系列教程：（二）jieba中文分词工具进阶</title>
    <link href="http://weafteam.github.io/posts/931939a5/"/>
    <id>http://weafteam.github.io/posts/931939a5/</id>
    <published>2018-03-19T11:57:19.000Z</published>
    <updated>2018-04-01T12:26:05.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jieba中文分词工具使用进阶篇，废话不多说吗，我们开始本次的学习吧~</p></blockquote><hr><h1 id="如何让分词的更加准确">如何让分词的更加准确</h1><p>我们之前举得例子有些文本其实很简单，我们后来确实换了官方的测试文本《围城》，但是均没避免一个问题，这些测试例都十分地中规中矩。在实际中需要我们做分词的文本可能是多种多样的，这时候的切词有可能会不太特别理想，导致分词的不准确。</p><p>那我们不妨下一个别的电子书（这里我下载的是《斗破苍穹》，为了测试我只用了第一章的文本），然后再进行切词，看下是否存在这样的问题。这里我们稍微改改上次的去停用词的代码，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) <span class="comment"># 获取当前文件的dir路径</span></span><br><span class="line"></span><br><span class="line">text_path = <span class="string">'txt/chapter2.txt'</span> <span class="comment">#《斗破苍穹》第一章的文本路径</span></span><br><span class="line">text = open(path.join(d, text_path),<span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CutWords</span><span class="params">(text)</span>:</span></span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=<span class="keyword">False</span>)</span><br><span class="line">    liststr=<span class="string">"/ "</span>.join(seg_list) <span class="comment"># 添加切分符</span></span><br><span class="line">    <span class="keyword">for</span> myword <span class="keyword">in</span> liststr.split(<span class="string">'/'</span>):</span><br><span class="line">        <span class="keyword">if</span> len(myword.strip())&gt;<span class="number">1</span>:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(mywordlist) <span class="comment">#返回一个字符串</span></span><br><span class="line"></span><br><span class="line">txt5 = CutWords(text)</span><br><span class="line">text_write = <span class="string">'txt/5.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(text_write,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(txt5)</span><br><span class="line">    print(<span class="string">"Success"</span>)</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/20/5ab12557a30b9.png" alt="result_cutwords.png"></p><p>终于被我们找到了一个切词错误，原文是这样的：</p><p>萧媚脑中忽然浮现出三年前那意气风发的少年</p><p>按照我们正常的断句，应为：</p><p>萧媚/脑中/忽然/浮现….，而jieba却认为“萧媚脑”是一个单词，从而导致此处分词不理想。</p><p>jieba考虑了这种情况，而且有很多的应对方案，下面我们先说最简单的。</p><h1 id="调整词典">调整词典</h1><h2 id="方法1动态修改词典">方法1：动态修改词典</h2><p>使用add_word(word,freq=None,tag=None)和del_word(word)可在程序中动态的修改词典，具体操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) <span class="comment"># 获取当前文件的dir路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处增加代码</span></span><br><span class="line">jieba.add_word(<span class="string">'脑中'</span>)</span><br><span class="line"></span><br><span class="line">  ····</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/22/5ab3a2f27d481.png" alt="add_word_test.png"></p><p>果然，这样的方法很直接的把我们原来切错的词变成了正确的词。与add_word()相对应的是delete_word()方法，根据字面意思我们也很容易理解delete_word()方法的作用，这里我就不做过多的演示了，大家在实际场景中直接运用就好了。</p><h2 id="方法2调节词频">方法2：调节词频</h2><p>使用suggest_freq(segment, tune=True)调节单个词语的词频，使得它更容易被分出来，或者不被分出来。</p><p>但是需要注意的是：<strong>自动计算的词频在使用 HMM 新词发现功能时可能无效。</strong></p><p>所以此时我们在做切词的时候需要把是HMM置为False。我们看下官方给的Demo（如果关闭HMM，很多新发现的词都消失了，所以‘萧媚脑’也消失了，无法做测试，我们的例子也是为了方便大家理解，所以也没必要非得针对这一个词做词频调节），具体的做法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到post中将出错。'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">jieba.suggest_freq((<span class="string">'中'</span>, <span class="string">'将'</span>), <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到post中将出错。'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'「台中」正确应该不会被切开'</span>, HMM=<span class="keyword">False</span>)))</span><br><span class="line"></span><br><span class="line">jieba.suggest_freq(<span class="string">'台中'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'「台中」正确应该不会被切开'</span>, HMM=<span class="keyword">False</span>)))</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/22/5ab3b191d1bfd.png" alt="suggest_freq.png"></p><p>对比下结果，不难发现suggest_freq()的使用方法，通过这样的强调高频词和低频词的方法可以做到分词更准确。</p><h1 id="添加自定义词典">添加自定义词典</h1><p>比起默认的词典，我们自定义的词典更适合我们自己的文本，这一点是毋庸置疑的。</p><p>词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。</p><p>这里我们的词典为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">云计算 5</span><br><span class="line">李小福 2 nr</span><br><span class="line">创新办 3 i</span><br><span class="line">easy_install 3 eng</span><br><span class="line">好用 300</span><br><span class="line">韩玉赏鉴 3 nz</span><br><span class="line">八一双鹿 3 nz</span><br><span class="line">台中</span><br><span class="line">凱特琳 nz</span><br><span class="line">Edu Trust认证 2000</span><br></pre></td></tr></table></figure><p>我们这个例子也用官方的Demo，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"../"</span>)</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.load_userdict(<span class="string">"userdict.txt"</span>)</span><br><span class="line"><span class="comment"># jieba在0.28版本之后采用延迟加载方式</span></span><br><span class="line"><span class="comment"># “import jieba”不会立即触发词典的加载，而是在有必要的时候才会加载词典</span></span><br><span class="line"><span class="comment"># 如果想手动加载，可执行代码： jieba.initialize() 进行手动初始化操作</span></span><br><span class="line"><span class="comment"># 也正是有了延迟加载机制，我们现在可以改变主词典的路径：</span></span><br><span class="line"><span class="comment"># jieba.set_dictionary('data/dict.txt.big')</span></span><br><span class="line"><span class="comment"># 官方还提供了占用内存较小的词典和适用于繁体字的词典，均在官方的GitHub上，有需要的可以自行下载。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line"><span class="comment"># pseg切分可以显示词性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下三个操作是修改词典的巩固</span></span><br><span class="line">jieba.add_word(<span class="string">'石墨烯'</span>)</span><br><span class="line">jieba.add_word(<span class="string">'凱特琳'</span>)</span><br><span class="line">jieba.del_word(<span class="string">'自定义词'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_sent = (</span><br><span class="line"><span class="string">"李小福是创新办主任也是云计算方面的专家; 什么是八一双鹿\n"</span></span><br><span class="line"><span class="string">"例如我输入一个带“韩玉赏鉴”的标题，在自定义词库中也增加了此词为N类\n"</span></span><br><span class="line"><span class="string">"「台中」正確應該不會被切開。mac上可分出「石墨烯」；此時又可以分出來凱特琳了。"</span></span><br><span class="line">)</span><br><span class="line">words = jieba.cut(test_sent)</span><br><span class="line">print(<span class="string">'/'</span>.join(words))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"="</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">result = pseg.cut(test_sent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> result:</span><br><span class="line">    print(w.word, <span class="string">"/"</span>, w.flag, <span class="string">", "</span>, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="https://i.loli.net/2018/03/23/5ab46d77c08dc.png" alt="userdict.png"></p><p>像‘云计算’、‘创新办’等词在没加载词典的时候是不能被识别出来的。像‘石墨烯’等在没有add_word()的时候也是不能识别出来的。可见效果还是不错的。</p><h1 id="并行分词">并行分词</h1><p>原理：将目标文本按行分隔后，把各行文本分配到多个 Python 进程并行分词，然后归并结果，从而获得分词速度的可观提升</p><p>但是令人遗憾的是，这个模块并不支持Windows平台，原因是因为jieba的该模块是基于python自带的 multiprocessing 模块，而这个模块并不支持Windows。这里我就贴一下用法，使用Linux系统的同学可以自行体验下这个可观的速度提升。</p><p><strong>用法：</strong></p><ul><li>jieba.enable_parallel(4) # 开启并行分词模式，参数为并行进程数</li><li>jieba.disable_parallel() # 关闭并行分词模式</li></ul><h1 id="最后">最后</h1><p>以上所讲的内容在日常的使用中应该是够用了，当然像基于TextRank算法的关键词抽取等内容，我这里并没涉及，并不是因为不重要，而是我对这个算法还不是很了解，硬着头皮写肯定也是照本宣科，效果肯定很差，所以先挖个坑吧，以后再填。</p><p>感谢阅读~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;jieba中文分词工具使用进阶篇，废话不多说吗，我们开始本次的学习吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1
        
      
    
    </summary>
    
      <category term="文本聚类" scheme="http://weafteam.github.io/categories/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="文本聚类" scheme="http://weafteam.github.io/tags/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>普通的 SQLAlchemy ORM 使用姿势</title>
    <link href="http://weafteam.github.io/posts/39277c31/"/>
    <id>http://weafteam.github.io/posts/39277c31/</id>
    <published>2018-03-18T13:38:54.000Z</published>
    <updated>2018-04-01T12:26:05.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>SQLAlchemy 是 Python 世界中最常用的 SQL 工具之一，包含 SQL 渲染引擎和 ORM 两大部分，平时使用最多的就是 ORM。在我看来平时很多使用 ORM 的姿势是有问题的，或者说是不优雅的。所以这篇文章打算讲讲（搬运）其中一些普通的姿势和技巧（API 文档）。</p><h2 id="property-和混合属性">property 和混合属性</h2><h3 id="property">property</h3><p>下面是一个简单的用户表映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    password = Column(String(<span class="number">128</span>))</span><br></pre></td></tr></table></figure><p>通常情况下，我们会加密用户的密码，在数据库中保存密文，但是这里有一个问题，我们得这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">user = User(name=<span class="string">'zhang'</span>, password=encrypt(<span class="string">'123456'</span>))</span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">user.password = encrypt(<span class="string">'654321'</span>)</span><br></pre></td></tr></table></figure><p>这意味着我们需要不断的重复书写 <code>encrypt</code> 函数来保证加密了用户密码。</p><p>有没有什么方法能省去这一步呢？答案是 <code>property</code>。</p><p>现在把用户表映射改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    _password = Column(String(<span class="number">128</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'write only!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @password.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._password = encrypt(value)</span><br></pre></td></tr></table></figure><p>现在只需要简单的写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">user = User(name=<span class="string">'zhang'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">user.password = <span class="string">'654321'</span></span><br></pre></td></tr></table></figure><p>就可以了。</p><p>关于 Python 中 <code>property</code>和描述符的使用值得再另写一篇文章描述，在这里就不详细说明了。</p><h3 id="混合属性hybrid_property">混合属性（hybrid_property）</h3><p>上面的例子看上去让代码清爽了不少，但是有时候这种用法是无法满足需要的，譬如下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    birthday = Column(DateTime)</span><br></pre></td></tr></table></figure><p>这是一个学生表映射，增加了 <code>birthday</code> 字段。通常我们会保存用户的生日，再通过生日获取用户年龄。有了上面的例子，很容易写出获取年龄的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br></pre></td></tr></table></figure><p>现在可以简单的使用 <code>student.age</code> 获取具体的生日。</p><p>这样做是有缺陷的：如果需要获取所有 18 岁的学生呢？我们希望可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter_by(age=<span class="number">18</span>).all()</span><br></pre></td></tr></table></figure><p>但是却没有任何结果返回。如果改成这样呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now = datetime.now()</span><br><span class="line">start = datetime(now.year - <span class="number">18</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end = end = datetime(now.year + <span class="number">1</span> - <span class="number">18</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">session.query(Student).filter(Student.birthday &gt;= start, Student.birthday &lt; end).all()</span><br></pre></td></tr></table></figure><p>这样倒是可以获取正确的结果了，但是也太丑了点吧？难道没办法写出像第一条一样的既清晰又简洁的查询么？</p><p>答案自然是有的，SQLAlchemy 提供了混合属性（<code>hybrid_property</code>）来处理类似的情况，于是我们可以改写获取年龄的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.hybrid <span class="keyword">import</span> hybrid_property</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @hybrid_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.expression</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - func.year(self.birthday)</span><br></pre></td></tr></table></figure><p>这里将原本的 <code>property</code> 替换为 SQLAlchemy 中的 <code>hybrid_property</code>，同时提供了一个 <code>expression</code> 装饰器，在被装饰的方法中把 Python 代码翻译成 SQL（代码示例的目标数据库为 MySQL，获取日期中的年份的函数为<code>YEAR()</code>，使用其他数据库请查阅对应数据库的相关文档）。有了这个方法，SQLAlchemy 就知道如何在 SQL 语句中处理 <code>age</code> 属性了。</p><p>接下来稍微提一下 <code>hybrid_method</code>。</p><p>和 <code>hybrid_property</code> 类似，只不过可以给 <code>hybrid_method</code> 传参数。下面这个例子不太合适，只为了展示<code>hybrid_method</code> 的功能。</p><p>如何找到所有 90 后同学？当然我们可以复用上面的 <code>age</code> 属性，先计算一下 90 后的同学现在多少岁，然后直接写在查询里就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter(Student.age &gt;= now.year - <span class="number">1990</span>, Student.age &lt; now.year - <span class="number">2000</span>).all()</span><br></pre></td></tr></table></figure><p>如果要判断某个学生是否是 90 后呢？又需要再写一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> now.year - <span class="number">2000</span> &gt; student.age &gt;= now.year - <span class="number">1990</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>出现了很多不直观的代码，这时候可以使用 <code>hybrid_method</code> 简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @hybrid_method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">born_after</span><span class="params">(self, years)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> years + <span class="number">10</span> &gt; self.birthday.year &gt;= years</span><br><span class="line"></span><br><span class="line"><span class="meta">    @born_after.expression</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">born_after</span><span class="params">(self, years)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> and_(func.year(self.birthday) &lt; years + <span class="number">10</span>, func.year(self.birthday) &gt;= years)</span><br></pre></td></tr></table></figure><p>于是现在可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session.query(Student).filter(Student.born_after(<span class="number">1990</span>)).all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> student.born_after(<span class="number">1990</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>看上去好了一些（误</p><p>这一部分就到此为止，当然 hybrid 在 SQLAlchemy 中的用法不止上述这些，更详细和复杂的内容参见官方文档。</p><h2 id="关联代理association_proxy">关联代理（association_proxy）</h2><h3 id="简化标量集合">简化标量集合</h3><p>关联代理用在有关联的表中，所以我们先创建如下映射关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">association = Table(<span class="string">'association'</span>, Base.metadata,</span><br><span class="line">                    Column(<span class="string">'blog_id'</span>, Integer, ForeignKey(<span class="string">'blog.id'</span>), primary_key=<span class="keyword">True</span>),</span><br><span class="line">                    Column(<span class="string">'tag_id'</span>, Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'blog'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    tags = relationship(</span><br><span class="line">        <span class="string">'Tag'</span>, secondary=association, backref=backref(<span class="string">'blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'dynamic'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'tag'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p>一个经常被拿出来作为演示的 Many-To-Many 模型。</p><p>先填充一些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: blog = Blog(name=<span class="string">'first'</span>)</span><br><span class="line">In [<span class="number">2</span>]: blog.tags.append(Tag(name=<span class="string">'t1'</span>))</span><br><span class="line">In [<span class="number">3</span>]: blog.tags.append(Tag(name=<span class="string">'t2'</span>))</span><br><span class="line">In [<span class="number">4</span>]: session.add(blog)</span><br><span class="line">In [<span class="number">5</span>]: session.commit()</span><br></pre></td></tr></table></figure><p>接下来就可以获取这些对象的所有信息了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: blog.tags.all()</span><br><span class="line">Out[<span class="number">4</span>]: [&lt;Tag at <span class="number">0x1fdbab6f198</span>&gt;, &lt;Tag at <span class="number">0x1fdbab6f208</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: blog.tags.all()[<span class="number">0</span>].name</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'t1'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: [t.name <span class="keyword">for</span> t <span class="keyword">in</span> blog.tags]</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br></pre></td></tr></table></figure><p>上面的操作有点复杂。对我们而言，<code>Tag</code> 对象只有 <code>name</code> 字段是有用的，为了获取 <code>name</code> 字段，我们要写很多额外的代码把 <code>name</code> 字段从 <code>Tag</code> 对象中剥离出来。<code>association_proxy</code> 就可以用来简化这个操作。</p><p>现在修改一下上面的 <code>Blog</code> 映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.associationproxy <span class="keyword">import</span> association_proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tag_objects = relationship(</span><br><span class="line">        <span class="string">'Tag'</span>, secondary=association, backref=backref(<span class="string">'blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'dynamic'</span>)</span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>)</span><br></pre></td></tr></table></figure><p>增加了一行 <code>association_proxy</code> 对象的声明，现在我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: blog.tags</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br></pre></td></tr></table></figure><p>现在查询操作变得很简单了，但是新增标签的操作还是很麻烦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.tag_objects.append(Tag(name=<span class="string">'t3'</span>))</span><br></pre></td></tr></table></figure><p>还是需要实例化一个 <code>Tag</code> 对象，能不能直接写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.tags.append(<span class="string">'t4'</span>)</span><br></pre></td></tr></table></figure><p>当然是可以的，只要再修改一下 <code>association_proxy</code> 的声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>, creator=<span class="keyword">lambda</span> name: Tag(name=name))</span><br></pre></td></tr></table></figure><p>参数 <code>creator</code> 接受一个可调用对象，它告诉 <code>association_proxy</code> 如何处理“新增”操作。</p><p><strong>注意</strong>：<code>creator</code> 的默认参数是被代理对象的构造函数，如果提供了一个单参数的构造函数，那么可以省略 <code>creator</code> 参数。</p><h3 id="简化关联对象">简化关联对象</h3><p>上面的例子里把 <code>association</code> 表作为一个普通的 <code>Table</code> 对象，是因为 <code>association</code> 中不需要保存额外信息，只需要作为 <code>Blog</code> 和 <code>Tag</code> 的中转。现在有了新的需求，我们需要知道每篇博客的标签是在什么时候加上的，这就需要在 <code>association</code> 表中增加一个额外的字段用来表示创建时间，同时为了获取这个时间，还要把 <code>association</code> 改造成一个真正的映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Association</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'association'</span></span><br><span class="line"></span><br><span class="line">    blog_id = Column(Integer, ForeignKey(<span class="string">'blog.id'</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">    tag_id = Column(Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">    created_at = Column(DateTime, default=datetime.now)</span><br><span class="line"></span><br><span class="line">    blog = relationship(<span class="string">'Blog'</span>, backref=backref(<span class="string">'blog_tags'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line">    tag = relationship(<span class="string">'Tag'</span>, backref=backref(<span class="string">'tag_blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'tag'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'blog'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p>这里实际上是把 Many-To-Many 拆成了两个 One-To-Many。</p><p>然后构造一些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In  [<span class="number">1</span>]: blog = Blog(name=<span class="string">'first'</span>)</span><br><span class="line">    ...: tags = [Tag(name=<span class="string">'t1'</span>), Tag(name=<span class="string">'t2'</span>)]</span><br><span class="line">    ...: <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">    ...:     session.add(Association(blog=blog, tag=tag))</span><br><span class="line">    ...: session.add(blog)</span><br><span class="line">    ...: session.add_all(tags)</span><br><span class="line">    ...: session.commit()</span><br></pre></td></tr></table></figure><p>现在就可以获取 <code>Tag</code> 和被添加的时间了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: blog.blog_tags[<span class="number">0</span>].tag.name</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'t1'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: blog.blog_tags[<span class="number">0</span>].created_at</span><br><span class="line">Out[<span class="number">3</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>可以看到，给 <code>Blog</code> 增加标签要经过 <code>Association</code> 这个中间对象。虽然表结构的确如此，但是我们仍然希望 <code>Association</code> 表是透明的，仅当需要获取其中的创建时间时才明确获取 <code>Association</code> 对象。只需要在 <code>Blog</code> 中声明一个关联代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tags = association_proxy(<span class="string">'blog_tags'</span>, <span class="string">'tag'</span>, creator=<span class="keyword">lambda</span> tag: Association(tag=tag))</span><br></pre></td></tr></table></figure><p>然后就可以这样写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: blog.tags[<span class="number">0</span>].name</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'t1'</span></span><br></pre></td></tr></table></figure><p>添加新的 <code>Tag</code> 也方便了很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In  [<span class="number">3</span>]: <span class="keyword">for</span> tag <span class="keyword">in</span> [Tag(name=<span class="string">'t3'</span>), Tag(name=<span class="string">'t4'</span>)]:</span><br><span class="line">    ...:     blog.tags.append(tag)</span><br></pre></td></tr></table></figure><h3 id="混合关联代理">混合关联代理</h3><p>现在回到了第一个问题的出发点，能不能在上一个例子的基础上简化 <code>tags</code> 的调用呢？同样没问题，只要在 <code>Association</code> 中加一个关联代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Association</span><span class="params">(Base)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tag_objects = relationship(<span class="string">'Tag'</span>, backref=backref(<span class="string">'tag_blogs'</span>, lazy=<span class="string">'dynamic'</span>), lazy=<span class="string">'joined'</span>)</span><br><span class="line">    tags = association_proxy(<span class="string">'tag_objects'</span>, <span class="string">'name'</span>, creator=<span class="keyword">lambda</span> name: Tag(name=name))</span><br></pre></td></tr></table></figure><p>然后用起来就和第一个例子一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: blog.tags</span><br><span class="line">Out[<span class="number">1</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: blog.tags.append(<span class="string">'t3'</span>)</span><br><span class="line">In [<span class="number">3</span>]: blog.tags</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">'t1'</span>, <span class="string">'t2'</span>, <span class="string">'t3'</span>]</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>上述内容并没有很复杂的操作，都是一些易于实现并且可以改善日常使用体验的方法。SQLAlchemy 还有很多骚操作可以讲，但是受限于本人的姿势水平，很多并没有实际使用过，也谈不上有什么见解。那就这样吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;SQLAlchemy 是 Python 世界中最常用的 SQL 工具之一，包含 SQL 渲染引擎和 ORM 两大部分，平时使用最多的就是 ORM。在我看来平时很多使用 ORM
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本聚类系列教程：（一）jieba中文分词工具入门</title>
    <link href="http://weafteam.github.io/posts/575e441b/"/>
    <id>http://weafteam.github.io/posts/575e441b/</id>
    <published>2018-03-17T09:20:22.000Z</published>
    <updated>2018-04-01T12:26:05.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习文本分类（聚类）的相关知识，所以接下来准备先写一个关于这个方面的系列博客。</p></blockquote><hr><h1 id="写在前面">写在前面：</h1><p>先介绍下由我们四个人组成的组织：FOUR ELEMENTS。四元素分别对应WELL、EARTH、AIR、FLAME，根据首字母缩写，我们的博客主页得名WEAF。</p><p>接下来介绍下我自己，我叫Leno，对应于四元素里面的Well，目前研究生在读，方向为智能信息处理。我的博客主要会以日常遇到的问题以及学习的知识为主。</p><hr><h1 id="简单的介绍">简单的介绍：</h1><p>首先，我们要做的是对中文文本的聚类，如果做聚类的话，我们需要对文本的内容做分析，而分析的最小单位肯定是词。</p><p>其次，中文和英文的词是有区别的，最大的区别就是中文的词与词之间并不是用空格分隔开的，而且由于中国文化的博大精深，切词的时候我们需要考虑的词语组合情况就更多了。显然让我们自己去造一个这样的轮子有点不现实，其实像这样的工具，前辈们已经为我们做好了，而且超好用。</p><p>本文介绍的就是jieba中文分词，正如它的口号那样。如下图所示： <img src="https://i.loli.net/2018/03/17/5aace9320fbc3.png" alt="jieba.png"></p><p>当然，这里有两本秘籍<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">GitHub</a> &amp;&amp; <a href="http://www.oschina.net/p/jieba" target="_blank" rel="noopener">OSChina</a>，既然你我有缘，便免费赠予你。</p><hr><h1 id="安装">安装</h1><p>这年头，没有什么是一句pip install 解决不了的。不管2或者3，直接pip即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure><hr><h1 id="结合官方demo理解jieba的三种切词模式">结合官方Demo理解jieba的三种切词模式</h1><p><strong>三种模式：</strong></p><ul><li>精确模式（默认模式）：它会试图将句子最精确的切开，适合文本分析。</li><li>全模式：不考虑歧义，这个模式会将所有的可以成词的词语都扫描出来，因而速度会非常快。</li><li>搜索引擎模式：该模式是在精确模式的基础上，对长词再进行切分，提高召回率，适用于搜索引擎分词。</li></ul><p><strong>官方Demo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;我来到北京清华大学&quot;, cut_all=True)</span><br><span class="line">print(&quot;全模式: &quot; + &quot;/ &quot;.join(seg_list))  # 全模式</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;我来到北京清华大学&quot;, cut_all=False)</span><br><span class="line">print(&quot;精确模式: &quot; + &quot;/ &quot;.join(seg_list))  # 精确模式</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;)  # 默认是精确模式</span><br><span class="line">print(&quot;默认模式：&quot; + &quot;/ &quot;.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut_for_search(&quot;小明硕士毕业于中国科学院计算所，后在日本京都大学深造&quot;)  # 搜索引擎模式</span><br><span class="line">print(&quot;搜索引擎模式：&quot; + &quot;/ &quot;.join(seg_list))</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/17/5aacfab51d67e.png" alt="Demo1.png"></p><p><strong>模式分析：</strong></p><p>这里我们先分析这三种模式，对于cut方法的讲解在后边会给出，so不要问我为啥不给出cut方法中第三个参数HMM。</p><p>通过对比前两条输出可以看出全模式情况下，它会找出所有可以组成词的划分，而精确模式与其对比给出的答案就会很清爽。所以结合上文所说，不难理解这两个模式的区别。</p><p>接下来我们看第四条输出，它是在精确模式的基础上对长词再做的划分。所以‘日本京都大学’，它会再次切分为‘日本’，‘京都’，‘大学’三个词，同理适用于‘中国科学院’。所以这个模式也不难理解吧。</p><p><strong>补充分析：</strong></p><p>最后看第三条输出内容，也许你会问，既然知道默认模式是精确模式了，为啥还要给出试例，况且还是一个不具有对比性质的对比。这里其实想说明的是：</p><p>‘杭研’并没有在词典中，但是jieba的Viterbi算法也将其识别了出来。</p><p>这时我们就需要考虑HMM这个参数了，关于HMM（Hidden Markov Model，HMM：隐马尔可夫模型），如果深究，那就需要另外一篇博文了，所以我们只要能理解官方给出的这句话即可：<strong>对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法。</strong></p><p>可能说的比较干涩，我们实际测一下吧。</p><p><strong>补充测试代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;,HMM=False)</span><br><span class="line">print(&quot;HMM为False：&quot; + &quot;/ &quot;.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(&quot;他来到了网易杭研大厦&quot;,HMM=True)</span><br><span class="line">print(&quot;HMM为True：&quot; + &quot;/ &quot;.join(seg_list))</span><br></pre></td></tr></table></figure><p><strong>补充测试结果：</strong></p><p><img src="https://i.loli.net/2018/03/17/5aad1051896b9.png" alt="Demo1plus.png"></p><p>所以<strong>一般情况下</strong>，使用cut方法，不用考虑HMM这个参数就可以，让它默认为True即可，让Viterbi算法为我们识别新词。HMM也能有效的解决中文中的歧义问题。</p><p><strong>启用HMM并不适用所有情况，根据需要开启！！！</strong></p><p>关于切词的方法以及切词的注意事项，请大家参考上文给出的两个链接，这里我不再赘述。</p><hr><h1 id="基于tf-idf的关键词提取">基于TF-IDF的关键词提取</h1><p><strong>相关知识：</strong></p><p>对于一个文档，我们肯定不会对所有的词进行聚类，所以我们需要对文档进行关键词提取。</p><p>下面我们对TF-IDF做一下简单的说明。如果单讲这个知识点，拿出来又是一篇博文。不过后续我也会写一篇关于它的博文。暂时请大家自行查阅相关资料学习。</p><p>TF-IDF是一种统计方法，用于评估一个词对于一个文件集或者语料库中的一份文件的重要程度。</p><p>TF(term frequency)：指的是某一个给定的词语在该文件中出现的频率。公式如下：</p><p><span class="math inline">\(tf_i,_j = \frac{n_i,_j}{\sum_k n_k,_j}\)</span></p><p>IDF(Inverse document frequency)：是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p><p><span class="math inline">\(idf(t,D) = log(\frac{N}{\lvert {d \in D, t \in d}\rvert})\)</span></p><p><strong>关键词提取：</strong></p><p>官方给了一个代码示例文件，源代码在这里：<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags.py" target="_blank" rel="noopener">关键词提取源码</a> 但是为了结果显示得更清晰一点，我做了些许的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;../&apos;)</span><br><span class="line"></span><br><span class="line">import jieba</span><br><span class="line">import jieba.analyse</span><br><span class="line">from optparse import OptionParser</span><br><span class="line"></span><br><span class="line">USAGE = &quot;usage:    python extract_tags.py [file name] -k [top k]&quot;</span><br><span class="line"></span><br><span class="line">parser = OptionParser(USAGE)</span><br><span class="line">parser.add_option(&quot;-k&quot;, dest=&quot;topK&quot;)</span><br><span class="line">opt, args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if len(args) &lt; 1:</span><br><span class="line">    print(USAGE)</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">file_name = args[0]</span><br><span class="line"></span><br><span class="line">if opt.topK is None:</span><br><span class="line">    topK = 20</span><br><span class="line">else:</span><br><span class="line">    topK = int(opt.topK)</span><br><span class="line"></span><br><span class="line">content = open(file_name, &apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=topK,withWeight=True)</span><br><span class="line"></span><br><span class="line">for i in tags :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>先说下用法，官方在文件的第8行给出了用法，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python extract_tags.py [file name] -k [top k]</span><br></pre></td></tr></table></figure><p>将这个Extract_tags.py文件和文本文件放在同一目录下，然后给利用如上命令便可得到文本的关键词。默认取得是top10，我改了下取了top20，我们这里做下测试（使用jieba的官方测试文档：《围城》），结果如下：</p><p><img src="https://i.loli.net/2018/03/18/5aade4db4fb52.png" alt="extract.png"></p><p><strong>分析：</strong></p><p>官方给的代码看着挺长，实际上超简单，其中重要的无非两句话，一句是读文件，另一句则是调用extract_tags()方法，我在原有的基础上设置了withWight=True，因而返回了一个权重值。大家如果嫌麻烦可以对上述关键代码进行抽取，写一个自己的测试。</p><hr><p>正如上图所示，‘自己’、‘知道’、‘先生’等等等等，像这些词语都是些没有实际意义的单词，所以在聚类的时候这些单词不应该做为聚类（或者分类）的标准，它们属于stop_words，中文的意思就是停用词，所以我们接下来处理这个问题。</p><h1 id="去除停用词">去除停用词</h1><p>去除停用词，我们需要知道哪些属于停用词，我在CSDN上找到了一个1893规模的停用词表，链接如下：<a href="http://blog.csdn.net/shijiebei2009/article/details/39696571" target="_blank" rel="noopener">最全中文停用词表整理（1893个）</a>。</p><p>我们接下来的工作思路是这样的，对《围城》（文件1.txt）进行切词，方法就是之前的cut()，读取StopWords文件，对比每个切分出来的单词是否是停用词，如果不是则加入到一个list中，然后再将这个list的内容存到另一个文件2.txt中，对文件2.txt使用之前说到的官方给的关键词提取文件做关键词提取即可。</p><p>去除停用词代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import jieba</span><br><span class="line">from os import path</span><br><span class="line"></span><br><span class="line">d = path.dirname(__file__) # 获取当前文件的dir路径</span><br><span class="line">stopwords_path = &apos;stopwords1893.txt&apos;  # 停用词表路径</span><br><span class="line"></span><br><span class="line">text_path = &apos;txt/1.txt&apos; #《围城》的文本路径</span><br><span class="line">text = open(path.join(d, text_path),&apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">def RmStopWords(text):</span><br><span class="line">    mywordlist = []</span><br><span class="line">    seg_list = jieba.cut(text, cut_all=False)</span><br><span class="line">    liststr=&quot;/ &quot;.join(seg_list) # 添加切分符</span><br><span class="line">    f_stop = open(stopwords_path)</span><br><span class="line">    try:</span><br><span class="line">        f_stop_text = f_stop.read()</span><br><span class="line">    finally:</span><br><span class="line">        f_stop.close( )</span><br><span class="line">    f_stop_seg_list=f_stop_text.split(&apos;\n&apos;) # 停用词是每行一个，所以用/n分离</span><br><span class="line">    for myword in liststr.split(&apos;/&apos;):</span><br><span class="line">        #对于每个切分的词都去停用词表中对比</span><br><span class="line">        if not(myword.strip() in f_stop_seg_list) and len(myword.strip())&gt;1:</span><br><span class="line">            mywordlist.append(myword)</span><br><span class="line">    return &apos;&apos;.join(mywordlist) #返回一个字符串</span><br><span class="line"></span><br><span class="line">txt2 = RmStopWords(text)</span><br><span class="line">text_write = &apos;txt/2.txt&apos;</span><br><span class="line">with open(text_write,&apos;w&apos;) as f:</span><br><span class="line">    f.write(txt2)</span><br><span class="line">    print(&quot;Success&quot;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.loli.net/2018/03/18/5aadf03b5ddc2.png" alt="RmStopWords.png"></p><p><strong>分析：</strong></p><p>由上图可见，我们的去停用词的效果还不错。</p><h1 id="最后">最后：</h1><p>这篇博客先写到这里，下一篇博客我会讲到jieba中文分词的进阶篇。感谢阅读，如有问题可以通过邮件与我交流，邮箱：cliugeek@us-forever.com</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近在学习文本分类（聚类）的相关知识，所以接下来准备先写一个关于这个方面的系列博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;写在前面：&lt;/h1&gt;
&lt;p&gt;先介绍下由我们四个人组成的组织：FOUR
        
      
    
    </summary>
    
      <category term="文本聚类" scheme="http://weafteam.github.io/categories/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="文本聚类" scheme="http://weafteam.github.io/tags/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从数据库的设置与Xtrabackup备份InnoDB(MySQL)</title>
    <link href="http://weafteam.github.io/posts/2f5dded6/"/>
    <id>http://weafteam.github.io/posts/2f5dded6/</id>
    <published>2018-03-17T08:08:56.000Z</published>
    <updated>2018-04-01T12:26:05.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一准备环境">一、准备环境</h2><ol type="1"><li>两台服务器：服务器A、服务器B</li><li>服务器A：Red Hat Enterprise Linux Server release 6.5 (Santiago)</li><li>服务器B：Red Hat Enterprise Linux Server release 6.5 (Santiago)</li><li>服务器A IP：172.16.125.50</li><li>服务器B IP：172.16.125.52</li><li>MySQL版本：5.6.23</li></ol><h2 id="二安装mysql">二、安装MySQL</h2><p>具体安装请见</p><ol type="1"><li><a href="http://us-forever.com/2018/01/15/LinuxMySQL的安装/" target="_blank" rel="noopener">LinuxMySQL的安装(1)</a></li><li><a href="http://us-forever.com/2018/02/02/LinuxMySQL的安装-2/" target="_blank" rel="noopener">LinuxMySQL的安装(2)</a></li><li><a href="http://us-forever.com/2018/02/08/LinuxMySQL的安装-3/" target="_blank" rel="noopener">LinuxMySQL的安装(3)</a></li></ol><a id="more"></a><h2 id="三主从库配置">三、主从库配置</h2><h3 id="主库在etcmy.cnf里添加以下内容">1、主库在/etc/my.cnf里添加以下内容</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#log日志</span></span><br><span class="line"><span class="attr">log_bin</span>=mysql_bin</span><br><span class="line"><span class="comment">#server ID</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">#忽略同步的库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=information_schema</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=cluster</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=mysql</span><br><span class="line"><span class="comment">#需要同步的库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=test</span><br></pre></td></tr></table></figure><h3 id="从库在etcmy.cnf里添加以下内容">2、从库在/etc/my.cnf里添加以下内容</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">log_bin=mysql_bin</span><br><span class="line">server_id=3</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=cluster</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">replicate-do-db=ufind_db</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">log-slave-updates</span><br><span class="line">slave-skip-errors=all</span><br><span class="line">slave-net-timeout=60</span><br></pre></td></tr></table></figure><h2 id="四主从库设置">四、主从库设置</h2><h3 id="进入主库我们在主库中创建一个的账户从库通过使用这个账号来同步数据">1、进入主库，我们在主库中创建一个的账户，从库通过使用这个账号来同步数据。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><h3 id="赋予相应的权限">2、赋予相应的权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">FILE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'172.16.125.52'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><h3 id="重启数据库主库执行以下命令">3、重启数据库（主库）执行以下命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><p><img src="http://us-forever.com/img/mysqlsync.png"> 要记住以上的信息，在设置从库的时候需要填写并设置。</p><h3 id="在从库里边执行以下命令">4、在从库里边执行以下命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master to master_host=&apos;172.16.125.50&apos;,master_user=&apos;repl&apos;,master_password=&apos;123456&apos;,master_log_file=&apos;mysql_bin.000023&apos;, master_log_pos=120;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h3 id="然后执行一下命令查看状态">5、然后执行一下命令查看状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure><p>内容如下： <img src="http://us-forever.com/img/mysqlsync1.png"> <img src="http://us-forever.com/img/mysqlsync2.png"></p><h3 id="测试与提示">6、测试与提示</h3><p>后期的测试中我们只针对<strong>test</strong>库进行了同步。 所以只能针对<strong>test</strong>进行的操作才有效。</p><p>如果后期对一些列库进行操作，需要 添加相应的配置 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>主库配置文件</span><br><span class="line">binlog-do-db=test</span><br><span class="line"><span class="meta">#</span>从库配置文件</span><br><span class="line">replicate-do-db=test</span><br></pre></td></tr></table></figure></p><p>并查询出最新的master的状态，停止从库。并改变从库的配置重启同步。 五、Xtrabackup的简单介绍 ——————- Percona XtraBackup 是世界上唯一的开源免费的MySQL热备份软件，可以执行非阻塞操作 InnoDB和XtraDB数据库的备份。 Percona XtraBackup可提供以下优点：</p><ul><li>备份快速安全可靠</li><li>备份期间不间断的事务处理</li><li>节省磁盘空间和网络带宽</li><li>自动备份验证</li><li>更快的恢复时间保证正常工作</li></ul><p>Percona XtraBackup 为所有版本的Percona服务器，MySQL和MariaDB提供MySQL热备份。 它可执行 流媒体，压缩和增量MySQL备份。</p><h2 id="六xtrabackup的安装">六、Xtrabackup的安装</h2><p>如果在互联网下 可使用以下命令安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>获取相应rpm包 安装部分依赖(不同的操作系统可能已安装的库不尽相同) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-compat-5.7.20-1.el7.x86_64.rpm</span><br><span class="line"><span class="meta">#</span>根据mysql版本而定</span><br><span class="line">yum list|grep perl</span><br><span class="line">yum -y install perl-DBI.x86_64 perl-DBD-MySQL.x86_64</span><br></pre></td></tr></table></figure></p><p>然后安装Xtrabackup <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>参考： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cmake gcc gcc-c++ libaio libaio-devel automake autoconf bison libtool ncurses-devel libgcrypt-devel libev-devel libcurl-devel vim-common</span><br></pre></td></tr></table></figure></p><h2 id="七xtrabackup备份mysql">七、Xtrabackup备份MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --defaults-file=/etc/my.cnf --user=root --password=root --host=localhost --backup --target-dir=/data/backups/</span><br><span class="line">可指定数据库--databases=test</span><br></pre></td></tr></table></figure><h2 id="八xtrabackup的备份恢复">八、Xtrabackup的备份恢复</h2><p>备份之前必须先关闭MySQL server 然后删除data目录（/var/lib/mysql一般情况是这个） <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup  --copy-back --target-dir=/data/backups/</span><br></pre></td></tr></table></figure></p><p>执行完恢复之后需要设置文件权限 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure></p><p>然后启动mysql <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br><span class="line"><span class="meta">#</span>或者使用服务</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure></p><h2 id="九使用脚本自动备份7天之内的数据">九、使用脚本自动备份7天之内的数据</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># Database info</span><br><span class="line">DB_USER="root"</span><br><span class="line">DB_PASS="root"</span><br><span class="line">DB_HOST="localhost"</span><br><span class="line"></span><br><span class="line"># Others vars</span><br><span class="line">BCK_DIR="/opt/app/mysqlbackup"    #the backup file directory</span><br><span class="line">CONF_DIR="/etc/my.cnf"</span><br><span class="line">DATE=`date +%F`</span><br><span class="line">RMDATE=`date -d '-7 day' +%F`</span><br><span class="line"></span><br><span class="line"># TODO</span><br><span class="line"></span><br><span class="line">mkdir -p $BCK_DIR/$DATE/</span><br><span class="line">#Create dir for save backup data</span><br><span class="line">xtrabackup --defaults-file=$CONF_DIR --user=$DB_USER --password=$DB_PASS --host=$DB_HOST --backup --target-dir=$BCK_DIR/$DATE/</span><br><span class="line">#Backup mysql data</span><br><span class="line">rm -rf $BCK_DIR/$RMDATE</span><br><span class="line">#Delete the backup 7 days ago</span><br><span class="line">#热备份数据库</span><br></pre></td></tr></table></figure><p>加入crontab <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * * /bin/sh /home/scripts/mysqlbackup.sh</span><br></pre></td></tr></table></figure></p><p><a href="https://learn.percona.com/hubfs/Manuals/Percona_Xtra_Backup/Percona_XtraBackup_2.4/Percona-XtraBackup-2.4.9.pdf" target="_blank" rel="noopener">更多请参考官方文档</a></p>]]></content>
    
    <summary type="html">
    
      MySQL主从数据库的设置与Xtrabackup备份InnoDB(MySQL)
    
    </summary>
    
      <category term="Linux" scheme="http://weafteam.github.io/categories/Linux/"/>
    
    
      <category term="Linux运维" scheme="http://weafteam.github.io/tags/Linux%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>chapter-01-AIR</title>
    <link href="http://weafteam.github.io/posts/8e8e4531/"/>
    <id>http://weafteam.github.io/posts/8e8e4531/</id>
    <published>2018-03-14T10:49:23.000Z</published>
    <updated>2018-04-01T12:26:05.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章-tensorflow-install">第一篇文章-TensorFlow Install</h1><ol type="1"><li>首先介绍一些我们这个组织，这是有四个人构成得一个组织，组织可以叫FOUR ELEMENTS。（也可以叫WEAF）分别对应WELL、EARTH、AIR、FLAME。（WEAF）。</li><li>其次我想做一下自我介绍，我的英文学名叫milittle。我开设的这个周刊名字叫AIR-周刊。希望把自己学习的一些内容分享给大家，也激励自己。学更多的知识。以后大家有什么要交流的，也可以一起交流。（邮箱地址会在文章末尾给出）</li></ol><p>接下来我讲一下我后续每周在<code>AIR-周刊</code>里面会讲到的内容：</p><ul><li>主要涉及TensorFlow框架使用多一些</li><li>后续也会分享一些机器学习方面的算法</li><li>也会有一些在人工智能方面的杂谈</li></ul><p>上面说了一些，我想把这块做好，文章内容有什么变化，后续的文章里面会有所提及。</p><p>今天就介绍一些TensorFlow的简述和安装：</p><ol type="1"><li>TensorFlow是Google公司在2015年12月份开源的一个机器学习库，代码链接<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFLow</a>。</li><li>第二点为什么现在TensorFlow这么火，在人工智能界已经算得上是称霸的地位，我们可以从下面的图中可以看出TensorFlow的数据占据了一大半市场。</li></ol><p><img src="https://s1.ax1x.com/2018/03/14/94kzp6.jpg" alt="-"></p><ol start="3" type="1"><li>原因是什么呢<ul><li>最主要的原因就是本身具有图运算的这个概念。使用简单，而且可以让程序员快捷的实现一些算法。从而可以用TensorFlow解决一些现实中的问题。图运算的概念我们后续会慢慢深入。大家不要着急。</li><li>还有一个原因，我想不用说大家也都知道，既然说了是Google的开源框架，那么技术就一定很牛逼。引得广大程序员的喜爱也是必然发生的事情。</li><li>而且用这个框架可以快速的解决一些机器学习的算法问题。是的编程效率也不断提高。</li></ul></li><li>TensorFlow支持Mac、Windows、Linux。以后我们的实验有可能通过Windows进行，也有可能在Linux进行，而且以后的代码都是基于python3.X，所以希望大家可以实现基本的python3的语法知识和编程知识。还有就是TensorFlow支持CPU版本和GPU版本，安装的时候都有很多的注意事项，基于GPU版本的可能会比较麻烦。但是后续我会给大家出一个教程，分别在Windows下面和Linux下面配置自己的独立环境。让你的机器学习算法跑在你自己的机器上面。完成一些看起来炫酷的程序。</li></ol><p>接下来我介绍一下TensorFlow的Windows CPU安装方法：</p><ol type="1"><li>首先打开电脑，这个是一定的~</li><li>去TensorFlow的<a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">官网</a>下载Windows的版本。点击下面红色箭头的地方—随意，都可以跳转到一个关于windows安装的界面。（可能需要科学上网，逃）</li></ol><p><img src="https://s1.ax1x.com/2018/03/14/94AS1K.png" alt="-"></p><ol start="3" type="1"><li>点开界面以后的注意事项：<ul><li>windows7及其以后的操作系统版本</li><li>决定安装哪个TensorFlow的版本，GPU还是CPU（GPU会有有一些第三方的库依赖，CUDA），接下来我们的教程是CPU版本安装。</li><li>决定怎么安装TensorFlow：可选方式有native pip 和 Anaconda等（我们使用Anaconda）</li><li>最后一步验证你的安装效果</li></ul></li></ol><p>接下来一步一步来：</p><p>第一步、我们决定用Anaconda来安装TensorFlow，你要知道Anaconda是什么呢，它就是可以很好的管理python的一些依赖库。让你在不同python版本之间切换自如。所以我们使用这个工具来安装我们的TensorFlow。Anaconda也可以集成Spyder这些编程工具，使得你编写代码会方便一些。</p><p>第二步、首先你去<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda官网</a>下载windows版本的Anaconda，具体安装就和普通的安装软件类似。这个地方需要注意的是不同python版本需要不同的Anaconda，别下错了。</p><p>第三步、安装好以后，我们打开Anaconda的控制台，就是开始里面找到Anaconda的应用，然后里面有一个Anaconda Prompt。打开以后，我们就开始了我们创建一个独立的TensorFlow独立的环境。</p><blockquote><p><code>conda create -n tensorflow pip python=3.5</code></p><p>上面这命令的意思就是说在Anaconda管理的环境里面给我独立的创建一个python环境来，这个里面python的版本是3.5。注意一下，这个地方还没有安装tensorflow呢，上面的tensorflow只不过是创建的一个环境名字而已。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kjt1.png" alt="-"></p><blockquote><p><code>activate tensorflow</code></p><p>上面的命令是激活这个tensorflow的环境，你可以通过这个环境，添加一些你自己的python库，定制自己的python环境，这也是我使用Anaconda的原因，但是并不是只有Anaconda支持这样的方式。不要和我抬杠。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kXkR.png" alt="-"></p><p>第四步，也就是正儿八经的安装TensorFlow的阶段，<strong>这里解释一下，上面为什么我执行的是tensorflow1，因为我的电脑上面已经有tensorflow这个环境了</strong></p><blockquote><p><code>pip install --ignore-installed --upgrade tensorflow</code></p><p>这个命令就是使用pip正常的安装tensorflow，这里的pip管理起来和普通的pip管理是一个道理，这里就不赘述了。</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/14/94kL79.png" alt="-"></p><p>第五步，测试TensorFlow是否安装上</p><blockquote><p><code>python</code></p><p>上面的命令是进入python解释器，然后执行下面的import语句</p><p><code>import tensorflow as tf</code></p><p>如果上面的命令执行完，如下图中一样，就算安装成功了，下面的那些语句是写了一个hello world！！！</p></blockquote><p><img src="https://s1.ax1x.com/2018/03/22/9Hf66P.png" alt="-"></p><p>今天是为了我们以后在TensorFlow上开发所做的准备。希望大家安装顺利。我的个人邮箱是air@weaf.top。有什么问题可以单独发邮件问我。感谢你们的驻足。有什么不好的地方，可以给出意见。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;第一篇文章-tensorflow-install&quot;&gt;第一篇文章-TensorFlow Install&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;首先介绍一些我们这个组织，这是有四个人构成得一个组织，组织可以叫FOUR
        
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://weafteam.github.io/tags/TensorFlow/"/>
    
  </entry>
  
</feed>
